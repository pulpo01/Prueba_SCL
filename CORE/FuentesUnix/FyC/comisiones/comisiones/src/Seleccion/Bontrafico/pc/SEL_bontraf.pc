/************************************************************************/
/* Programa encargado de seleccionar los prepagos para comisiones ver. 2*/ 
/*----------------------------------------------------------------------*/
/* Version 1 - Revision 04.                                             */
/* Inicio: Viernes 31 de Agosto del 2001.                               */
/* Fin   : Martes 25 de Septiembre del 2001.                            */
/* Por Richard Troncoso C.                                              */
/************************************************************************/
/* Modificacion por PGonzaleg                                           */
/* Inicio: Lunes 2 de diciembre de 2002.                                */
/* Fin:    Lunes 2 de diciembre de 2002.                                */
/* Autor : Patricio Gonzalez Gomez                                      */
/* Modificacion de condiciones en los WHERE referentes a la tabla 		*/
/* CMD_PARAMETROS. Cambio en los campos COD_TIPCODIGO, COD_CODIGO y		*/
/* COD_PARAMETRO.														*/
/************************************************************************/
/************************************************************************/
/* Modificacion : Marcelo González Lizama                               */
/* Inicio       : Martes 14 de Octubre de 2003                          */
/* Fin			:                                               		*/
/* Descripcion  : 					       								*/
/* **********************************************************************/
/************************************************************************/
/* Modificacion : Fabian Aedo Ramirez                                   */
/* Inicio       : Jueves 06 de Novienmbre del 2003.                     */
/* Fin			:                                               		*/
/* Descripcion  : Cambios asociados al versionado de cuzco....          */
/*                - Normalizacion de Uso de Variables                   */
/*                - Planes de Comisiones                                */
/*                - Nuevo modelo de Bono Cartera                        */
/*                - Mejoras Varias.                                     */
/*                                                                      */
/* Modificacion : Manuel Garcia G.                                      */
/* Inicio       : Jueves 13 de Mayo del 2004.                           */
/* Fin			:                                               		*/
/* Descripcion  : Se aplica Homologacion HD-200405060712                */
/*                - Se optimiza acceso a tabla cmt_cartera              */
/*                  Se crea version CUZCO 4.0.1                         */
/* **********************************************************************/ 

#include "bontraf.h"
#include "GEN_biblioteca.h"

/*---------------------------------------------------------------------------*/
/* Inclusion de biblioteca para manejo de interaccion con Oracle.            */
/*---------------------------------------------------------------------------*/
EXEC SQL INCLUDE sqlca;
EXEC SQL WHENEVER SQLERROR DO vSqlError();
/*---------------------------------------------------------------------------*/
/* Definicion de variables globales para ser usadas con	Oracle.		         */
/*---------------------------------------------------------------------------*/
EXEC SQL BEGIN DECLARE SECTION;
	char	szhUser[30]="";
	char	szhPass[30]="";
	char	szhSysDate [17]="";
	char	szFechaYYYYMMDD[9]="";
EXEC SQL END DECLARE SECTION;
/*---------------------------------------------------------------------------*/
/* Lista de Tipos de Comisionistas para ejecución de ciclo  			     */
/*---------------------------------------------------------------------------*/
	stConceptosProc * lstConceptosProc = NULL;
/*---------------------------------------------------------------------------*/
/* Gestiona la carga de	Conceptos y Parámetros de Valoración		         */
/*---------------------------------------------------------------------------*/
int bCargaConceptos()
{
	switch (stCiclo.cTipCiclComis)
	{
		case PERIODICO:
		    vFechaHora();										    
		    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
		    fprintf(pfLog , "Carga lista de conceptos para ejecucion Periodica o Normal..\n\n");  
		    fprintf(stderr, "Carga lista de conceptos para ejecucion Periodica o Normal...\n\n");  
		    lstConceptosProc = stGetConceptosPer(FORMACOMIS,stCiclo);
		    return TRUE;
		case ESPORADICO:
		    vFechaHora();										    
		    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
		    fprintf(pfLog , "Carga lista de conceptos para ejecucion Esporadica	o Promocional..\n\n");	
		    fprintf(stderr, "Carga lista de conceptos para ejecucion Esporadica	o Promocional...\n\n");	 
		    lstConceptosProc = stGetConceptosProm(FORMACOMIS,stCiclo);
		    return TRUE;
		default:
		    vFechaHora();										    
		    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
		    fprintf(pfLog , "Error, Forma de Ejecucion:[%c] No reconocida..\n\n", stCiclo.cTipCiclComis);  
		    fprintf(stderr, "Error, Forma de Ejecucion:[%c] No reconocida..\n\n", stCiclo.cTipCiclComis);  
		    return FALSE;
	}
}
/*---------------------------------------------------------------------------*/
/* */
/*---------------------------------------------------------------------------*/
stUniverso * stBuscaCliente(stUniverso * paux, long lCodCliente, char * szTipComis, int iCodTipoRed)
{
	stUniverso * 	raux;
	int				bEncontrado;
	if (paux==NULL)
		return paux;
	raux = paux;
	bEncontrado = FALSE;
	while((raux != NULL)&&(!bEncontrado))
	{
		if ((lCodCliente == raux->lCodCliente)&&(strcmp(raux->szCodTipComis, szTipComis)==0)&&(raux->iCodTipoRed == iCodTipoRed))
			bEncontrado = TRUE;
		else
			raux = raux->sgte;
	}
	if (bEncontrado)
		return raux;
	else
		return NULL;
}
/*---------------------------------------------------------------------------*/
/* OBTIENE LOS CONCEPTOS DE FACTURACION ASOCIADOS AL TIPO DE RED.            */
/*---------------------------------------------------------------------------*/
stConcFact * stCargaConcFact(int iCodTipoRed, char * szCodPlanComis, int iCodConcComis)
{
	stConcFact * paux;
	stConcFact * qaux;
	int			i;
	short 		iLastRows 	 = 0;
	short 		iFetchedRows = MAXFETCH;
	short 		iRetrievRows = MAXFETCH;

	EXEC SQL BEGIN DECLARE SECTION;
		int		ihCodTipoRed;
		char	szhCodPlanComis[7];
		int		ihCodConcComis;
		int 	ihCodConcepto[MAXFETCH];
		char 	szhTipoConcepto[MAXFETCH][10];
		int		iMaxFetch;
	EXEC SQL END DECLARE SECTION;
	
	ihCodTipoRed			= iCodTipoRed;
	strcpy(szhCodPlanComis	, szCodPlanComis);
	ihCodConcComis 			= iCodConcComis;
	iMaxFetch 				= MAXFETCH;
	paux 					= NULL;
	qaux 					= NULL;
	
	EXEC SQL DECLARE CUR_CONCFACT CURSOR FOR SELECT  
		COD_CONCEPTOFACT,
		TIP_CONCEPTO
		FROM CM_CONCEPFACT_BONOCARTERA_TD
		WHERE 	COD_TIPORED 	= :ihCodTipoRed
		AND 	COD_PLANCOMIS 	= :szhCodPlanComis
		AND 	COD_CONCEPTO	= :ihCodConcComis;
	
	EXEC SQL OPEN CUR_CONCFACT;	

	while(iFetchedRows == iRetrievRows)
	{
		EXEC SQL FOR :iMaxFetch FETCH CUR_CONCFACT INTO 
			:ihCodConcepto, :szhTipoConcepto;
		
		iRetrievRows = sqlca.sqlerrd[2] - iLastRows;
		iLastRows = sqlca.sqlerrd[2];
				
		for (i=0; i < iRetrievRows; i++)
		{
			paux = (stConcFact *) malloc (sizeof(stConcFact));
			
			paux->iCodConcepto 			= ihCodConcepto[i];
			strcpy(paux->szTipoConcepto	, szfnTrim(szhTipoConcepto[i]));
			paux->sgte 					= qaux;
			qaux 						= paux;
		}
	}
	EXEC SQL CLOSE CUR_CONCFACT;
	return qaux;
}
/*---------------------------------------------------------------------------*/
/*   Carga universo de datos												 */
/*---------------------------------------------------------------------------*/
void vSeleccionarUniverso()
{
	stUniverso 		* paux;
	stUniverso 		* qaux;
	stAbonado  		* aaux;
	stConceptosProc 	* raux;
	
	int			i;
	short 		iLastRows 	= 0;
	short 		iFetchedRows 	= MAXFETCH;
	short 		iRetrievRows = MAXFETCH;

	EXEC SQL BEGIN DECLARE SECTION;
		int		iMaxFetch;
		int		ihCodTipoRed;
		long    lhCodComisionista[MAXFETCH];
		char	szhCodTipVendedor[MAXFETCH][3];
	    long    lhCodAgencia[MAXFETCH];
	    long    lhCodCliente[MAXFETCH];
	    long    lhNumAbonado[MAXFETCH];
		int		ihCanAbonados[MAXFETCH];
		char    szhCodPlanTarif[MAXFETCH][04];
    	char	szhFecVenta[MAXFETCH][15];
		char    szhCodTipComis[3];
	EXEC SQL END DECLARE SECTION;		
	qaux = NULL;
	for (raux=lstConceptosProc;raux != NULL; raux=raux->sgte)
	{
    	ihCodTipoRed			= raux->iCodTipoRed;
	   	strcpy(szhCodTipComis	, raux->szCodTipComis);
	   	iMaxFetch 				= MAXFETCH;
	
		fprintf(pfLog, "\n[vSeleccionarUniverso] Carga Cartera Para TipoRed:[%d] TipComis:[%s].\n",ihCodTipoRed, szhCodTipComis);
		fprintf(stderr,"\n[vSeleccionarUniverso] Carga Cartera Para TipoRed:[%d] TipComis:[%s].\n",ihCodTipoRed, szhCodTipComis);

/* MGG HOMOLOGACION HD-200405060712 
		EXEC SQL DECLARE CUR_CARTERA CURSOR FOR SELECT  
 			A.COD_COMISIONISTA,
 			A.COD_TIPVENDEDOR,
			A.COD_AGENCIA,
			A.COD_CLIENTE,
			A.NUM_ABONADO,
			A.COD_PLANTARIF,
			NVL(C.NUM_ABONADOS,1),
			TO_CHAR(A.FEC_VENTA, 'YYYYMMDDHH24MISS')
	 	FROM	CMT_CARTERA A, 
	 			TA_PLANTARIF C
	 	WHERE	A.IND_PROCESABLE 	= 'S' 
	 	AND		A.COD_TIPCOMIS		= :szhCodTipComis
	 	AND		A.COD_TIPORED		= :ihCodTipoRed
	 	AND   	A.NUM_ABONADO 		> 0
	 	AND   	C.COD_PRODUCTO 		= 1
	 	AND	 	C.COD_PLANTARIF 	= A.COD_PLANTARIF
	 	ORDER BY A.COD_CLIENTE DESC; 
*/
		EXEC SQL 
		DECLARE CUR_CARTERA CURSOR FOR 
		SELECT A.COD_COMISIONISTA,
			   A.COD_TIPVENDEDOR,
			   A.COD_AGENCIA,
			   A.COD_CLIENTE,
			   A.NUM_ABONADO,
			   A.COD_PLANTARIF,
			   NVL(C.NUM_ABONADOS,1),
			   TO_CHAR(A.FEC_VENTA, 'YYYYMMDDHH24MISS')
		  FROM CMT_CARTERA A, 
			   ( SELECT COD_PLANTARIF, 
					    NUM_ABONADOS
				   FROM TA_PLANTARIF
				  WHERE COD_PLANTARIF IN ( SELECT UNIQUE COD_PLANTARIF 
											 FROM CMT_CARTERA
											WHERE IND_PROCESABLE = 'S' 
										 )
					AND COD_PRODUCTO = 1 
			   ) C
		 WHERE A.IND_PROCESABLE = 'S' 
		   AND A.NUM_ABONADO > 0
		   AND A.COD_TIPCOMIS = :szhCodTipComis
		   AND A.COD_TIPORED = :ihCodTipoRed
		   AND C.COD_PLANTARIF = A.COD_PLANTARIF	
		ORDER BY A.COD_CLIENTE DESC; 
	
		EXEC SQL OPEN CUR_CARTERA;	

		while(iFetchedRows == iRetrievRows)
		{
			EXEC SQL FOR :iMaxFetch FETCH CUR_CARTERA INTO  
				:lhCodComisionista,
				:szhCodTipVendedor,
				:lhCodAgencia,
				:lhCodCliente,
				:lhNumAbonado,
				:szhCodPlanTarif,
				:ihCanAbonados,
				:szhFecVenta;
	
			iRetrievRows = sqlca.sqlerrd[2] - iLastRows;
			iLastRows = sqlca.sqlerrd[2];
					
			for (i=0; i < iRetrievRows; i++)
			{
				paux = stBuscaCliente(qaux, lhCodCliente[i], szhCodTipComis, ihCodTipoRed);
				if (paux == NULL)
				{
					paux = (stUniverso *) malloc (sizeof(stUniverso));
					
					paux->iCodTipoRed			= ihCodTipoRed;
				    strcpy(paux->szCodTipComis	, szhCodTipComis);
					paux->lCodComisonista 		= lhCodComisionista[i];
					paux->lCodCliente 			= lhCodCliente[i];
					paux->sgte_concfact			= stCargaConcFact(paux->iCodTipoRed, paux->szCodPlanComis, paux->iCodConcepto);
					paux->cIndConsidera 		= 'N'; 										   							
					strcpy(paux->szCodPlanComis	, raux->szCodPlanComis);
					paux->iCodConcepto			= raux->iCodConcepto; 
					paux->sgte_factura 			= NULL;
					paux->sgte_abonado 			= NULL;
					paux->sgte 					= qaux;
					qaux 						= paux;
				}

				aaux = (stAbonado *) malloc (sizeof(stAbonado));
				
				aaux->lCodAgencia 				= lhCodAgencia[i];
			    strcpy(aaux->szCodTipVendedor	, szfnTrim(szhCodTipVendedor[i]));
				aaux->lNumAbonado 				= lhNumAbonado[i];
				strcpy(aaux->szCodPlanTarif		, szfnTrim(szhCodPlanTarif[i]));
				aaux->iCantAbonadosPlan			= ihCanAbonados[i];	
				aaux->dFecVenta					= atof(szhFecVenta[i]); 
				aaux->cIndConsidera 			= 'N'; 

				aaux->sgte_idfactura			= NULL;
				aaux->sgte 						= paux->sgte_abonado;
				paux->sgte_abonado 				= aaux;
		  	}
		}	
		EXEC SQL CLOSE CUR_CARTERA;	
	}
	lstUniverso = qaux;
}
/*****************************************************************************/
/* CARGA TIPOS DE DOCUMENTOS VALIDOS PARA EL PROCESO.                        */
/*****************************************************************************/
void vCargaTipoDocumentos ()
{
    stDocumentos * paux;
    int     iFetchedRows 	= MAXFETCH;
    int     iRetrievRows 	= MAXFETCH;
    short   iLastRows    	= 0;   
	int		i;
	EXEC SQL BEGIN DECLARE SECTION;
        int    	iMaxFetch;
        int		ihCodTipDocum[MAXFETCH];
	    char    szhDesTipDocum[MAXFETCH][51];
    EXEC SQL END DECLARE SECTION;
    
	EXEC SQL DECLARE CUR_PARAMETROS CURSOR FOR SELECT 
			TO_NUMBER(VAL_PARAMETRO1), 
			DES_PARAMETRO1
	FROM 	CMD_PARAMETROS
	WHERE 	COD_TIPCODIGO 		= 10
			AND COD_CODIGO 		= 8
			AND COD_PARAMETRO 	> 0;

	EXEC SQL OPEN CUR_PARAMETROS;
	fprintf(pfLog ,"\n[vCargaTipoDocumentos] Inicia Carga de Tipos de Documentos a Considerar\n");
	fprintf(stderr,"\n[vCargaTipoDocumentos] Inicia Carga de Tipos de Documentos a Considerar\n");
	iMaxFetch = MAXFETCH;
	
	while(iFetchedRows == iRetrievRows)
    {
	EXEC SQL FOR :iMaxFetch FETCH CUR_PARAMETROS INTO
            :ihCodTipDocum,    
            :szhDesTipDocum;
	                        
		iRetrievRows = sqlca.sqlerrd[2] - iLastRows;
       	iLastRows = sqlca.sqlerrd[2];
		for (i=0; i < iRetrievRows; i++)
		{
			paux = (stDocumentos *) malloc (sizeof(stDocumentos));
	       	paux->iCodTipDocum 			= ihCodTipDocum[i];
	       	strcpy(paux->szDesTipDocum	, szfnTrim(szhDesTipDocum[i]));
			paux->sgte 					= lstDocumentos;
			lstDocumentos				= paux;
			
			fprintf(pfLog ,"[vCargaTipoDocumentos] TipDocum:[%d] [%s]\n", paux->iCodTipDocum, paux->szDesTipDocum);	       	
			fprintf(stderr,"[vCargaTipoDocumentos] TipDocum:[%d] [%s]\n", paux->iCodTipDocum, paux->szDesTipDocum);	       	
		}
   }   
	EXEC SQL CLOSE CUR_PARAMETROS;
	fprintf(pfLog ,"\n[vCargaTipoDocumentos] Fin Carga de Tipos de Documentos a Considerar\n");
	fprintf(stderr,"\n[vCargaTipoDocumentos] Fin Carga de Tipos de Documentos a Considerar\n");
}
/*****************************************************************************/
/* BUSCA UN TIPO DE DOCUMENTO EN LA LISTA DE TIPOS DE DOCUMENTOS VALIDOS.    */
/*****************************************************************************/
int bFindTipDocum(stDocumentos * paux, int iTipDocum)
{
	if (paux == NULL)
		return FALSE;
	if (paux->iCodTipDocum == iTipDocum)
		return TRUE;
	return bFindTipDocum(paux->sgte, iTipDocum);
}
/*****************************************************************************/
/* Almacenamiento de CO_CANCELADOS en memoria                                */
/*****************************************************************************/
void vCargaFacturas() 
{

	stCancelados * 	faux;
	int				i;
	int 			iLastRows 		= 0;
	int 			iFetchedRows 	= MAXFETCH;
	int 			iRetrievRows 	= MAXFETCH;
	long			lCantRegistros 	= 0;	

    EXEC SQL begin declare section;
		int		iMaxFetch;
        int   	ihCodTipDocum[MAXFETCH];
        int   	ihCodCentremi[MAXFETCH];
		long    lhNumSecuenci[MAXFETCH];
        long    lhCodCliente[MAXFETCH];
        long    lhCodVendedorAgente[MAXFETCH];
        char    szhLetra[MAXFETCH][2];
		char	szhFecDesde[11];
		char	szhFecHasta[11];
    EXEC SQL end declare section;

	strcpy(szhFecDesde, stCiclo.szFecDesdeNormal);
	strcpy(szhFecHasta, stCiclo.szFecHastaNormal);
	fprintf(pfLog ,"\n[vCargaFacturas] Inicia Carga de Documentos cancelados del periodo.\n");
	fprintf(stderr,"\n[vCargaFacturas] Inicia Carga de Documentos cancelados del periodo.\n");

	iMaxFetch = MAXFETCH;
	EXEC SQL DECLARE CUR_CANCELADOS CURSOR FOR SELECT  
		COD_CLIENTE, 
		COD_TIPDOCUM, 
		COD_CENTREMI,
		NUM_SECUENCI, 
		COD_VENDEDOR_AGENTE, 
		LETRA 
		FROM   CO_CANCELADOS S 
		WHERE  S.FEC_CANCELACION BETWEEN  TO_DATE(:szhFecDesde ,'DD-MM-YYYY') AND 
										  TO_DATE(:szhFecHasta,'DD-MM-YYYY') 
		 AND   S.ROWID = ( SELECT T.ROWID FROM CO_CANCELADOS T 
		                    WHERE  S.NUM_SECUENCI        = T.NUM_SECUENCI 
		                    AND    S.COD_TIPDOCUM        = T.COD_TIPDOCUM 
		                    AND    S.COD_VENDEDOR_AGENTE = T.COD_VENDEDOR_AGENTE 
		                    AND    S.LETRA               = T.LETRA 
		                    AND    S.COD_CENTREMI        = T.COD_CENTREMI 
		                    AND   ROWNUM                 = 1) 
		ORDER BY COD_CLIENTE DESC;

	EXEC SQL OPEN CUR_CANCELADOS;

    while (iFetchedRows == iRetrievRows)
    {
		EXEC SQL FOR :iMaxFetch FETCH CUR_CANCELADOS INTO
			:lhCodCliente,
			:ihCodTipDocum,
			:ihCodCentremi,
			:lhNumSecuenci,
			:lhCodVendedorAgente,
			:szhLetra;

        iRetrievRows = sqlca.sqlerrd[2] - iLastRows;
        iLastRows 	= sqlca.sqlerrd[2];

        for (i=0; i < iRetrievRows; i++)
 		{
			if (bFindTipDocum(lstDocumentos, ihCodTipDocum[i]))
			{
				faux = (stCancelados *) malloc(sizeof(stCancelados));
				faux->lCodCliente  			= lhCodCliente[i];
				faux->iCodTipDocum 			= ihCodTipDocum[i];
				faux->iCodCentremi 			= ihCodCentremi[i];
				faux->lNumSecuenci 			= lhNumSecuenci[i];
				faux->lCodVendedorAgente 	= lhCodVendedorAgente[i];
				strcpy(faux->cLetra 		, szhLetra[i]);
				faux->sgte 					= lstCancelados;
				lstCancelados 				= faux;
				lCantRegistros++;
			}
		}
	}
	EXEC SQL CLOSE CUR_CANCELADOS;
	fprintf(pfLog ,"\n[vCargaFacturas] Documentos Cancelados del Periodo[%ld].\n", lCantRegistros);
	fprintf(stderr,"\n[vCargaFacturas] Documentos Cancelados del Periodo[%ld].\n", lCantRegistros);
}

/*****************************************************************************/
/* Liberar memoria ocupada por las Facturas                                  */
/*****************************************************************************/
void vLiberaCancelados(stCancelados * paux)
{
	stCancelados * raux;
	
    if(paux!=NULL)
	{
		raux = paux->sgte;
		while (raux!=NULL)
		{
			free(paux);
			paux = raux;
			raux = paux->sgte;
		}
		if(paux!=NULL) free(paux);
    }
}
/*****************************************************************************/
/*****************************************************************************/
stUniverso * stBuscaClienteFactura(stUniverso * puni, long lCodCliente)
{
	int	bEncontrado = FALSE;
	if (puni == NULL)
		return NULL;

	bEncontrado = FALSE;
	while ((puni!=NULL)&&(!bEncontrado))
	{
		if (puni->lCodCliente < lCodCliente)
			puni = puni->sgte;
		else
			bEncontrado = TRUE;
	}
	if (bEncontrado)
		if (puni->lCodCliente == lCodCliente)
			return puni;

	return NULL;
}
/*****************************************************************************/
/* Asignacion de Facturas a la Estructura de Clientes                        */
/*****************************************************************************/
void vAsignaFacturas()
{
	stUniverso 		* puni;
	stCancelados	* pcan;
	stFactura		* faux;

	for (pcan = lstCancelados; pcan != NULL; pcan = pcan->sgte)
	{
		puni = stBuscaClienteFactura(lstUniverso, pcan->lCodCliente);
		while (puni!=NULL)
		{
            faux = (stFactura *) malloc(sizeof(stFactura));
            
            faux->iCodTipDocum 			= pcan->iCodTipDocum;
            faux->iCodCentremi 			= pcan->iCodCentremi;
            faux->lNumSecuenci 			= pcan->lNumSecuenci;
            faux->lCodVendedorAgente 	= pcan->lCodVendedorAgente;
            strcpy(faux->cLetra 		, pcan->cLetra);
            faux->cIndConsidera 		= 'S';
            puni->cIndConsidera 		= 'S';
            faux->sgte 					= puni->sgte_factura;
            puni->sgte_factura 			= faux;
            
			puni = stBuscaClienteFactura(puni->sgte, pcan->lCodCliente);
		}
	}
}
/*****************************************************************************/
/* Comparacion contra tabla CO_CARTERA                                       */ 
/*****************************************************************************/
void vValidaCancelados()
{
	stUniverso	* paux;
	stFactura	* faux;

    EXEC SQL begin declare section;
		short	ihCantCartera;
        short   ihCodTipDocum;
        short   ihCodCentremi;
        long    lhCodCliente;
        long    lhNumSecuenci;
        long    lhCodVendedorAgente;
        char    szhLetra[2];
    EXEC SQL end declare section;

	for (paux = lstUniverso; paux != NULL; paux = paux->sgte)
	{
		if (paux->cIndConsidera == 'S')
		{
			for (faux = paux->sgte_factura; faux != NULL; faux = faux->sgte)
			{
				lhCodCliente  = paux->lCodCliente;
				ihCodTipDocum = faux->iCodTipDocum;
				ihCodCentremi = faux->iCodCentremi;
				lhNumSecuenci = faux->lNumSecuenci;
				lhCodVendedorAgente = faux->lCodVendedorAgente;
				strcpy(szhLetra , faux->cLetra);
				ihCantCartera = 0;

				EXEC SQL SELECT COUNT(1)
					 INTO	:ihCantCartera
					 FROM	CO_CARTERA
					 WHERE	COD_CLIENTE  		= :lhCodCliente
					   AND	NUM_SECUENCI 		= :lhNumSecuenci
					   AND	COD_TIPDOCUM 		= :ihCodTipDocum
					   AND	COD_VENDEDOR_AGENTE = :lhCodVendedorAgente
					   AND	LETRA 				= :szhLetra
					   AND	COD_CENTREMI 		= :ihCodCentremi;

				if (ihCantCartera)
					faux->cIndConsidera = 'N';
			}
		}
	}
}
/*****************************************************************************/
/* Recupera los datos de la Factura desde FA_HISTDOCU.                       */ 
/*****************************************************************************/
void vRecuperaFactura()
{
	stUniverso	* paux;
	stFactura	* faux;

    EXEC SQL begin declare section;
        short   ihCodTipDocum;
        short   ihCodCentremi;
        long    lhNumSecuenci;
        long    lhCodVendedorAgente;
        char    szhLetra[2];
		long	lhCodCiclFact;
		long	lhlIndOrdenTotal;
		char	szhFecEmision[15];
    EXEC SQL end declare section;

	for (paux = lstUniverso; paux != NULL; paux = paux->sgte)
	{
		if (paux->cIndConsidera == 'S')
		{
			for (faux=paux->sgte_factura; faux != NULL; faux=faux->sgte)
			{
				if (faux->cIndConsidera == 'S')
				{
					ihCodTipDocum 			= faux->iCodTipDocum;
					ihCodCentremi 			= faux->iCodCentremi;
					lhNumSecuenci 			= faux->lNumSecuenci;
					lhCodVendedorAgente 	= faux->lCodVendedorAgente;
					strcpy(szhLetra 			, faux->cLetra);

					EXEC SQL SELECT	NVL(COD_CICLFACT,0),									
									IND_ORDENTOTAL,
									TO_CHAR(FEC_EMISION, 'YYYYMMDDHH24MISS')
					 		 INTO	:lhCodCiclFact,
									:lhlIndOrdenTotal,
									:szhFecEmision
					 		 FROM	FA_HISTDOCU
					 		 WHERE	NUM_SECUENCI 		= :lhNumSecuenci	
					 		   AND	COD_TIPDOCUM 		= :ihCodTipDocum
					   		   AND	COD_VENDEDOR_AGENTE	= :lhCodVendedorAgente
					   		   AND	LETRA 				= :szhLetra
					   		   AND	COD_CENTREMI 		= :ihCodCentremi;

					faux->lCodCiclFact 		= lhCodCiclFact;
					faux->lIndOrdenTotal 	= lhlIndOrdenTotal;
					faux->dFecEmision    	= atof(szhFecEmision);						
				}
			}
		}
	}
}

/*****************************************************************************/
/* Bajando a memoria FA_ENLACEHIST                                           */
/*****************************************************************************/
void vCargaEnlaceHist()
{
	stEnlaceHist * paux;
	int				i;
	int 			iLastRows = 0;
	int 			iFetchedRows = MAXFETCH;
	int 			iRetrievRows = MAXFETCH;
	
	EXEC SQL BEGIN DECLARE SECTION;
		long	lhCodCiclFact[MAXFETCH];
		char    szhFaHistConc[MAXFETCH][41];
		int		iMaxFetch;
	EXEC SQL END DECLARE SECTION;

	iMaxFetch = MAXFETCH; 

	EXEC SQL DECLARE CUR_ENLACE CURSOR FOR SELECT	
		COD_CICLFACT,
		FA_HISTCONC
	 FROM FA_ENLACEHIST
	 WHERE FA_HISTCONC IS NOT NULL;

	EXEC SQL OPEN CUR_ENLACE;

    while(iFetchedRows == iRetrievRows)
    {
        EXEC SQL FOR :iMaxFetch FETCH CUR_ENLACE INTO  
        	:lhCodCiclFact, :szhFaHistConc;

        iRetrievRows = sqlca.sqlerrd[2] - iLastRows;
        iLastRows = sqlca.sqlerrd[2];

        for (i=0; i < iRetrievRows; i++)
        {
			paux 					= (stEnlaceHist *) malloc (sizeof(stEnlaceHist));
			
			paux->lCodCiclFact 			= lhCodCiclFact[i];
			strcpy(paux->szFaHistConc	, szfnTrim(szhFaHistConc[i]));
			paux->sgte 					= lstEnlaceHist;
			lstEnlaceHist 				= paux;
		}
	}
	EXEC SQL CLOSE CUR_ENLACE;
}
/*****************************************************************************/
/*****************************************************************************/
stEnlaceHist * stBuscaEnlace(stEnlaceHist * paux, long lCodCiclFact)
{
	if (paux == NULL)
		return paux;
	
	if (paux->lCodCiclFact == lCodCiclFact)
		return paux;
	return 	stBuscaEnlace(paux->sgte, lCodCiclFact);
}
/*****************************************************************************/
/* Asigna Tabla Historica para cada Ciclo                                    */
/*****************************************************************************/
void vDeterminaCicloFactura()
{
	stUniverso 		* paux;
	stEnlaceHist	* penl;
	stFactura		* pfac;

	for (paux = lstUniverso; paux != NULL; paux = paux->sgte)
	{
		if (paux->cIndConsidera == 'S')
		{
			for (pfac = paux->sgte_factura; pfac != NULL; pfac = pfac->sgte)
			{
				if ( pfac->cIndConsidera == 'S' )
				{
					penl = stBuscaEnlace(lstEnlaceHist, pfac->lCodCiclFact);
					if (penl == NULL)
					{
						fprintf(pfLog ,"\t[vDeterminaCicloFactura] No se Encontro Detalle para CICLO:[%d]. Se Descarta.\n", pfac->lCodCiclFact);
						fprintf(stderr,"\t[vDeterminaCicloFactura] No se Encontro Detalle para CICLO:[%d]. Se Descarta.\n", pfac->lCodCiclFact);
						pfac->cIndConsidera = 'N';						
					}
					else
						strcpy(pfac->szFaHistConc, penl->szFaHistConc);
				}
			}
		}
	}
}
/*****************************************************************************/
/* Busca una factura en la lista de facturas por abonado.                    */
/*****************************************************************************/
stIdFactura * stBuscaIdFactura(stIdFactura * pide, long lIndOrden)
{
	if (pide == NULL)
		return NULL;
	
	if (pide->lIndOrdenTotal = lIndOrden)
		return pide;
		
	return stBuscaIdFactura(pide->sgte, lIndOrden);
}
/*****************************************************************************/
/* Busca un abonado en la lista de abonados del cliente.                     */
/*****************************************************************************/
stAbonado * stBuscaAbonado(stAbonado * pabo, long lNumAbonado)
{
	if (pabo == NULL)
	{
		return NULL;
	}
	if (pabo->lNumAbonado == lNumAbonado)
	{
		return pabo;
	}
	return stBuscaAbonado(pabo->sgte,lNumAbonado);
}

/*****************************************************************************/
/* BUSQUEDA DE CONCEPTOS													 */
/*****************************************************************************/
stConcFact * stBuscaConcepto(stConcFact * paux, int iCodConcepto)
{
	if (paux==NULL)
		return paux;
	if (paux->iCodConcepto == iCodConcepto)
		return paux;
	return stBuscaConcepto(paux->sgte, iCodConcepto);
}
/*****************************************************************************/
/* Distribuye y asigna el monto del concepto recuperado de la factura sobre  */
/* la lista de abonamdos del nodo principal.                                 */
/*****************************************************************************/
void vAsignaConceptos(stUniverso * paux, stFactura * pfac, int iCodConcepto, double dImpConcepto, long lNumAbonado)
{
	stAbonado   * pabo;
	stIdFactura * pide;
	stConcFact	* pConc;
	
	double	    dProrrateo;
	int			bExiste;
	
	if (lNumAbonado = 0)
	{
		for(pabo = paux->sgte_abonado; pabo != NULL; pabo = pabo->sgte)
		{
			if(pabo->dFecVenta <= pfac->dFecEmision)
			{
				dProrrateo = (dImpConcepto / pabo->iCantAbonadosPlan);
				pide = stBuscaIdFactura(pabo->sgte_idfactura, pfac->lIndOrdenTotal);
				if (pide == NULL)
				{
					pide = (stIdFactura *) malloc (sizeof(stIdFactura));
		       		pide->lIndOrdenTotal 	= pfac->lIndOrdenTotal;
		       		pide->lCodCiclFact   	= pfac->lCodCiclFact;
	           		pide->dImpTrafico 		= 0.00;
					pide->dImpCBasico  		= 0.00;
		       		pide->sgte 				= pabo->sgte_idfactura;
		       		pabo->sgte_idfactura 	= pide;
					pabo->cIndConsidera 	= 'S';
				}
	       		pConc = stBuscaConcepto(paux->sgte_concfact, iCodConcepto);
	       		if (pConc != NULL)
	       		{
	       		 	if (strcmp(pConc->szTipoConcepto , CONCEPTO_TRAFICO)==0)
	           			pide->dImpTrafico += dProrrateo;
	       			else 
	       		 		pide->dImpCBasico += dProrrateo;
				}
			}
		}
	}
	else
	{
		pabo = stBuscaAbonado(paux->sgte_abonado, lNumAbonado);
		if (pabo != NULL)
		{
			if(pabo->dFecVenta <= pfac->dFecEmision)
			{
				pide = stBuscaIdFactura(pabo->sgte_idfactura, pfac->lIndOrdenTotal);
				if (pide == NULL)
				{
					pide = (stIdFactura *) malloc (sizeof(stIdFactura));
		       		pide->lIndOrdenTotal 	= pfac->lIndOrdenTotal;
		       		pide->lCodCiclFact   	= pfac->lCodCiclFact;
	           		pide->dImpTrafico 		= 0.00;
					pide->dImpCBasico  		= 0.00;
		       		pide->sgte 				= pabo->sgte_idfactura;
		       		pabo->sgte_idfactura 	= pide;
					pabo->cIndConsidera 	= 'S';
				}
	       		pConc = stBuscaConcepto(paux->sgte_concfact, iCodConcepto);
	       		if (pConc != NULL)
	       		{
	       		 	if (strcmp(pConc->szTipoConcepto , CONCEPTO_TRAFICO)==0)
	           			pide->dImpTrafico += dProrrateo;
	       			else 
	       		 		pide->dImpCBasico += dProrrateo;
				}
			}
		}
	}
}
/*****************************************************************************/
/* Se asignan los bonos x cartera                                            */ 
/*****************************************************************************/
void vRecuperaMontosFactura()
{
	stUniverso	* paux;
	stAbonado 	* aaux;
	stFactura	* pfac;

	short		i;
	short 		iLastRows;
	short 		iFetchedRows;
	short 		iRetrievRows;

	EXEC SQL BEGIN DECLARE SECTION;
		int		iMaxFetch;
		char	szhSentencia[MAXARRAY];
		long	lhlIndOrdenTotal;
		long	lhNumAbonado[MAXFETCH];
		short	ihCodConcepto[MAXFETCH];
		double	dhImpConcepto[MAXFETCH];
	EXEC SQL END DECLARE SECTION;

	iMaxFetch = MAXFETCH;

	for (paux = lstUniverso; paux != NULL; paux = paux->sgte)
		if (paux->cIndConsidera == 'S')
		{
			for (pfac = paux->sgte_factura; pfac != NULL; pfac = pfac->sgte)
				if (pfac->cIndConsidera == 'S')
				{
					lhlIndOrdenTotal = pfac->lIndOrdenTotal;
					sprintf(szhSentencia, " SELECT "
					 	" NUM_ABONADO, COD_CONCEPTO, IMP_CONCEPTO "
						" FROM %s "
						" WHERE IND_ORDENTOTAL = :v1 ",pfac->szFaHistConc);
						
					EXEC SQL PREPARE S FROM :szhSentencia;
					EXEC SQL DECLARE CUR_CONCEPTOS CURSOR FOR S;
					
					EXEC SQL OPEN CUR_CONCEPTOS USING :lhlIndOrdenTotal;

					iLastRows = 0;
					iFetchedRows = MAXFETCH;
					iRetrievRows = MAXFETCH;
    				while(iFetchedRows == iRetrievRows)
    				{
	        			 EXEC SQL FOR :iMaxFetch FETCH 	CUR_CONCEPTOS INTO 	
	        			 	:lhNumAbonado, :ihCodConcepto, :dhImpConcepto;
	
						iRetrievRows = sqlca.sqlerrd[2] - iLastRows;
						iLastRows = sqlca.sqlerrd[2];
	
						for (i=0; i < iRetrievRows; i++)
						{
							vAsignaConceptos(paux, pfac, ihCodConcepto[i],dhImpConcepto[i],lhNumAbonado[i]);
						}
					}
					EXEC SQL CLOSE CUR_CONCEPTOS;
				}
		} 
}
/*****************************************************************************/
/* Liberar Memoria para Enlaces Historicos                                   */
/*****************************************************************************/

void liberar_enlaceshist(stEnlaceHist * paux)
{
    stEnlaceHist *  raux;	
	   
    if(paux!=NULL)
	{
		raux = paux->sgte;
		while (raux!=NULL)
		{
			free(paux);
			paux = raux;
			raux = paux->sgte;
		}
		if(paux!=NULL) free(paux);
    }  
    return;
}
/*****************************************************************************/
/* Liberar Memoria para Abonados (Montos)                                    */
/*****************************************************************************/
void liberar_idfactura(stIdFactura * paux)
{
    stIdFactura	*  raux;	
	   
    if(paux!=NULL)
	{
		raux = paux->sgte;
		while (raux!=NULL)
		{
			free(paux);
			paux = raux;
			raux = paux->sgte;
		}
		if(paux!=NULL) free(paux);
    }      
}
/*****************************************************************************/
/* Liberar Memoria para Abonados                                             */
/*****************************************************************************/
void liberar_abonado(stAbonado * paux)
{
    stAbonado	*  raux;	
	   
    if(paux!=NULL)
	{
		raux = paux->sgte;
		while (raux!=NULL)
		{
			free(paux);
			paux = raux;
			raux = paux->sgte;
		}
		if(paux!=NULL) free(paux);
    }     
}
/*****************************************************************************/
/* Liberar Memoria para Facturas                                             */
/*****************************************************************************/

void liberar_factura(stFactura * paux)
{
    stFactura	*  raux;	
	   
    if(paux!=NULL)
	{
		raux = paux->sgte;
		while (raux!=NULL)
		{
			free(paux);
			paux = raux;
			raux = paux->sgte;
		}
		if(paux!=NULL) free(paux);
    }
}

/*****************************************************************************/
/* Libera Memoria Usada Por Universo                                         */
/*****************************************************************************/

void liberar_memoria(stUniverso * paux)
{
	stUniverso * raux;
	long	 	lCantMemoria = 0;
    if(paux!=NULL)
	{
		raux = paux->sgte;
		while (raux!=NULL)
		{
			free(paux);
			lCantMemoria++;
			paux = raux;
			raux = paux->sgte;
		}
		if(paux!=NULL) free(paux);
    }
    fprintf(stderr,"\nLibera_Memoria: Registros eliminados:[%ld]\n",lCantMemoria);
}

/*****************************************************************************/
/* Insercion de valores en salida                                            */
/*****************************************************************************/

void inserta_valores()
{
	stUniverso	* paux;
	stAbonado	* aaux;
	stIdFactura * pfac;
	long		lCantRegistros = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		char	szhIdCiclComis[11];
		long	lhCodCiclComis;
		int		ihCodTipoRed;
		char	szhCodPlanComis[7];
		int		ihCodConcepto;
		char    szhCodTipComis[3];
		long	lhCodComisionista;
		long	lhCodCliente;
		long	lhNumAbonado;
		long	lhCodAgencia;
		char    szhCodPlanTarif[4];
		char	szhCodTipVendedor[3];
		long	lhIndOrdenTotal;
		long	lhCodCiclFact;
		double	dhImpTrafico;
		double	dhImpCBasico;
		long	lhNumSecuencia;
	EXEC SQL END DECLARE SECTION;

	lhCodCiclComis 			= stCiclo.lCodCiclComis;	
	strcpy(szhIdCiclComis	, stCiclo.szIdCiclComis);

	for (paux = lstUniverso; paux != NULL; paux = paux->sgte)
		if (paux->cIndConsidera == 'S')
		{
			ihCodTipoRed			= paux->iCodTipoRed;
			strcpy(szhCodPlanComis 	, paux->szCodPlanComis);
			ihCodConcepto			= paux->iCodConcepto;
			strcpy(szhCodTipComis	, paux->szCodTipComis);
			lhCodComisionista 		= paux->lCodComisonista;
			lhCodCliente 			= paux->lCodCliente;
	    	for (aaux = paux->sgte_abonado; aaux != NULL; aaux = aaux->sgte)
	       	{
				if (aaux->cIndConsidera == 'S')
			 	{
					lhNumAbonado	 		= 	aaux->lNumAbonado;
					lhCodAgencia	 		= 	aaux->lCodAgencia;
					strcpy(szhCodPlanTarif	, 	aaux->szCodPlanTarif);
					strcpy(szhCodTipVendedor,	aaux->szCodTipVendedor);
	
					for (pfac=aaux->sgte_idfactura; pfac != NULL; pfac = pfac->sgte)
					{
						lhIndOrdenTotal 	= 	pfac->lIndOrdenTotal;
						lhCodCiclFact	 	= 	pfac->lCodCiclFact;
						dhImpTrafico 		= 	pfac->dImpTrafico;
						dhImpCBasico  		= 	pfac->dImpCBasico; 
		
						EXEC SQL SELECT CMS_REG_SELECCION.nextval INTO :lhNumSecuencia FROM   DUAL;
		
						lCantRegistros++;

						EXEC SQL INSERT INTO CMT_BONOSCARTERA(
							NUM_GENERAL, COD_TIPCOMIS, COD_COMISIONISTA, COD_AGENCIA, 
							COD_CLIENTE, NUM_ABONADO, COD_PLANTARIF, IND_ORDENTOTAL, 
							IMP_TRAFICO, IMP_CARGOBASICO, COD_CICLFACT, COD_PERIODO, 
							ID_PERIODO, COD_TIPORED, COD_TIPVENDEDOR, COD_PLANCOMIS, 
							COD_CONCEPTO) VALUES(
							:lhNumSecuencia, :szhCodTipComis, :lhCodComisionista, :lhCodAgencia, 
							:lhCodCliente, :lhNumAbonado, :szhCodPlanTarif, :lhIndOrdenTotal,
							:dhImpTrafico, :dhImpCBasico, :lhCodCiclFact, :lhCodCiclComis,
							:szhIdCiclComis, :ihCodTipoRed, :szhCodTipVendedor, :szhCodPlanComis,
							:ihCodConcepto);
					}
		     	}
	       	}
		}
	stStatusProc.lCantRegistros = lCantRegistros;
}
/*****************************************************************************/
/* Rutina principal.                                                         */
/*****************************************************************************/
int main (int argc, char *argv[])
{
/*---------------------------------------------------------------------------*/
/* Variables Globales.                                                       */
/*---------------------------------------------------------------------------*/
	long lSegIni, lSegFin;
	short ibiblio;
/*---------------------------------------------------------------------------*/
/* Recuperacion del tiempo de inicio del proceso, en segundos.               */
/*---------------------------------------------------------------------------*/
	lSegIni =lGetTimer();

	memset(&stArgs, 0, sizeof(rg_argumentos));
	memset(&proceso, 0, sizeof(proceso));
	memset(&stStatusProc, 0, sizeof(rg_estadistica));
/*---------------------------------------------------------------------------*/
/* Manejo de argumentos ingresados como parametros externos.                 */
/*---------------------------------------------------------------------------*/	
	vManejaArgs(argc, argv);

/*---------------------------------------------------------------------------*/
/* Conexion a la base de datos Oracle.                                       */
/*---------------------------------------------------------------------------*/
	fprintf(stderr, "\nstArgs.szUser        [%s]\n", stArgs.szUser);
	fprintf(stderr, "\nstArgs.szPass        [%s]\n", stArgs.szPass);
	
	strcpy(szhUser, stArgs.szUser);                                                      
	strcpy(szhPass, stArgs.szPass);                                                    
	if(fnOraConnect(szhUser, szhPass) == FALSE)                                          
	{                                                                                  
	        fprintf(stderr, "\nUsuario/Password Oracle no son validos. Se cancela.\n");
	        exit(EXIT_205);                                                            
	}                                                                                  
	else                                                                               
	{                                                                                  
	        fprintf(stderr, "\nConexion con la base de datos ha sido exitosa.\n");     
	        fprintf(stderr, "Username: %s\n\n", szhUser);                              
	}
/*---------------------------------------------------------------------------*/
/* Inicialización estructura de Bloque(proceso).                             */
/*---------------------------------------------------------------------------*/
        vInicia_Estructura_Procesos(stArgs.szBloque, stArgs.szProceso,szhUser, stArgs.izSecuencia);
        ibiblio = iAccesa_Traza_Procesos(ABRIR_TRAZA,0,"",0,0);                                    
        if (ibiblio)                                                                               
        {                                                                                          
                fprintf(stderr, "Error al Abrir Traza");                                           
                fprintf(stderr, "Error [%d] al escribir Traza de Proceso.\n", ibiblio);            
                exit(ibiblio);                                                                     
        }                                                                                          
/*---------------------------------------------------------------------------*/
/* Preparacion de ambiente para archivos de log y datos.                     */
/*---------------------------------------------------------------------------*/
	fprintf(stderr, "Preparando ambiente para archivos de log, de datos y de configuracion ...\n");                    
	if((pszEnvLog = (char *)pszEnviron("XPCM_LOG", "")) == (char *)NULL)                                               
	{                                                                                                                  
	        exit(iAccesa_Traza_Procesos(CERRAR_TRAZA_NOK,EXIT_401,"VARIABLE DE AMBIENTE XPCM_LOG NO RECONOCIDA.",0,0));
	}                                                                                                                  
	fprintf(stderr, "Directorio de Logs         : [%s]\n", (char *)pszEnvLog);                                         
/*---------------------------------------------------------------------------*/
/* GENERACION DEL NOMBRE Y CREACION DEL ARCHIVO DE LOG.                      */
/*---------------------------------------------------------------------------*/
	strncpy(szFechaYYYYMMDD,szfnObtieneFecYYYYMMDD(),8);
        strncpy(szhSysDate, pszGetDateLog(),16);                                                           
	strcpy(stArgsLog.szProceso,LOGNAME);                                                                     
	strncpy(stArgsLog.szSysDate,szhSysDate,16);                                                                  
	sprintf(stArgsLog.szPath,"%s%s/%s",pszEnvLog,stArgsLog.szProceso,szFechaYYYYMMDD);                       
	                                                                                                         
	if((pfLog = fAbreArchivoLog()) == (FILE *)NULL)                                                          
	{
	    fprintf(stderr, "\nArchivo [%s/%s_%s.log] No pudo ser abierto." ,stArgsLog.szPath,stArgsLog.szProceso,stArgsLog.szSysDate);                                  
	    fprintf(stderr, "Revise su existencia.\n");                                                          
	    fprintf(stderr, "Error Numero: %d     %s\n", errno, strerror(errno));                                
	    fprintf(stderr, "Proceso finalizado con error.\n");                                                  
	}
/*---------------------------------------------------------------------------*/
/* Header.                                                                   */
/*---------------------------------------------------------------------------*/    
    
    vFechaHora();                                                               
    fprintf(stderr, "Procesando ...\n");                                        
    fprintf(pfLog, "%s\n", szRaya);                    
    fprintf(pfLog, "\n\n%s\n", (char *)pszFechaHora());
    fprintf(pfLog, "%s\n", GLOSA_PROG);                
    fprintf(pfLog, "VERSION %s\n", PROG_VERSION);      
    fprintf(pfLog, "Ultima Revision: [%s]\n", LAST_REVIEW);   
	fprintf(pfLog, "Base de datos : %s\n\n", (strcmp(getenv((const char *)"TWO_TASK"), "")!=0?getenv((const char *)"TWO_TASK"):getenv((const char *)"ORACLE_SID")));
    fprintf(pfLog,"\nUsuario ORACLE      :[ %s ]\n",(char * )sysGetUserName() ); 
             
    fprintf(pfLog, "%s\n\n", szRaya);                  

    fprintf(pfLog, "\n Argumentos de Ejecucion\n");
	fprintf(pfLog,"Periodo                : %s\n", stArgs.szIdPeriodo);
    fprintf(pfLog,"Codigo de Bloque       : %s\n", stArgs.szBloque);
    fprintf(pfLog,"Codigo de Proceso      : %s\n", stArgs.szProceso);
    fprintf(pfLog,"Secuencia de Bloque    : %d\n", stArgs.izSecuencia);


/*---------------------------------------------------------------------------*/
/* Modificacion de configuracion ambiental, para manejo de fechas en Oracle. */
/*---------------------------------------------------------------------------*/
        EXEC SQL ALTER SESSION SET NLS_DATE_FORMAT='dd-mm-yyyy';
/*---------------------------------------------------------------------------*/
/*  PROGRAMA PRINCIPAL                                                       */
/*---------------------------------------------------------------------------*/        

/*---------------------------------------------------------------------------*/
/* CARGA ESTRUCTURA CICLOS DE PROCESO                                        */
/*---------------------------------------------------------------------------*/
    fprintf(pfLog,  "\n\n%s\n", (char *)pszFechaHora());
    fprintf(pfLog,  "Carga estructura de ciclo de proceso...(vCargaCiclo)\n\n");       
    fprintf(stderr, "Carga estructura de ciclo de proceso...(vCargaCiclo)\n\n");       
    if (!vCargaCiclo(stArgs.szIdPeriodo,&stCiclo))    
    {
    	fprintf(pfLog, "\n\n[Main] Ciclo que pretende Ejecutar no bExiste.(vCargaCiclo)\n");
    	fprintf(pfLog, "[Main] Se cancela la ejecucion.(vCargaCiclo)\n");
    	fprintf(pfLog, "\n\n[Main] Ciclo que pretende Ejecutar no bExiste.(vCargaCiclo)\n");
    	fprintf(pfLog, "[Main] Se cancela la ejecucion.(vCargaCiclo)\n");
    	exit(EXIT_101);
    }
/*--------------------------------------------------------------------------*/
/* Carga Estructura de Conceptos y Tipos de Red	a Procesar...(Estándar)	    */
/*--------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
    fprintf(pfLog , "Gestiona Carga de Datos y Parametros..\n\n");  
    fprintf(stderr, "Gestiona Carga de Datos y Parametros...\n\n");  
	if (!bCargaConceptos())
	{
		fprintf(stderr,	"\nError Recuperando Lista de Conceptos	de comisiones.\n");
		fprintf(stderr,	"Revise	la parametrizacion.\n");
		fprintf(stderr,	"Proceso finalizado con	error.\n");
		exit(iAccesa_Traza_Procesos(CERRAR_TRAZA_NOK,EXIT_301,"NO PUEDE	CARGAR LISTA DE	CONCEPTOS DE COMISION.",0,0));
	}
/*---------------------------------------------------------------------------*/
/* CARGA UNIVERSO DE DATOS                                                   */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
    fprintf(pfLog,  "Carga Universo de datos a procesar...\n\n");       
    fprintf(stderr, "Carga Universo de datos a procesar...\n\n");       
	vSeleccionarUniverso();
   
/*--------------------------------------------------------------------------*/
/* Almacenando tabla CO_CANCELADOS                                          */
/*--------------------------------------------------------------------------*/    
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
    fprintf(pfLog,  "Carga Tipos de Documentos a procesar...\n\n");       
    fprintf(stderr, "Carga Tipos de Documentos a procesar...\n\n");       
  	vCargaTipoDocumentos();

    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Almacena tabla CO_CANCELADOS...\n\n");  
    fprintf(stderr, "Almacena tabla CO_CANCELADOS...\n\n");  
	vCargaFacturas();
/*--------------------------------------------------------------------------*/
/* Asigna Facturas a Clientes                                               */
/*--------------------------------------------------------------------------*/    
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Asignando Facturas a Clientes...(asignar_facturas)\n\n");  
    fprintf(stderr, "Asignando Facturas a Clientes...(asignar_facturas)\n\n");
    vAsignaFacturas();

/*---------------------------------------------------------------------------*/
/* LIBERA MEMORIA UTILIZADA POR LISTA CCANCELADO                             */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Libera memoria utilizada por lista de Clientes Cancelados.....(liberar_co_cancelados)\n\n");  
    fprintf(stderr, "Libera memoria utilizada por lista de Clientes Cancelados.....(liberar_co_cancelados)\n\n");    
    vLiberaCancelados(lstCancelados);
/*---------------------------------------------------------------------------*/
/* Verifican No existencia en CO_CARTERA                                     */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Verificando No existencia en CO_CARTERA........\n\n");  
    fprintf(stderr, "Verificando No existencia en CO_CARTERA........\n\n");    
    vValidaCancelados();
/*---------------------------------------------------------------------------*/
/* Compara con tabla FA_HISTDOCU                                             */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Comparando con tabla FA_HISTDOCU...()\n\n");  
    fprintf(stderr, "Comparando con tabla FA_HISTDOCU...()\n\n");    
	vRecuperaFactura();
	
/*---------------------------------------------------------------------------*/
/* Almacena en Memoria FA_ENLACEHIST                                         */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Almacenando en Memoria FA_ENLACEHIST...()\n\n");  
    fprintf(stderr, "Almacenando en Memoria FA_ENLACEHIST...()\n\n");    
    vCargaEnlaceHist();

/*---------------------------------------------------------------------------*/
/* Asigna tabla de enlace para Ciclos                                        */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Asignando tabla de enlace para Ciclos...()\n\n");  
    fprintf(stderr, "Asignando tabla de enlace para Ciclos...()\n\n"); 
    vDeterminaCicloFactura();
    
/*---------------------------------------------------------------------------*/
/* Asignando Bonos por Cartera                                               */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Asignando Bonos por Cartera...()\n\n");  
    fprintf(stderr, "Asignando Bonos por Cartera...()\n\n");     
	vRecuperaMontosFactura();

/*---------------------------------------------------------------------------*/
/* Inserta Valores en Salida                                                 */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
  	fprintf(pfLog, "Insertando Valores en Salida(s)...(inserta_valores)\n\n");  
    fprintf(stderr, "Insertando Valores en Salida(s)...(inserta_valores)\n\n");        
	inserta_valores();

/*---------------------------------------------------------------------------*/
/* LIBERA MEMORIA UTILIZADA POR LISTA DE UNIVERSO                            */
/*---------------------------------------------------------------------------*/   
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
	fprintf(pfLog, "Liberando Memoria usada por lista Universo...(liberar_memoria)\n\n");  
    fprintf(stderr, "Liberando Memoria usada por lista Universo...(liberar_memoria)\n\n");    
    liberar_memoria(lstUniverso); 
    
/*---------------------------------------------------------------------------*/
/* LIBERA MEMORIA UTILIZADA POR LISTA DE UNIVERSO                            */
/*---------------------------------------------------------------------------*/   
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
	fprintf(pfLog, "Liberando Memoria usada por lista de enlaces historicos...(liberar_enlaceshist)\n\n");  
    fprintf(stderr, "Liberando Memoria usada por lista de enlaces historicos...(liberar_enlaceshist)\n\n");    
	liberar_enlaceshist(lstEnlaceHist); 

/*---------------------------------------------------------------------------*/
/* LIBERA MEMORIA UTILIZADA POR LISTA DE ABONADOS                            */
/*---------------------------------------------------------------------------*/   
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
	fprintf(pfLog, "Liberando Memoria usada por lista de Abonados...(liberar_abonado)\n\n");  
    fprintf(stderr, "Liberando Memoria usada por lista de Abonados...(liberar_abonado)\n\n");    
	liberar_abonado(lstAbonado);

/*------------------------------------------------------------------*/
/* RECUPERACION DE LOS SEGUNDOS REALES OCUPADOS POR EL PROCESO.    */
/*-----------------------------------------------------------------*/
   	lSegFin=lGetTimer();
   	stStatusProc.lSegProceso = lSegFin - lSegIni;

   	if (iAccesa_Traza_Procesos(CERRAR_TRAZA_OK,0,"", stStatusProc.lSegProceso, stStatusProc.lCantRegistros))
      exit(iAccesa_Traza_Procesos(CERRAR_TRAZA_NOK,EXIT_400,"NO SE PUDO CERRAR TRAZA OK.",0,0));

	EXEC SQL COMMIT WORK;
/*-----------------------------------------------------------------------*/
/* Despliegue de la informacion estadistica del proceso.                 */
/*-----------------------------------------------------------------------*/   
  
   	fprintf(pfLog, "Estadistica del proceso\n");
   	fprintf(pfLog, "------------------------\n");
   	fprintf(pfLog, "Registros Finales Procesados   : [%d]\n", stStatusProc.lCantRegistros);
   	fprintf(pfLog, "Segundos Reales Utilizados     : [%d]\n\n", stStatusProc.lSegProceso);

   	fprintf(stderr, "Estadistica del proceso\n");
   	fprintf(stderr, "------------------------\n");
   	fprintf(stderr, "Registros Finales Procesados   : [%d]\n", stStatusProc.lCantRegistros);
   	fprintf(stderr, "Segundos Reales Utilizados     : [%d]\n\n", stStatusProc.lSegProceso);

	fprintf(pfLog ,"\n\n\nProceso [%s] finalizado ok.\n", basename(argv[0]));
	fprintf(stderr,"\n\n\nProceso [%s] finalizado ok.\n", basename(argv[0]));
	fclose(pfLog);
	return(EXIT_0);
}


/******************************************************************************************/
/** Información de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisión                                            : */
/**  %PR% */
/** Autor de la Revisión                                : */
/**  %AUTHOR% */
/** Estado de la Revisión ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creación de la Revisión                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/

