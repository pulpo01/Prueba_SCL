/*---------------------------------------------------------------------------*/
/* Programa encargado de ejecutar la valoración	del Bono Cartera	         */
/*									                                         */
/*---------------------------------------------------------------------------*/
/* Version 1 - Revision	00.						                             */
/* Inicio: Lunes 26 de Noviembre del 2001.				                     */
/* Fin:									                                     */
/* Autor : Fabian Aedo Ramirez						                         */
/*---------------------------------------------------------------------------*/
/* Recibira entre sus parametros un COD_PERIODO, con el	que cruzara las	     */
/*  tablas de Valoracion (CMT_VALORIZADOS) y la	de periodos, (CMD_PERIODOS), */
/*  para todos aquellos	periodos cuyo indicador	de periodo sea mensual.	     */
/*---------------------------------------------------------------------------*/
/* Inclusion de	librería para definiciones generales del programa.	         */
/*---------------------------------------------------------------------------*/
/* Modificado Marcelo Quiroz Garcia                                          */
/* Se incorporan tratamientos de:                                            */
/* - Ciclos Esporádicos                                                      */
/* - Planes de Comisiones                                                    */
/* - Red de Ventas                                                           */
/* Versionado CUZCO - Oct-2003.                                              */
/* ***************************************************************************/
#include "Val_Bajas.h"
#include "GEN_biblioteca.h"
#include <geora.h>
/*---------------------------------------------------------------------------*/
/* Declaracion e inicializacion	de lista de conceptos a	procesar.	         */
/*---------------------------------------------------------------------------*/
stConceptosProc	* lstConceptosProc = NULL;
/*---------------------------------------------------------------------------*/
/* Inclusion de	biblioteca para	manejo de interaccion con Oracle.	         */
/*---------------------------------------------------------------------------*/
EXEC SQL INCLUDE sqlca;
EXEC SQL WHENEVER SQLERROR DO vSqlError();
/*---------------------------------------------------------------------------*/
/* Definicion de variables globales para ser usadas con	Oracle.		         */
/*---------------------------------------------------------------------------*/
EXEC SQL BEGIN DECLARE SECTION;
	char	szhUser[30]="";
	char	szhPass[30]="";
	char	szhSysDate [17]="";
	char	szFechaYYYYMMDD[9]="";
EXEC SQL END DECLARE SECTION;

/*---------------------------------------------------------------------------*/
void vLiberaDatosTiempo(stTiempos * taux)
{
	if (taux == NULL)
		return;
	vLiberaDatosTiempo(taux->sgte);	
	free(taux);
}
/*---------------------------------------------------------------------------*/
void vLiberaDatosPlan(stPlan * raux)
{
	if (raux == NULL)
		return;
	vLiberaDatosPlan(raux->sgte);
	vLiberaDatosTiempo(raux->sgte_tiempo);
	free(raux);
}
/*---------------------------------------------------------------------------*/
void vLiberaDatosParam(stParam * qaux)
{
	if (qaux == NULL)
		return;
	vLiberaDatosParam(qaux->sgte);
	free(qaux);
}
/*---------------------------------------------------------------------------*/
void vLiberaDatosEvento(stEvento * qaux)
{
	if (qaux == NULL)
		return;
	vLiberaDatosEvento(qaux->sgte);
	free(qaux);
}
/*---------------------------------------------------------------------------*/
void vLiberaPrincipal(stPrincipal * paux)
{
	if (paux == NULL)
		return;
	vLiberaPrincipal(paux->sgte);	
	vLiberaDatosPlan(paux->sgte_plan);
	vLiberaDatosParam(paux->sgte_causa);
	vLiberaDatosParam(paux->sgte_usuar);
	vLiberaDatosEvento(paux->sgte_evento);
	free(paux);
}
/*---------------------------------------------------------------------------*/
/* CREA	LISTA PRINCIPAL	DE EVALUALCION A PARTIR	DE LA TABLA CM_PENALIZA_TD   */
/*---------------------------------------------------------------------------*/
stPrincipal * stfnCreaPrincipal()
{
    stConceptosProc * raux;
    stPrincipal	    *paux;
    stPrincipal	    *qaux;
    
    long	lCantRegistros = 0;
    int				         i;
    short	iLastRows      = 0;
    int		iFetchedRows   = MAXFETCH;
    int		iRetrievRows   = MAXFETCH;
	
    EXEC SQL BEGIN DECLARE SECTION;
	char	szhCodPlanComis[6] ;
	int	    ihCodTipoRed	   ;
	int	    ihCodConcepto	   ;
	char	szhCodTipComis [3] ;
	char	szhCodUniverso [7] ;		    

	long	lMaxFetch;

	char	szhIndTrafico	    [MAXFETCH][2];
	char	szhIndProcequi	    [MAXFETCH][2];
	char	szhCodTipCalculo    [MAXFETCH][2];
	int	    ihNomFechaDesde	    [MAXFETCH];
	int	    ihNumListaCausa	    [MAXFETCH];
	int	    ihNumListaUsuaExcep [MAXFETCH];
	
	char	szhFecInicio[11];
	char	szhFecTermino[11];
	
    EXEC SQL END DECLARE SECTION;

    paux = NULL;
    qaux = NULL;	 
	
    lMaxFetch =	MAXFETCH;
    
    strcpy(szhFecInicio  , stCiclo.szFecDesdeNormal);
	strcpy(szhFecTermino , stCiclo.szFecHastaNormal);
    
    for (raux = lstConceptosProc; raux != NULL; raux = raux->sgte)
    {
		iLastRows      		   = 0;       
		iFetchedRows   		   = MAXFETCH;
		iRetrievRows   		   = MAXFETCH;
		ihCodTipoRed	       = raux->iCodTipoRed;
		ihCodConcepto	       = raux->iCodConcepto;
		strcpy(szhCodPlanComis , raux->szCodPlanComis);
		lMaxFetch =	MAXFETCH;

		strcpy(szhCodTipComis  , raux->szCodTipComis);
		strcpy(szhCodUniverso  , raux->szCodUniverso);
	
		EXEC SQL DECLARE CUR_UNIVERSO CURSOR FOR
			SELECT	IND_TRAFICO	  	  ,
				    IND_PROCEQUI	  ,
					COD_TIPCALCULO	  ,
					NOM_FECHADESDE	  ,
					NUM_LISTACAUSA	  ,
					NUM_LISTAUSUAEXCEP			
			FROM	CM_PENALIZA_TD
			WHERE	COD_TIPORED   =	:ihCodTipoRed
			AND	    COD_PLANCOMIS =	:szhCodPlanComis
			AND	    COD_CONCEPTO  =	:ihCodConcepto;
	
		EXEC SQL OPEN CUR_UNIVERSO;
		
		while(iFetchedRows == iRetrievRows)
		{
		     EXEC SQL for :lMaxFetch
				 FETCH CUR_UNIVERSO INTO 
					:szhIndTrafico,
					:szhIndProcequi,
					:szhCodTipCalculo,
					:ihNomFechaDesde,
					:ihNumListaCausa,
					:ihNumListaUsuaExcep;			       
		
		     iRetrievRows = sqlca.sqlerrd[2] - iLastRows;
		     iLastRows	  = sqlca.sqlerrd[2];
					
		     for (i=0; i < iRetrievRows; i++)
		     {
			  paux = (stPrincipal *) malloc(sizeof(stPrincipal));
	 
			  paux->iCodTipoRed	       	   = ihCodTipoRed;
			  paux->iCodConcepto	       = ihCodConcepto;
			  paux->iNomFechaDesde	       = ihNomFechaDesde[i];
			  paux->iNumListaCausa	       = ihNumListaCausa[i];
			  paux->iNumListaUsuaExcep     = ihNumListaUsuaExcep[i];
	
			  strcpy(paux->szCodPlanComis  , szhCodPlanComis);
			  strcpy(paux->szCodTipComis   , szfnTrim(szhCodTipComis)); 
			  strcpy(paux->szCodUniverso   , szfnTrim(szhCodUniverso));			   
			  strcpy(paux->szIndTrafico    , szfnTrim(szhIndTrafico[i]));
			  strcpy(paux->szIndProcequi   , szfnTrim(szhIndProcequi[i]));			      
			  strcpy(paux->szCodTipCalculo , szfnTrim(szhCodTipCalculo[i]));			
			  
			  strcpy(paux->szFecDesde		, raux->szFecDesde);
			  strcpy(paux->szFecHasta		, raux->szFecHasta);

			  paux->sgte_plan  = NULL;  
			  paux->sgte_causa = NULL; 
			  paux->sgte_usuar = NULL; 
			  paux->sgte_evento= NULL;
			  lCantRegistros++;
				
			  paux->sgte	   = qaux;
			  qaux		   = paux;
		     } 
		}
		EXEC SQL CLOSE CUR_UNIVERSO;
    }
    fprintf(pfLog,  "(stfnCreaPrincipal)Registros Leidos:[%ld].\n\n", lCantRegistros);
    return (qaux);
}
/*---------------------------------------------------------------------------*/
/* Gestiona la carga de	Conceptos y Parámetros de Valoración		         */
/*---------------------------------------------------------------------------*/
int bCargaConceptos()
{
	switch (stCiclo.cTipCiclComis)
	{
		case PERIODICO:
		    vFechaHora();										    
		    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
		    fprintf(pfLog , "Carga lista de conceptos para ejecucion Periodica o Normal..\n\n");  
		    fprintf(stderr, "Carga lista de conceptos para ejecucion Periodica o Normal...\n\n");  
		    lstConceptosProc = stGetConceptosPer(FORMACOMIS,stCiclo);
		    return TRUE;
		case ESPORADICO:
		    vFechaHora();										    
		    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
		    fprintf(pfLog , "Carga lista de conceptos para ejecucion Esporadica	o Promocional..\n\n");	
		    fprintf(stderr, "Carga lista de conceptos para ejecucion Esporadica	o Promocional...\n\n");	 
		    lstConceptosProc = stGetConceptosProm(FORMACOMIS,stCiclo);
		    return TRUE;
		default:
		    vFechaHora();										    
		    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
		    fprintf(pfLog , "Error, Forma de Ejecucion:[%c] No reconocida..\n\n", stCiclo.cTipCiclComis);  
		    fprintf(stderr, "Error, Forma de Ejecucion:[%c] No reconocida..\n\n", stCiclo.cTipCiclComis);  
		    return FALSE;
	}
	
}
/*---------------------------------------------------------------------------*/
/*   Funcion que devuelve el puntero de	una lista			                 */
/*---------------------------------------------------------------------------*/
void vCargaPrincipal()
{			     
    stPrincipal	 * paux;											     
    lstPrincipal = NULL;														

    lstPrincipal = stfnCreaPrincipal();	 
    
    /* recorre la lista	principal para añadir listas de	planes,	usuarios y causas.. */
    for(paux=lstPrincipal; paux!=NULL; paux=paux->sgte)
    {
		fprintf(pfLog,	"(vCargaPrincipal) Carga Lista de TipPlan/CategCliente\n");
		paux->sgte_plan	= stCargaPlan(paux->iCodTipoRed, paux->szCodPlanComis, paux->iCodConcepto);
			
		if (paux->iNumListaCausa!=0)
		{
			fprintf(pfLog,"\n(vCargaPrincipal) Carga Lista de Causas [%s]\n", paux->szCodUniverso);		   
			paux->sgte_causa = stCargaParam(paux->iNumListaCausa);
		}
		if (paux->iNumListaUsuaExcep!=0)
		{
			fprintf(pfLog,"\n(vCargaPrincipal) Carga Lista de Usuarios de Excepcion\n");
			paux->sgte_usuar = stCargaParam(paux->iNumListaUsuaExcep);
		}
    }														
}
/*---------------------------------------------------------------------------*/
/* Busca la existencia de pszElemento en la lista stLista (parametros).	     */
/*---------------------------------------------------------------------------*/
BOOL bBuscaParametro(stParam * stLista,char *	pszElemento)
{								   
	if (stLista==NULL)
		return FALSE;		
	if (strcmp(stLista->szValParametro1,pszElemento)==0)	   
		return TRUE;
	else							   
		return(bBuscaParametro(stLista->sgte,pszElemento));
} 								     
 /*---------------------------------------------------------------------------*/
int bValidaEvento(stPrincipal * paux, stEvento * qaux)				
{
	stConceptosProc * raux;
	
	if (paux == NULL) 
		return(FALSE);

	if (qaux == NULL) 
		return(FALSE);

	if  ((paux->iCodTipoRed == qaux->iCodTipoRed) && 
	     (strcmp(paux->szCodTipComis , qaux->szCodTipComis)== 0) && 
	     ((strcmp(paux->szIndProcequi, qaux->szIndProcequi)== 0) ||	(strcmp(paux->szIndProcequi, "T")==	0))) 
	{
		if (paux->sgte_causa ==	NULL)
		{	    
			fprintf(pfLog, "\n[bValidaEvento] Concepto sin lista de Causas. Se asumen todas las causas validas.\n");
			fprintf(stderr,"\n[bValidaEvento] Concepto sin lista de Causas. Se asumen todas las causas validas.\n");
		}
		else
		{
			if (!bBuscaParametro(paux->sgte_causa,qaux->szCodCausaBaja))		
			{
				return(FALSE);									
			}
		}
	}			
	else
	{
		return(FALSE);									
	}						      

	if (!bValidaFechaEvento(paux->szFecDesde, paux->szFecHasta, qaux->szFechaEvento))
	{						
		fprintf(pfLog, "\n[bValidaEvento] Evento esta fuera de la vigencia del Plan de Comisiones.");
		fprintf(stderr,"\n[bValidaEvento] Evento esta fuera de la vigencia del Plan de Comisiones.");
		return (FALSE);
	}
	return(TRUE);
} 											  
/*---------------------------------------------------------------------------*/
/* PROCEDIMIENTO QUE EJECUTA EL	CALCULO	DE LA COMISION			             */
/*---------------------------------------------------------------------------*/
void vCalculaComision(stEvento * lstEventos)
{														   
    stPrincipal	* paux;											   
    stEvento	* pNuevo;	
    stEvento	* qaux;	
    
	for(qaux = lstEventos; qaux != NULL; qaux = qaux->sgte)
	{
		fprintf(pfLog, "\n[vCalculaComision] Analiza Evento. TR:[%d] NumGral.:[%ld] Universo:[%s] TipPlan:[%s] CatCte.:[%s]\n",qaux->iCodTipoRed, qaux->lNumGeneral, qaux->szCodUniverso, qaux->szTipPlan, qaux->szCodCategCliente);
		fprintf(pfLog, "\tCausa:[%s] DiasVta:[%d] Acep:[%d] Recep:[%d] ProcEqui:[%s]\n", qaux->szCodCausaBaja, qaux->iDiasVenta, qaux->iDiasAceptacion, qaux->iDiasRecepcion, qaux->szIndProcequi);
		fprintf(stderr,"\n[vCalculaComision] Analiza Evento. TR:[%d] NumGral.:[%ld] Universo:[%s] TipPlan:[%s] CatCte.:[%s]\n",qaux->iCodTipoRed, qaux->lNumGeneral, qaux->szCodUniverso, qaux->szTipPlan, qaux->szCodCategCliente);
		fprintf(stderr,"\tCausa:[%s] DiasVta:[%d] Acep:[%d] Recep:[%d] ProcEqui:[%s]\n", qaux->szCodCausaBaja, qaux->iDiasVenta, qaux->iDiasAceptacion, qaux->iDiasRecepcion, qaux->szIndProcequi);
	    
	    for(paux = lstPrincipal; paux != NULL; paux = paux->sgte)							   
	    {
			fprintf(pfLog , "\n[vCalculaComision]TR:[%d] PlComis:[%s] Conc:[%d] Universo:[%s] IndProcequi:[%s]\n",paux->iCodTipoRed, paux->szCodPlanComis, paux->iCodConcepto, paux->szCodUniverso, paux->szIndProcequi);
			fprintf(stderr, "\n[vCalculaComision]TR:[%d] PlComis:[%s] Conc:[%d] Universo:[%s] IndProcequi:[%s]\n",paux->iCodTipoRed, paux->szCodPlanComis, paux->iCodConcepto, paux->szCodUniverso, paux->szIndProcequi);
			
			if (bValidaEvento(paux,qaux))
			{
				pNuevo = (stEvento *) malloc(sizeof(stEvento));						   

				/* copiamos los valores del evento...	*/
				pNuevo->lNumGeneral		        = qaux->lNumGeneral;
				strcpy(pNuevo->szCodUniverso	, qaux->szCodUniverso);
				strcpy(pNuevo->szCodTipComis	, qaux->szCodTipComis);
				pNuevo->lCodComisionista	    = qaux->lCodComisionista;
				pNuevo->lNumCelular		        = qaux->lNumCelular;
				strcpy(pNuevo->szCodCategCliente, szfnTrim(qaux->szCodCategCliente));
				strcpy(pNuevo->szCodPlanTarif	, qaux->szCodPlanTarif);
				strcpy(pNuevo->szFechaEvento	, qaux->szFechaEvento);
				strcpy(pNuevo->szCodCausaBaja	, szfnTrim(qaux->szCodCausaBaja));
				strcpy(pNuevo->szNomUsuario	    , qaux->szNomUsuario);

				strcpy(pNuevo->szIndProcequi	, qaux->szIndProcequi);

				strcpy(pNuevo->szCodCategoria	, qaux->szCodCategoria);
				strcpy(pNuevo->szTipPlan	    , qaux->szTipPlan);
				pNuevo->iDiasVenta		        = qaux->iDiasVenta;
				pNuevo->iDiasRecepcion		    = qaux->iDiasRecepcion;
				pNuevo->iDiasAceptacion		    = qaux->iDiasAceptacion;
				pNuevo->dImporteTotal		    = 0;
				pNuevo->dImporteBase		    = 0;
				pNuevo->dImporteEquipo		    = 0;
				pNuevo->dImporteTrafico		    = 0;
				pNuevo->lCantMinutos		    = 0;
				pNuevo->dImporteTarifa		    = 0;
																   
				/* anexamos el nodo a	la lista principal */								  
				pNuevo->sgte	    = paux->sgte_evento;						     
				paux->sgte_evento   = pNuevo;								   
																   
				/* Comenzamos	la recuperación	de los montos... */							  
				/* Importe Base	y Equipo */										
				vAsignaImporteBase(paux->sgte_plan, pNuevo, paux->szCodTipCalculo, paux->iNomFechaDesde);	  
				
				if (strcmp(pNuevo->szCodUniverso, UNIRECHAZO) == 0)
				{
					if (strcmp(paux->szIndTrafico,"S") == 0)
					{
						vAsignaImporteTrafico(pNuevo);								
					}
					vEvaluaUsuarioExepcion(paux->sgte_usuar,pNuevo);     
				}												   
			}
		}													   
	}														   
} 														     
/*---------------------------------------------------------------------------*/
/* EVALUA EXCEPCION DE USUARIO:	SI EXISTE USUARIO EN LISTA, IMPORTE_BASE = 0 */
/* USUARIO = paux->szNom_Usuario					                         */
/* LISTA   = qaux							                                 */
/* SI EXISTE ->	  paux->dImp_Base = 0					                     */
/*---------------------------------------------------------------------------*/
void vEvaluaUsuarioExepcion(stParam *	qaux,stEvento *	paux)		    
{									  
    if (qaux != NULL)	
    {					  
		if (strcmp(qaux->szValParametro1 , paux->szNomUsuario)==0)
		{
	 	    paux->dImporteBase = 0;
		    fprintf(pfLog,"\t(vEvaluaUsuarioExepcion)Evento:[%ld] Universo:[%s]-->Importe Base$[%f]	UsuarioExcepcion[%s] \n",paux->lNumGeneral,paux->szCodUniverso, paux->dImporteBase, paux->szNomUsuario);
		}		
		else							  
		{
		    vEvaluaUsuarioExepcion(qaux->sgte, paux);	  
		}
	}
}										 
/*---------------------------------------------------------------------------*/
/* Funcion que inserta en la tabla Valorizados y Detalle Rechazos	         */
/*---------------------------------------------------------------------------*/
void vGrabaPrincipal()
{												     
    stPrincipal  *paux;										    
    stEvento     *qaux;										    

    long	lCantBajas;							       
    long	lCantRecha;							       
													    
    EXEC SQL BEGIN DECLARE SECTION;								       
		char	szhCodUniverso[7];							       
		int		ihCodConcepto;								       
		char	szhCodTipComis[3];							       
		long	lhCodPeriodo;								       
		char	szhIdPeriodo[11];							       
		long	lhNumGeneral;									     
		long	lhCodComisionista;								       
		double	dhImporteEquipo;								       
		double	dhImporteBase;									       
		double	dhImporteTrafico;								       
		long	lhCantMinutos;									       
		double	dhImporteTarifa;								       
		double	dhImporteConcepto;
	    int		ihCodTipoRed;							      
    EXEC SQL END DECLARE SECTION;								       
													    
    lCantBajas = 0;										       
    lCantRecha = 0;				     
	
    for(paux=lstPrincipal;paux!=NULL;paux=paux->sgte)					       
    {											       
		strcpy(szhCodUniverso	, paux->szCodUniverso);
		strcpy(szhCodTipComis	, paux->szCodTipComis);
		ihCodConcepto			= paux->iCodConcepto;
	    ihCodTipoRed            = paux->iCodTipoRed;

		lhCodPeriodo			= stCiclo.lCodCiclComis;  
	    strcpy(szhIdPeriodo		, stCiclo.szIdCiclComis);	
															    
	    for(qaux=paux->sgte_evento;qaux!=NULL;qaux=qaux->sgte)
		{
			lhNumGeneral		= qaux->lNumGeneral;
	   		lhCodComisionista	= qaux->lCodComisionista;
	   		dhImporteEquipo		= fnCnvDouble(qaux->dImporteEquipo , 0);
	   		dhImporteBase		= fnCnvDouble(qaux->dImporteBase   , 0);
	   		dhImporteTrafico	= fnCnvDouble(qaux->dImporteTrafico, 0);
	   		lhCantMinutos		= qaux->lCantMinutos;
	   		dhImporteTarifa		= qaux->dImporteTarifa;
	   		dhImporteConcepto	= 0;
											       
	   		/*Calcula el importe total */							  
	   		dhImporteConcepto = dhImporteEquipo	+ dhImporteBase + dhImporteTrafico;			
	   		dhImporteConcepto = fnCnvDouble(dhImporteConcepto, 0);
													      														      
		   EXEC SQL INSERT
			INTO CMT_VALORIZADOS (
				NUM_GENERAL,
				COD_UNIVERSO,
				COD_CONCEPTO,
				COD_TIPCOMIS,
				COD_COMISIONISTA,
				COD_PERIODO,
				ID_PERIODO,
				IMP_CONCEPTO, 
				COD_TIPORED)
			VALUES (
				:lhNumGeneral,									      
				:szhCodUniverso,								      
				:ihCodConcepto,								      
				:szhCodTipComis,								      
				:lhCodComisionista,								      
				:lhCodPeriodo,									      
				:szhIdPeriodo,									      
				:dhImporteConcepto, 
            	:ihCodTipoRed);								      
												
           	lCantBajas++ ;	
											      
	   		if (strcmp(paux->szCodUniverso, UNIRECHAZO)== 0)					      
	   		{											      
				EXEC SQL INSERT	INTO CMT_DETALLE_RECHAZOS					      
					(NUM_GENERAL      , COD_TIPCOMIS, 
             		COD_COMISIONISTA , COD_PERIODO ,		      
			 		ID_PERIODO       , COD_CONCEPTO,
		            IMP_EQUIPO       , IMP_RECHAZO ,			      
		    		IMP_TRAFICO      , MIN_SALIDA  ,
 	         		VAL_PLAN         , COD_TIPORED  )					      
				VALUES							       
					(:lhNumGeneral     , :szhCodTipComis,
             		:lhCodComisionista, :lhCodPeriodo  ,		
		 	 		:szhIdPeriodo     , :ihCodConcepto ,
             		:dhImporteEquipo  , :dhImporteBase ,		
			 		:dhImporteTrafico , :lhCantMinutos ,
             		:dhImporteTarifa  , :ihCodTipoRed);				
		
 			lCantRecha++;										
	    	}											
		}													
    }		      
												  
    lCantBajas -=lCantRecha;										     
    stStatusProc.lCantBajasWrit = lCantBajas;									 
    stStatusProc.lCantRechaWrit = lCantRecha; 
										       
}												
/*---------------------------------------------------------------------------*/
/* Funcion que retorna los minutos y el	monto							     */
/*---------------------------------------------------------------------------*/
void vAsignaImporteTrafico(stEvento *	qaux)			  
{								
    EXEC SQL BEGIN DECLARE SECTION;				
		long	lhMinutos;					
		double	dhTarifa;					
		long	lhNumCelular;					
		long	lhCodPeriodo;					
		char	szhCodPlanTarif[4];				
    EXEC SQL END DECLARE SECTION;				
								  
    lhCodPeriodo = stCiclo.lCodCiclComis;	 
    
    lhNumCelular           = qaux->lNumCelular;			  
    strcpy(szhCodPlanTarif , qaux->szCodPlanTarif);		
								
    lhMinutos =	0;						
    dhTarifa  =	0;						
																
    EXEC SQL							
    SELECT NVL (SUM (MINS_TRAF), 0)				
      INTO :lhMinutos						
    FROM TA_TRAFICO_CELULAR_MES					
    WHERE NUM_CELULAR =	:lhNumCelular				
       AND IND_ENTSAL =	2					
       AND TO_CHAR (FECHA_TRAF,	'YYYYMMDD') = :lhCodPeriodo ;	  
								
    qaux->lCantMinutos	= lhMinutos;				
								
    EXEC SQL							
    SELECT NVL(MAX (tarifa),0)
      INTO :dhTarifa
      FROM (SELECT NVL((60 * IMP_AIRE /	SEG_FRACCION),0) AS TARIFA
	      FROM TA_TFAIRE
	     WHERE CLS_TARIFA =	'LOC'
	       AND TIP_DIA = '1'
	       AND COD_FRANCONS	= 'FCG'
	       AND COD_PLANTARIF = :szhCodPlanTarif
	    UNION
	    SELECT NVL((60 * IMP_AIRE_RF / SEG_FRACCION),0)
	      FROM TA_TFAIRE
	     WHERE CLS_TARIFA =	'LOC'
	       AND TIP_DIA = '1'
	       AND COD_FRANCONS	= 'FCG'
	       AND COD_PLANTARIF = :szhCodPlanTarif
	    UNION
	    SELECT NVL((60 * IMP_AIRE_RM / SEG_FRACCION),0)
	      FROM TA_TFAIRE
	     WHERE CLS_TARIFA =	'LOC'
	       AND TIP_DIA = '1'
	       AND COD_FRANCONS	= 'FCG'
	       AND COD_PLANTARIF = :szhCodPlanTarif);
								
    qaux->dImporteTarifa=dhTarifa;				
								
    qaux->dImporteTrafico = dhTarifa *	lhMinutos;
    fprintf(pfLog,"\t-->Importe	Tarifa$[%f] Trafico$[%f] \n", qaux->dImporteTarifa, qaux->dImporteTrafico);
} 								  
/*---------------------------------------------------------------------------*/
/* FUNCION QUE ASIGNA IMPORTE BASE					     				     */
/*---------------------------------------------------------------------------*/
void vAsignaImporteBase(stPlan *lstPlan, stEvento * pNuevo, char * pszCodTipCalculo, int piNomDias)
{												
    char	cCodTipCalculo[2];
    int		iDiasDesde;								  
    
    strcpy(cCodTipCalculo , pszCodTipCalculo);
    
    if (lstPlan	== NULL)
    {												
	pNuevo->dImporteBase	      =	0.00;
	pNuevo->dImporteEquipo	      =	0.00;                                              

    }												
    else											
    {
	    if (((strcmp(lstPlan->szTipPlan   ,  pNuevo->szTipPlan	      )==0)&&		   
		(strcmp(lstPlan->szCodCategCliente,  pNuevo->szCodCategCliente)==0)) ||		
		((strcmp(lstPlan->szTipPlan,"TODAS") == 0) &&	
		(strcmp(lstPlan->szCodCategCliente,"TODAS") ==	0 )))
		{										  
			pNuevo->dImporteEquipo	      =	lstPlan->dImporteEquipo;    
			
			fprintf	(pfLog,"\n(vAsignaImporteBase) cCodTipCalculo [%s]",cCodTipCalculo);
			if(strcmp(cCodTipCalculo,"D") == 0)
			{
				pNuevo->dImporteBase	      =	lstPlan->dImporteBase;
			}
			if(strcmp(cCodTipCalculo,"I") == 0)
			{
  			    /* determina la cantidad de días a considerar	en la evaluacion de plazos */
			    iDiasDesde = iGetDiasDesde(pNuevo,piNomDias);
				/* evalúa la cantidad de días con la lista de plazos. */
				pNuevo->dImporteBase	 = dGetImportePlazos(lstPlan->sgte_tiempo,iDiasDesde);
			}															
		}
		else
			vAsignaImporteBase(lstPlan->sgte, pNuevo, cCodTipCalculo, piNomDias);
	}
    fprintf(pfLog,"\n\t-->Evento [%ld] Importe Base$[%f] Equipo$[%f]", pNuevo->lNumGeneral,pNuevo->dImporteBase, pNuevo->dImporteEquipo);
}
/*---------------------------------------------------------------------------*/
/* FUNCION QUE DETERMINA LA CANTIDAD DE	DIAS (PARAMETRO) A EVALUAR PARA	     */
/* LOS PLAZOS.								     							 */
/*---------------------------------------------------------------------------*/
int iGetDiasDesde(stEvento * qaux, int iDias)
{
	int	iRetorno = 0;
	fprintf(pfLog, "\n\t(iGetDiasDesde) Nombre de Fecha:[%d]",iDias);
	switch (iDias)
	{
		case iDIASVENTA:
			iRetorno = qaux->iDiasVenta;
			break;
		case iDIASRECEP:
			iRetorno = qaux->iDiasRecepcion;
			break;
		case iDIASACEPT:
			iRetorno = qaux->iDiasAceptacion;
			break;
	}
	fprintf(pfLog, " Dias Retorno:[%d]\n",iRetorno);
	return (iRetorno);
}
/*---------------------------------------------------------------------------*/
/* Funcion de busca el importe de plazos				     				 */
/*---------------------------------------------------------------------------*/
double dGetImportePlazos(stTiempos * qaux,int	iDias)
{												    
    int	iContinue = 0;
    double	dImporte = 0.0;
	
    if (qaux == NULL) return(0);
       
    fprintf(pfLog,"\n(dGetImportePlazos)Dias :[%d]\n",iDias);

    if (iDias <= qaux->iDiasDesde)
    {
		fprintf(pfLog,"\n\t Es Primer Tramo... Dias:[%d] <= Desde:[%d] Comision:[%f]\n",iDias,qaux->iDiasDesde, qaux->dImpPenaliza);
		return(qaux->dImpPenaliza);
    }
	
    while(iContinue == 0)
    {
		fprintf(pfLog,"\n\t -> Evalua tramo Desde:[%d] Hasta:[%d] Comision:[%f]",qaux->iDiasDesde, qaux->iDiasHasta,qaux->dImpPenaliza );
		if (((iDias > qaux->iDiasDesde)&&(iDias <= qaux->iDiasHasta))||(qaux->iDiasHasta == -1))
		{
			dImporte = qaux->dImpPenaliza;
			iContinue = 1;
			fprintf(pfLog,"	Encontrado!!!\n");
		}
		else
		{
			fprintf(pfLog,"	Siguiente!!!\n");
			qaux = qaux->sgte;
			if (qaux == NULL)
			{
				dImporte = 0.0;
				iContinue = 1;
			}
		}
    }
    return (dImporte);
} 												      
/*---------------------------------------------------------------------------*/
/* Funcion de Carga de Parametro					     					 */
/*---------------------------------------------------------------------------*/
stParam * stCargaParam( int piCodTipCodigo)						
{										      
    stParam	   *paux;							      
    stParam	   *qaux;							      
										      
    int		  	           i;							
    short	iLastRows    = 0;						
    int		iFetchedRows = MAXFETCH;					
    int		iRetrievRows = MAXFETCH;					
											
    EXEC SQL BEGIN DECLARE SECTION;							
		char	szhValParametro1[MAXFETCH][11];				
		int		ihCodCodigo;  
		int		ihTipCodigo;
		long	lMaxFetch;							
    EXEC SQL END DECLARE SECTION;							

    paux = NULL;
    qaux = NULL;

    ihTipCodigo = ITIPOCODIGO;
    ihCodCodigo	= piCodTipCodigo;
    lMaxFetch   = MAXFETCH;

    EXEC SQL DECLARE Cur_Parametro CURSOR FOR
	SELECT VAL_PARAMETRO1
	FROM   CMD_PARAMETROS
	WHERE  COD_TIPCODIGO	= :ihTipCodigo
	AND    COD_CODIGO	= :ihCodCodigo
	AND    COD_PARAMETRO	> 0;
    EXEC SQL OPEN Cur_Parametro;

    while(iFetchedRows == iRetrievRows)
    {
		EXEC SQL for :lMaxFetch
			 FETCH Cur_Parametro INTO :szhValParametro1;

		iRetrievRows = sqlca.sqlerrd[2]	- iLastRows;
		iLastRows    = sqlca.sqlerrd[2];
	
		for (i=0; i < iRetrievRows; i++)
		{
			paux = (stParam	*) malloc(sizeof(stParam));

			strcpy(paux->szValParametro1  , szfnTrim(szhValParametro1[i]));

			fprintf(pfLog,	"\t(stCargaParam)Parametro...[%s]\n", paux->szValParametro1);
			paux->sgte	  = qaux;
			qaux		  = paux;
		}
    }
    EXEC SQL CLOSE Cur_Parametro;							
    return(qaux);								
} 											  
/*---------------------------------------------------------------------------*/
/*  Funcion para Planes													     */
/*---------------------------------------------------------------------------*/
stPlan * stCargaPlan( int piCodTipoRed , char * pszCodPlanComis , int piCodConcepto )
{										     
	stPlan	      *pPlanaux;							     
	stPlan	      *qaux;							       
	int			               i;							       
	short		iLastRows    = 0;					       
	int		iFetchedRows = MAXFETCH;				       
	int		iRetrievRows = MAXFETCH;				       
										       
	EXEC SQL BEGIN DECLARE SECTION;	
		int     ihCodTipoRed      ;		
		int		ihCodConcepto     ;
    	char    szhCodPlanComis[6];			       

		long	lMaxFetch;

		char	szhTipoPlan		[MAXFETCH][6];					    
		char	szhCodCategCliente	[MAXFETCH][11];				    
		double	dhImpBase		[MAXFETCH];					     
		double	dhImpEquipo		[MAXFETCH];						  
	EXEC SQL END DECLARE SECTION;						       
										     
	ihCodTipoRed            = piCodTipoRed;
	ihCodConcepto			= piCodConcepto;
	strcpy(szhCodPlanComis	, pszCodPlanComis);
										     
	lMaxFetch = MAXFETCH;							       
	qaux      = NULL;	  

	EXEC SQL DECLARE CUR_PLANES CURSOR FOR
		SELECT TIP_PLAN,
		       COD_CATEGCLIENTE,
		       NVL(IMP_BASE,0),
		       NVL(IMP_EQUIPO,0)
		FROM   CM_DETPENALIZA_TD
		WHERE COD_TIPORED   = :ihCodTipoRed
		AND   COD_PLANCOMIS = :szhCodPlanComis
        AND   COD_CONCEPTO  = :ihCodConcepto;
		  										       
	EXEC SQL OPEN CUR_PLANES;   

	while(iFetchedRows == iRetrievRows)					       
	{									       
		EXEC SQL for :lMaxFetch						       
			 FETCH CUR_PLANES INTO					       
				:szhTipoPlan,						
				:szhCodCategCliente,				       
				:dhImpBase,					       
				:dhImpEquipo;					       
										     
		iRetrievRows = sqlca.sqlerrd[2]	- iLastRows;			       
		iLastRows    = sqlca.sqlerrd[2];  
		
						
		for (i=0; i < iRetrievRows; i++)				       
		{
			pPlanaux = (stPlan *) malloc(sizeof(stPlan));			 
			
			strcpy(pPlanaux->szTipPlan			, szfnTrim(szhTipoPlan[i]));
			strcpy(pPlanaux->szCodCategCliente	, szfnTrim(szhCodCategCliente[i]));
			pPlanaux->dImporteBase				= dhImpBase[i];										  
			pPlanaux->dImporteEquipo			= dhImpEquipo[i];

			fprintf(pfLog,"\tszTipPlan	      	  [%s]\n",pPlanaux->szTipPlan	    );
			fprintf(pfLog,"\tszCodCategCliente    [%s]\n",pPlanaux->szCodCategCliente );
			fprintf(pfLog,"\tdImporteBase	      [%f]\n",pPlanaux->dImporteBase	    );
			fprintf(pfLog,"\tdImporteEquipo       [%f]\n",pPlanaux->dImporteEquipo    );
			
			fprintf(pfLog,"\tCarga Plazos de evaluacion para Universo de Datos.\n");
			pPlanaux->sgte_tiempo = stCargaTiempo(ihCodTipoRed   ,
                                                  szhCodPlanComis,
                                                  ihCodConcepto  ,
                                                  pPlanaux->szTipPlan,
                                                  pPlanaux->szCodCategCliente);
			pPlanaux->sgte	= qaux;															      
			qaux		= pPlanaux;															  
		}			
	}			      
	EXEC SQL CLOSE CUR_PLANES;    
	return(qaux);		      
}
/*----------------------------------------------------------------------------*/
/*  Funcion para los Plazos						      */
/*----------------------------------------------------------------------------*/
stTiempos *stCargaTiempo(int piCodTipoRed, char * pszCodPlanComis, int piCodConcepto, char * pszTipPlan, char * pszCodCategCliente)
{													  
	stTiempos	*paux;										    
	stTiempos	*qaux;										    
	int			i;										    
	short		iLastRows    = 0;								    
	int			iFetchedRows = MAXFETCH;							    
	int			iRetrievRows = MAXFETCH;							    

	EXEC SQL BEGIN DECLARE SECTION;
    	int		ihCodTipoRed;
     	char    szhCodPlanComis[6];
  	    int		ihCodConcepto;
		char	szhTipPlan[6];
		char	szhCodCategCliente[11];

		long	lMaxFetch;

		int		ihDiasDesde[MAXFETCH];
		int		ihDiasHasta[MAXFETCH];
		double	dhImpPenaliza[MAXFETCH];
	EXEC SQL END DECLARE SECTION;
		
	ihCodTipoRed              =  piCodTipoRed;
    ihCodConcepto		  	  =  piCodConcepto;
    strcpy(szhCodPlanComis	  ,  pszCodPlanComis);
	strcpy(szhTipPlan	  	  ,  pszTipPlan);
    strcpy(szhCodCategCliente ,  pszCodCategCliente);

	paux = NULL;
	qaux = NULL;
	lMaxFetch = MAXFETCH;

	EXEC SQL DECLARE CUR_PLAZOS CURSOR FOR
		SELECT DIAS_DESDE,
		       DIAS_HASTA,
		       IMP_PENALIZA
		FROM   CM_PLAZOS_PENALIZA_TD
	WHERE  COD_TIPORED      = :ihCodTipoRed
     AND   COD_CONCEPTO		= :ihCodConcepto
	 AND   COD_PLANCOMIS	= :szhCodPlanComis
	 AND   TIP_PLAN			= :szhTipPlan
	 AND   COD_CATEGCLIENTE	= :szhCodCategCliente
	ORDER BY DIAS_DESDE DESC;
	
	EXEC SQL OPEN CUR_PLAZOS;

	while(iFetchedRows == iRetrievRows)
	{
		EXEC SQL for :lMaxFetch
		FETCH CUR_PLAZOS INTO
		 		:ihDiasDesde,
		     	:ihDiasHasta,
		     	:dhImpPenaliza;
		
		iRetrievRows = sqlca.sqlerrd[2]	- iLastRows;
		iLastRows    = sqlca.sqlerrd[2];

		for (i=0; i < iRetrievRows; i++)
		{
			paux = (stTiempos *) malloc(sizeof(stTiempos));

			paux->iDiasDesde     =	ihDiasDesde[i];
			paux->iDiasHasta     =	ihDiasHasta[i];
			paux->dImpPenaliza   =	dhImpPenaliza[i];
	
			fprintf(pfLog, "\t\t(stCargaTiempo)iDiasDesde	  :[%d]\n",paux->iDiasDesde	);
			fprintf(pfLog, "\t\t(stCargaTiempo)iDiasHasta	  :[%d]\n",paux->iDiasHasta	);
			fprintf(pfLog, "\t\t(stCargaTiempo)dImpPenaliza   :[%f]\n",paux->dImpPenaliza);

			paux->sgte	  = qaux;
			qaux		  = paux;
		}
	}													    
	EXEC SQL CLOSE CUR_PLAZOS;									    
	return(qaux);										    
} 													    
/*----------------------------------------------------------------------------*/
/* Obtiene categoria de	Plan tarifario para evaluar Excepcion de Plan Total   */
/*----------------------------------------------------------------------------*/
char * szfnCategoriaPlan(char * pszCodPlanTarif,char * pszhFecVenta)								
{															      
    EXEC SQL BEGIN DECLARE SECTION;												
		char	szhFecVenta[9];												
		char	szhCodPlanTarif[4];											
		char	szhCodCategoria[4];											
    EXEC SQL END DECLARE SECTION;		 
    
    strcpy (szhCodPlanTarif, pszCodPlanTarif);
    strcpy (szhFecVenta, pszhFecVenta);
	
    EXEC SQL SELECT COD_CATEGORIA												
	       INTO :szhCodCategoria												
	       FROM VE_CATPLANTARIF												
  	      WHERE COD_PLANTARIF   =	:szhCodPlanTarif									
	      AND   COD_PRODUCTO    =	1											
	      AND   FEC_EFECTIVIDAD =	(SELECT	MAX(FEC_EFECTIVIDAD)								
					 FROM   VE_CATPLANTARIF						
					 WHERE  COD_PLANTARIF    = :szhCodPlanTarif			
					 AND    FEC_EFECTIVIDAD <= TO_DATE(:szhFecVenta,'YYYYMMDD'));	
	
    return (szfnTrim(szhCodCategoria));											
} 																  
/*---------------------------------------------------------------------------*/
/* Carga Eventos de Baja						     */
/*---------------------------------------------------------------------------*/
stEvento * stCargaEventosBaja()
{
    stConceptosProc * raux;    
    stEvento	    * paux;
    stEvento	    * qaux;

    int		i;
    short	iLastRows    = 0;
    int		iFetchedRows = MAXFETCH;
    int		iRetrievRows = MAXFETCH;
    int		lCantReg = 0;
	
    EXEC SQL BEGIN DECLARE SECTION;
    	char    szhCodTipComis[3];        
		char	szhCodUniverso[7];
		long	lhCodPeriodo;
		char	szhIdPeriodo[11];

		long	lMaxFetch;
	
		long	lhNumGeneral		[MAXFETCH];
		long	lhCodComisionista	[MAXFETCH];
		long	lhNumCelular		[MAXFETCH];
		char	szhCodCategCliente	[MAXFETCH][11];
		char	szhCodPlanTarif		[MAXFETCH][4];
		char	szhFecBaja			[MAXFETCH][11];
		char	szhFecVenta			[MAXFETCH][9];
		char	szhFecAux			[9];		 		
		char	szhCodCausaBaja		[MAXFETCH][6];
		char	szhNomUsuario		[MAXFETCH][31];
		char	szhIndProcequi		[MAXFETCH][2];
		char	szhTipPlan			[MAXFETCH][6];
		int		ihDiasVenta			[MAXFETCH];
		int		ihDiasRecepcion		[MAXFETCH];
		int		ihDiasAceptacion	[MAXFETCH];
    	int	    ihCodTipoRed        [MAXFETCH];
    EXEC SQL END DECLARE SECTION;
	
    paux = NULL;  
    qaux = NULL;
    lCantReg  = 0;	

    lhCodPeriodo	  	  = stCiclo.lCodCiclComis;
    strcpy(szhCodUniverso , UNIBAJAS);
    strcpy(szhIdPeriodo	  , stCiclo.szIdCiclComis);
    
    
    for (raux = lstConceptosProc; raux != NULL; raux = raux->sgte)
    {        
		strcpy(szhCodTipComis	, raux->szCodTipComis);
		iLastRows    	= 0;          
		iFetchedRows 	= MAXFETCH;   
		iRetrievRows 	= MAXFETCH;   
		lMaxFetch 		= MAXFETCH;   
	
	    fprintf(stderr, "\n[stCargaEventosBaja] Cargando Eventos de Baja...TipComis[%s] Ciclo:[%s]\n",szhCodTipComis, szhIdPeriodo );
		
        EXEC SQL DECLARE CUR_BAJAS CURSOR FOR
			SELECT	A.NUM_GENERAL, 
					A.COD_COMISIONISTA,
					A.NUM_CELULAR, 
					A.COD_CATEGCLIENTE, 
					A.COD_PLANTARIF, 
					TO_CHAR(A.FEC_BAJA,'DD-MM-YYYY'),
					TO_CHAR(A.FEC_VENTA,'YYYYMMDD'),
					A.COD_CAUSABAJA, 
					C.NOM_USUARIO,
					A.IND_PROCEQUI,	
					C.TIP_PLAN,
					TRUNC(A.FEC_BAJA - A.FEC_VENTA),	 
					TRUNC(A.FEC_BAJA - A.FEC_RECEPCION),
					TRUNC(A.FEC_BAJA - A.FEC_ACEPTACION), 
					A.COD_TIPORED
	   		FROM 	CMT_BAJAS_CELULAR A, 
	        	 	CMD_PLANESTARIF C
			WHERE 	A.COD_TIPCOMIS  = :szhCodTipComis
	  		AND 	A.COD_PERIODO   = :lhCodPeriodo
	  		AND 	A.ID_PERIODO    = :szhIdPeriodo
	  		AND	 	A.COD_PLANTARIF = C.COD_PLANTARIF;

		EXEC SQL OPEN CUR_BAJAS; 

		while(iFetchedRows == iRetrievRows)
		{
	   		EXEC SQL for :lMaxFetch
		 		FETCH CUR_BAJAS INTO 
			       	:lhNumGeneral		,
			        :lhCodComisionista	,
		       		:lhNumCelular		,
		       		:szhCodCategCliente	,
		       		:szhCodPlanTarif	,
		       		:szhFecBaja			,
		       		:szhFecVenta		,
		       		:szhCodCausaBaja	,  
		       		:szhNomUsuario		,  
		       		:szhIndProcequi		,    
		       		:szhTipPlan			, 
		       		:ihDiasVenta		,
		       		:ihDiasRecepcion	,
		       		:ihDiasAceptacion   , 
				    :ihCodTipoRed		;
	     				 
	   		iRetrievRows = sqlca.sqlerrd[2]- iLastRows;
	   		iLastRows    = sqlca.sqlerrd[2];
					
	   		for (i=0; i < iRetrievRows; i++)
	   		{		    
	 			paux = (stEvento *) malloc(sizeof(stEvento));
			
				strcpy(paux->szCodTipComis		, szhCodTipComis);
				strcpy(paux->szCodUniverso		, UNIBAJAS);
				paux->lNumGeneral				= lhNumGeneral[i];
				paux->lCodComisionista			= lhCodComisionista[i];
				paux->lNumCelular				= lhNumCelular[i];
				paux->iCodTipoRed				= ihCodTipoRed[i];

				strcpy(paux->szCodCategCliente	, szfnTrim(szhCodCategCliente[i]));
				strcpy(paux->szCodPlanTarif		, szfnTrim(szhCodPlanTarif[i]));
				strcpy(paux->szFechaEvento		, szfnTrim(szhFecBaja[i]));
				
				strcpy(szhFecAux				, szfnTrim(szhFecVenta[i]));
				strcpy(paux->szCodCategoria		, szfnCategoriaPlan(paux->szCodPlanTarif,szhFecAux));

				strcpy(paux->szCodCausaBaja		, szfnTrim(szhCodCausaBaja[i]));
				strcpy(paux->szNomUsuario		, szfnTrim(szhNomUsuario[i]));
				strcpy(paux->szIndProcequi		, szfnTrim(szhIndProcequi[i]));
				strcpy(paux->szTipPlan			, szfnTrim(szhTipPlan[i]));
			
				paux->iDiasVenta		= ihDiasVenta[i];	   
				paux->iDiasRecepcion	= ihDiasRecepcion[i]; 
				paux->iDiasAceptacion	= ihDiasAceptacion[i];
				paux->dImporteTotal		= 0;
				paux->dImporteBase		= 0;
				paux->dImporteEquipo	= 0;
				paux->dImporteTrafico	= 0;
				paux->lCantMinutos		= 0;
				paux->dImporteTarifa	= 0;
		
				paux->sgte	  = qaux;
				qaux		  = paux;
				lCantReg++;
	   		}
		}
    	EXEC SQL CLOSE CUR_BAJAS;
    }	
    stStatusProc.lCantBajasRead = lCantReg;
    fprintf(pfLog,"(stCargaEventosBaja) Registros Leidos [%d].\n", lCantReg);
    fprintf(stderr,"(stCargaEventosBaja) Registros Leidos [%d].\n", lCantReg);
    return(qaux);
}
/*---------------------------------------------------------------------------*/
/* Carga Eventos de Rechazo						     */
/*---------------------------------------------------------------------------*/
stEvento * stCargaEventosRechazo()
{
    stConceptosProc * raux;    
    stEvento	    * paux;
    stEvento	    * qaux;
	
    int					   i;
    short	iLastRows    = 0;
    int		iFetchedRows = MAXFETCH;
    int		iRetrievRows = MAXFETCH;
    long	lCantReg;

    EXEC SQL BEGIN DECLARE SECTION;
    	char    szhCodTipComis[3];        
		char	szhCodUniverso[6];
		long	lhCodPeriodo;
		char	szhIdPeriodo[11];

		long	lMaxFetch;

		long	lhNumGeneral		[MAXFETCH]; 
		long	lhCodComisionista	[MAXFETCH];
		long	lhNumCelular		[MAXFETCH];	  
		char	szhCodCategCliente	[MAXFETCH][11];	  
		char	szhCodPlanTarif		[MAXFETCH][4];	     
		char	szhFecRechazo		[MAXFETCH][11];		 
		char	szhFecVenta			[MAXFETCH][9];		 
		char	szhFecAux			[9];		 
		char	szhCodCausaRec		[MAXFETCH][3];
		char	szhNomUsuario		[MAXFETCH][31];		  
		char	szhIndProcequi		[MAXFETCH][2];
		char	szhTipPlan			[MAXFETCH][6];
		int		ihDiasVenta			[MAXFETCH];	     
		int		ihDiasRecepcion		[MAXFETCH];	   
    	int	    ihCodTipoRed        [MAXFETCH];  	
    EXEC SQL END DECLARE SECTION;
		
    lCantReg = 0;
    strcpy(szhCodUniverso,  UNIRECHAZO);

    lhCodPeriodo	  	=  stCiclo.lCodCiclComis;
    strcpy(szhIdPeriodo ,  stCiclo.szIdCiclComis);
	
    paux = NULL;  
    qaux = NULL;		
    lMaxFetch = MAXFETCH;

    for (raux = lstConceptosProc; raux != NULL; raux = raux->sgte)
    {			
		strcpy(szhCodTipComis	, raux->szCodTipComis);
		iLastRows    	= 0;          
		iFetchedRows 	= MAXFETCH;   
		iRetrievRows 	= MAXFETCH;   
		lMaxFetch 		= MAXFETCH;   
				
		EXEC SQL DECLARE CUR_RECHAZ CURSOR FOR
			SELECT	A.NUM_GENERAL, 
					A.COD_COMISIONISTA,
					A.NUM_CELULAR,	    
					A.COD_CATEGCLIENTE, 
					A.COD_PLANTARIF, 
					TO_CHAR(A.FEC_RECHAZO,'DD-MM-YYYY'),
					TO_CHAR(A.FEC_VENTA,'YYYYMMDD'),
					A.COD_CAUSAREC,	
					A.NOM_USUARIO,
					A.IND_PROCEQUI,	
					C.TIP_PLAN,
					TRUNC(A.FEC_RECHAZO - A.FEC_VENTA),	       
					TRUNC(A.FEC_RECHAZO - A.FEC_RECEPCION), 
	 				A.COD_TIPORED
			FROM	CMT_RECHAZOS_CELULAR A,	
					CMD_PLANESTARIF	C
			WHERE	A.NUM_GENERAL >	0
			AND		A.COD_TIPCOMIS  = :szhCodTipComis
			AND		A.COD_PERIODO	= :lhCodPeriodo
			AND		A.ID_PERIODO	= :szhIdPeriodo 
			AND		C.COD_PLANTARIF	= A.COD_PLANTARIF;

		EXEC SQL OPEN CUR_RECHAZ;
		
		while(iFetchedRows == iRetrievRows)
		{
	    	 EXEC SQL for :lMaxFetch
			 	FETCH CUR_RECHAZ INTO	
					:lhNumGeneral		,
					:lhCodComisionista	,
					:lhNumCelular		,
					:szhCodCategCliente	,
					:szhCodPlanTarif	,
					:szhFecRechazo		,
					:szhFecVenta		,
					:szhCodCausaRec		,	
					:szhNomUsuario		,	
					:szhIndProcequi		,
					:szhTipPlan			,
					:ihDiasVenta		,   
					:ihDiasRecepcion	, 
					:ihCodTipoRed		;
													 
	     	iRetrievRows = sqlca.sqlerrd[2]	- iLastRows;
	     	iLastRows    = sqlca.sqlerrd[2];

	     	for (i=0; i < iRetrievRows; i++)
	     	{
				paux = (stEvento *) malloc(sizeof(stEvento));
			
				strcpy(paux->szCodUniverso		, UNIRECHAZO);	
				paux->lNumGeneral				= lhNumGeneral[i];
				strcpy(paux->szCodTipComis		, szhCodTipComis);
				paux->lCodComisionista			= lhCodComisionista[i];
				paux->lNumCelular				= lhNumCelular[i];
				strcpy(paux->szCodCategCliente	, szfnTrim(szhCodCategCliente[i]));
				strcpy(paux->szCodPlanTarif		, szfnTrim(szhCodPlanTarif[i]));
				strcpy(paux->szFechaEvento		, szfnTrim(szhFecRechazo[i]));
				strcpy(paux->szCodCausaBaja		, szfnTrim(szhCodCausaRec[i]));
				strcpy(paux->szNomUsuario		, szfnTrim(szhNomUsuario[i]));
				strcpy(paux->szIndProcequi		, szfnTrim(szhIndProcequi[i]));
				strcpy(paux->szTipPlan			, szfnTrim(szhTipPlan[i]));	 

				paux->iCodTipoRed				= ihCodTipoRed[i];     
				paux->iDiasVenta				= ihDiasVenta[i];
				paux->iDiasRecepcion			= ihDiasRecepcion[i];	
				
				strcpy(szhFecAux				, szfnTrim(szhFecVenta[i]));
				strcpy(paux->szCodCategoria		, szfnCategoriaPlan(paux->szCodPlanTarif,szhFecAux));
				paux->iDiasAceptacion			= 0;						     
				paux->dImporteTotal				= 0;
				paux->dImporteBase				= 0;
				paux->dImporteEquipo			= 0;
				paux->dImporteTrafico			= 0;
				paux->lCantMinutos				= 0;
				paux->dImporteTarifa			= 0;
			
				paux->sgte	  = qaux;
				qaux		  = paux;
				lCantReg++;
	  	   }
		}
    	EXEC SQL CLOSE CUR_RECHAZ;
    }
    stStatusProc.lCantRechaRead = lCantReg;
    fprintf(pfLog,"(stCargaEventosRechazo) Cantidad de Registros:[%ld].\n", lCantReg);
    fprintf(stderr,"(stCargaEventosRechazo) Cantidad de Registros:[%ld].\n", lCantReg);
    return(qaux);
}

/*---------------------------------------------------------------------------*/
/* Rutina principal.							     						 */
/*---------------------------------------------------------------------------*/
int main (int argc, char *argv[])
{
/*---------------------------------------------------------------------------*/
/* Variables Globales.													     */
/*---------------------------------------------------------------------------*/
    long  lSegIni, lSegFin;	    
    short ibiblio;	
/*---------------------------------------------------------------------------*/
/* Recuperacion	del tiempo de inicio del proceso, en segundos.			     */
/*---------------------------------------------------------------------------*/
    lSegIni=lGetTimer();
/*---------------------------------------------------------------------------*/
/* Inicializacion de estructura	de argumentos externos,	de estadistica del   */
/* proceso y de	alguna otra estructura.					    				 */
/*---------------------------------------------------------------------------*/
    memset(&stCiclo, 0,	sizeof(reg_ciclo));	    
    memset(&stStatusProc, 0, sizeof(stStatusProc));
/*---------------------------------------------------------------------------*/
/* Manejo de argumentos	ingresados como	parametros externos.			     */
/*---------------------------------------------------------------------------*/
    memset(&stArgs, 0, sizeof(rg_argumentos));	   
    vManejaArgs(argc, argv);
/*---------------------------------------------------------------------------*/
/* Conexion a la base de datos Oracle.					    				 */
/*---------------------------------------------------------------------------*/	       
    strcpy(szhUser, stArgs.szUser);						    
    strcpy(szhPass, stArgs.szPass); 	
											   
    if(fnOraConnect(szhUser, szhPass) == FALSE)						 
    {										       
	 	fprintf(stderr, "\nUsuario/Password Oracle no son validos. Se cancela.\n");
	 	exit(EXIT_205);							    
    }										       
    else									       
    {										       
	 	fprintf(stderr, "\nConexion con la base de datos ha sido exitosa.\n");	    
	 	fprintf(stderr, "Username: %s\n\n", szhUser);				    
    }										       
/*---------------------------------------------------------------------------*/
/* Inicia estructura de	proceso	y bloques.				    				 */
/*---------------------------------------------------------------------------*/
    vInicia_Estructura_Procesos(stArgs.szBloque, stArgs.szProceso,szhUser, stArgs.izSecuencia);	    
    ibiblio = iAccesa_Traza_Procesos(ABRIR_TRAZA,0,"",0,0);					    
    if (ibiblio)										    
    {												    
		fprintf(stderr,	"Error al Abrir	Traza");						    
		fprintf(stderr,	"Error [%d] al escribir	Traza de Proceso.\n", ibiblio);			    
		exit(ibiblio);										    
    }												    
/*---------------------------------------------------------------------------*/
/* Preparacion de ambiente para	archivos de log	y datos.		     		 */
/*---------------------------------------------------------------------------*/
    fprintf(stderr, "Preparando	ambiente para archivos de log, de datos	y de configuracion ...\n");		       
    if((pszEnvLog = (char *)pszEnviron("XPCM_LOG", ""))	== (char *)NULL)					       
    {														       
		exit(iAccesa_Traza_Procesos(CERRAR_TRAZA_NOK,EXIT_401,"VARIABLE	DE AMBIENTE XPCM_LOG NO	RECONOCIDA.",0,0));
    }														       
    fprintf(stderr, "Directorio	de Logs		: [%s]\n", (char *)pszEnvLog);					       
/*---------------------------------------------------------------------------*/
/* GENERACION DEL NOMBRE Y CREACION DEL	ARCHIVO	DE LOG.			     		 */
/*---------------------------------------------------------------------------*/
    strncpy(szFechaYYYYMMDD,szfnObtieneFecYYYYMMDD(),8);
    strncpy(szhSysDate, pszGetDateLog(),16);								    
    strcpy(stArgsLog.szProceso,LOGNAME);									    
    strncpy(stArgsLog.szSysDate,szhSysDate,16);									    
    sprintf(stArgsLog.szPath,"%s%s/%s",pszEnvLog,stArgsLog.szProceso,szFechaYYYYMMDD);				    
														   
    if((pfLog =	fAbreArchivoLog()) == (FILE *)NULL)								    
    {														    
       fprintf(stderr, "\nArchivo [%s] no pudo ser abierto.\n",	LOGNAME);					 
       fprintf(stderr, "Revise su existencia.\n");								   
       fprintf(stderr, "Error Numero: %d     %s\n", errno, strerror(errno));					   
       fprintf(stderr, "Proceso	finalizado con error.\n");							   
       exit(iAccesa_Traza_Procesos(CERRAR_TRAZA_NOK,EXIT_301,"ARCHIVO DE DATOS NO PUDO SER ABIERTO.",0,0));	   
    }														    
/*---------------------------------------------------------------------------*/
/* Header.								     								 */
/*---------------------------------------------------------------------------*/	
    vFechaHora();                                                               
    fprintf(stderr, "\nProcesando ...\n");                                        
    fprintf(pfLog, "%s\n", szRaya);                    
    fprintf(pfLog, "\n\n%s\n", (char *)pszFechaHora());
    fprintf(pfLog, "%s\n", GLOSA_PROG);                
    fprintf(pfLog, "VERSION %s\n", PROG_VERSION);      
    fprintf(pfLog, "Ultima Revision: [%s]\n", LAST_REVIEW);                
	fprintf(pfLog, "Base de datos : %s\n", (strcmp(getenv((const char *)"TWO_TASK"), "")!=0?getenv((const char *)"TWO_TASK"):getenv((const char *)"ORACLE_SID")));
    fprintf(pfLog,"Usuario ORACLE      :[ %s ]\n",(char * )sysGetUserName() ); 
    fprintf(pfLog, "%s\n\n", szRaya);                  

    fprintf(pfLog, "\n Argumentos de Ejecucion\n");
    fprintf(pfLog, "Identificador de Ciclo 			<%s>\n", stArgs.szIdPeriodo);
    fprintf(pfLog, "Identificador de Proceso		<%s>\n", stArgs.szProceso);
    fprintf(pfLog, "Identificador de Bloque			<%s>\n", stArgs.szBloque);
    fprintf(pfLog, "Secuencia de Ejecucion			<%d>\n", stArgs.izSecuencia);

/*---------------------------------------------------------------------------*/
/* Modificacion	de configuracion ambiental, para manejo	de fechas en Oracle. */
/*---------------------------------------------------------------------------*/
    EXEC SQL ALTER SESSION SET NLS_DATE_FORMAT='dd-mm-yyyy';	    
/*---------------------------------------------------------------------------*/
/*    INICIA PROCESAMIENTO PRINCIPAL.					     				 */
/*---------------------------------------------------------------------------*/
    fprintf(pfLog,  "Inicio procesamiento principal ...\n\n");
    fprintf(stderr, "Inicio procesamiento principal ...\n\n");
/*---------------------------------------------------------------------------*/
/* CARGA DATOS DEL PERIODO DE COMISIONES				     				 */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
    fprintf(pfLog , "Carga fechas que definen el periodo actual...\n\n");  
    fprintf(stderr, "Carga fechas que definen el periodo actual...\n\n");  
    if (!vCargaCiclo(stArgs.szIdPeriodo,&stCiclo))    
    {
		fprintf(pfLog, "\n\n[Main] Ciclo que pretende Ejecutar no existe.\n");
		fprintf(pfLog, "[Main] Se cancela la ejecucion.\n");
		fprintf(pfLog, "\n\n[Main] Ciclo que pretende Ejecutar no existe.\n");
		fprintf(pfLog, "[Main] Se cancela la ejecucion.\n");
		exit(EXIT_101);
    }
/*--------------------------------------------------------------------------*/
/* Carga Estructura de Conceptos y Tipos de Red	a Procesar...(Estándar)	    */
/*--------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog , "\n\n%s\n",	(char *)pszFechaHora());		      
    fprintf(pfLog , "Gestiona Carga de Datos y Parametros..\n\n");  
    fprintf(stderr, "Gestiona Carga de Datos y Parametros...\n\n");  
	if (!bCargaConceptos())
	{
		fprintf(stderr,	"\nError Recuperando Lista de Conceptos	de comisiones.\n");
		fprintf(stderr,	"Revise	la parametrizacion.\n");
		fprintf(stderr,	"Proceso finalizado con	error.\n");
		exit(iAccesa_Traza_Procesos(CERRAR_TRAZA_NOK,EXIT_301,"NO PUEDE	CARGAR LISTA DE	CONCEPTOS DE COMISION.",0,0));
	}    
/*---------------------------------------------------------------------------*/
/* CARGA ESTRUCTURA PRINCIPAL DE VALORACION DE UNIVERSOS		     		 */
/*---------------------------------------------------------------------------*/
    vFechaHora();										    
    fprintf(pfLog ,  "\n\n%s\n", (char *)pszFechaHora());		       
    fprintf(pfLog ,  "Carga estructura principal de valoracion...\n\n");       
    fprintf(stderr,  "Carga estructura principal de valoracion...\n\n");       
    vCargaPrincipal();										   
/*---------------------------------------------------------------------------*/
/* CARGA UNIVERSO DE BAJAS DE CONTRATO DEL PERIODO			     			 */
/*---------------------------------------------------------------------------*/
    vFechaHora();									 
    fprintf(pfLog ,  "\n\n%s\n", (char *)pszFechaHora());	 
    fprintf(pfLog ,  "Carga universo de bajas...\n\n");	 
    fprintf(stderr,  "Carga universo de bajas...\n\n");	 
    lstBajas = stCargaEventosBaja();
/*---------------------------------------------------------------------------*/
/* CARGA UNIVERSO DE RECHAZOS DE CONTRATO DEL PERIODO			     		 */
/*---------------------------------------------------------------------------*/
    vFechaHora();								    
    fprintf(pfLog,	"\n\n%s\n", (char *)pszFechaHora());
    fprintf(pfLog,	"Carga universo	de rechazos ...\n\n");	
    fprintf(stderr,	"Carga universo	de rechazos ...\n\n");	
    lstRechazos = stCargaEventosRechazo();						
/*---------------------------------------------------------------------------*/
/* CALCULA COMISION SOBRE EL UNIVERSO DE BAJAS							     */
/*---------------------------------------------------------------------------*/
    vFechaHora();								     
    fprintf(pfLog   , "\n\n%s\n", (char *)pszFechaHora()); 
    fprintf(pfLog   , "Calcula comisión por bajas...\n\n");
    fprintf(stderr  , "Calcula comisión por bajas...\n\n");
    vCalculaComision(lstBajas);							
/*---------------------------------------------------------------------------*/
/* CALCULA COMISION SOBRE EL UNIVERSO DE RECHAZOS						     */
/*---------------------------------------------------------------------------*/
    vFechaHora();									
    fprintf(pfLog   ,	"\n\n%s\n", (char *)pszFechaHora());	
    fprintf(pfLog   ,	"Calcula comisión por rechazos...\n\n");
    fprintf(stderr  ,	"Calcula comisión por rechazos...\n\n");
    vCalculaComision(lstRechazos);							
/*---------------------------------------------------------------------------*/
/* GRABA REGISTROS EN CMT_VALORIZADOS....				    				 */
/*---------------------------------------------------------------------------*/
    vFechaHora();									      
    fprintf(pfLog   ,	"\n\n%s\n", (char *)pszFechaHora());	      
    fprintf(pfLog   ,	"Graba resultados en cmt_valorizados...\n\n");
    fprintf(stderr  ,	"Graba resultados en cmt_valorizados...\n\n");
    vGrabaPrincipal();									
/*---------------------------------------------------------------------------*/
/* LIBERA MEMORIA UTILIZADA...						     					 */
/*---------------------------------------------------------------------------*/
    vFechaHora();									  
    fprintf(pfLog ,	"\n\n%s\n", (char *)pszFechaHora());	  
    fprintf(pfLog ,	"Libera	memoria	utilizada...\n\n");	
    fprintf(stderr,	"Libera	memoria	utilizada...\n\n");	
    vLiberaPrincipal(lstPrincipal);						 
    vLiberaDatosEvento(lstBajas);						 
    vLiberaDatosEvento(lstRechazos);	
    vLiberaConceptosVal(lstConceptosProc);					
/*---------------------------------------------------------------------------*/
/* Recuperacion	de los segundos	reales ocupados	por el proceso.		     	 */
/*---------------------------------------------------------------------------*/
    lSegFin=lGetTimer();					  
    stStatusProc.lSegProceso = lSegFin - lSegIni;	
/*---------------------------------------------------------------------------*/
/* Despliegue de la informacion	estadistica del	proceso.		     		 */
/*---------------------------------------------------------------------------*/
    fprintf(pfLog,  "\nEstadistica del proceso\n");								 
    fprintf(pfLog,	"------------------------\n");									 
    fprintf(pfLog,	"Segundos Reales Utilizados	: [%d]\n",stStatusProc.lSegProceso);				 
    fprintf(pfLog,	"Cantidad de Bajas Leidas	: [%d]\n",stStatusProc.lCantBajasRead);			       
    fprintf(pfLog,	"Cantidad de Bajas Valoradas	: [%d]\n",stStatusProc.lCantBajasWrit);			       
    fprintf(pfLog,	"Cantidad de Rechazos Leidos	: [%d]\n",stStatusProc.lCantRechaRead);			       
    fprintf(pfLog,	"Cantidad de Rechazos Valorados	: [%d]\n",stStatusProc.lCantRechaWrit);			       

    fprintf(stderr, "\nEstadistica del proceso\n");								 
    fprintf(stderr,	"------------------------\n");									 
    fprintf(stderr,	"Segundos Reales Utilizados	: [%d]\n",stStatusProc.lSegProceso);				 
    fprintf(stderr,	"Cantidad de Bajas Leidas	: [%d]\n",stStatusProc.lCantBajasRead);			       
    fprintf(stderr,	"Cantidad de Bajas Valoradas	: [%d]\n",stStatusProc.lCantBajasWrit);			       
    fprintf(stderr,	"Cantidad de Rechazos Leidos	: [%d]\n",stStatusProc.lCantRechaRead);			       
    fprintf(stderr,	"Cantidad de Rechazos Valorados	: [%d]\n",stStatusProc.lCantRechaWrit);			       
																	       
    if (iAccesa_Traza_Procesos(CERRAR_TRAZA_OK,0,"",stStatusProc.lSegProceso, stStatusProc.lCantBajasWrit +	stStatusProc.lCantRechaWrit))  
		exit(iAccesa_Traza_Procesos(CERRAR_TRAZA_NOK,EXIT_400,"NO SE PUDO CERRAR TRAZA OK.",0,0));					

	fprintf(pfLog,"\n\n\nProceso [%s] finalizado ok.\n", basename(argv[0]));
	fprintf(stderr,"\n\n\nProceso [%s] finalizado ok.\n", basename(argv[0]));
    
    EXEC SQL COMMIT	WORK RELEASE;													  
    return(EXIT_0);
}


/******************************************************************************************/
/** Información de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisión                                            : */
/**  %PR% */
/** Autor de la Revisión                                : */
/**  %AUTHOR% */
/** Estado de la Revisión ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creación de la Revisión                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/

