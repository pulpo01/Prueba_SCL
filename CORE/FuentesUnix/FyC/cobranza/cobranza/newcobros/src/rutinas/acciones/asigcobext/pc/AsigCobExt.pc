/* ==================================================================================================
Tipo        :  ACCION
Nombre      :  AsigCobExt.pc ("ACEXT"->szfnAsigCobExt)
Descripcion :  ASIGna una entidad de COBranza EXTerna ( Pre-Judicial)
               a todos los abonados del rut del cliente dado
Recibe      :  by Val -> Cod Cliente 
Devuelve    :  "SQL"  -> Ocurrio un error de oracle ( queda registrado en el log )
               "NORUT"-> Fue imposible determinar el rut del cliente dado
               "NOAGE"-> Fue imposible asignar un agente (entidad)
               "PND"  -> La accion queda pendiente                         / MGG_27032001 /
   				"NODIR"-> Fue imposible determinar la direccion del cliente / MGG_27032001 /
   				"OK"   -> La accion se ejecuto correctamente
Autor       :  Roy Barrera Richards
Fecha       :  10 - Agosto - 2000 

Modificaciones	:	
==================================================================================================
2004-03-09  :  Se comenta UPDATE CO_MOROSOS CH-200402171678 MAC.
2004-08-17  :  GAC. Homologacion a Incidencia PR-200406100505
Modificacion:  12-11-2004
					Por proyecto P_MAS-04037 se agregan 2 parametros a la accion
               Puntero de archivo log tipo Hilo. 
               Variable de contexto para instancia de BD tipo hilo
================================================================================================== */

#define _COLIBGENERALES_PC_ /* Agregado por PGonzalez 20-10-2004 MAS-04037 */
#define _COLIBACCIONES_PC_  /* Agregado por PGonzalez 20-10-2004 MAS-04037 */
#include	"AsigCobExt.h"
#define	HOST_ARRAY_AGENTES  500  

EXEC SQL INCLUDE sqlca;

/* ================================================================================================== */
/* funcion de asignacion de entidad de cobranza externa                                               */
/* ================================================================================================== */
char *szfnAsigCobExt (FILE **ptArchLog, long lCliente, sql_context ctxCont )
{
EXEC SQL BEGIN DECLARE SECTION;

	TDATOSCOB stDatosCob;
	char	szhEntGestCob[21];
	long	lhCodCliente = 0;
	long	lhCodClienteNew = 0;
	char	szhCodRegion[4];			   EXEC SQL VAR szhCodRegion IS STRING (4);
	char	szhCodComuna[6];			   EXEC SQL VAR szhCodComuna IS STRING (6);
	int   ihDirCorrespondencia = 3;
	char  szhCodEntidadAsig[6];		EXEC SQL VAR szhCodEntidadAsig IS STRING (6);
	char  szhCodAgenteAsig[31];		EXEC SQL VAR szhCodAgenteAsig IS STRING (31);
	char  szhCodAgenteNew[31];		   EXEC SQL VAR szhCodAgenteNew IS STRING (31);
	long  lhCodCuentaNew = 0;
	char  szhAuxHoy[15];				   EXEC SQL VAR szhAuxHoy IS STRING (15);
	int   ihIncrementoClientes = 0;
	char  szhCodAgente[HOST_ARRAY_AGENTES][31];
	char  szhCodEntidad[HOST_ARRAY_AGENTES][6]; 
	int   ihPrcAsignado[HOST_ARRAY_AGENTES];
	int   ihMorososAgente[HOST_ARRAY_AGENTES];
	int   ihCnt = 0;
	char  szhUser[31];				   EXEC SQL VAR szhUser IS STRING (31);
	char  szhNomUsuario[31];			EXEC SQL VAR szhNomUsuario IS STRING (31);
	int   iCountGest=0;
	char  szCodGestion[3+1];
	char  szCodOperadora[21];        EXEC SQL VAR szCodOperadora IS STRING (21);
	/*vbles bind*/
	char  szhEjecutivoCob [41];
	char  szhYYYYMMDDHH24MISS [17];
	char  szhRutinaACEXT [6];
	char  szhEstadoEJE   [4];
	char  szhMovimSM [3];
	char  szhLetra_R [2];  
	char  szhLetra_I [2];
	char  szhLetra_G [2];
	char  szhLetra_V [2];
	char  szhLetra_N [2];
	char  szhLetra_E [2];
	char  szhLetra_B [2];
	char  szhLetra_J [2];
	
	int   ihValor_cero= 0;
	int   ihValor_dos = 2;
	sql_context CXX;
EXEC SQL END DECLARE SECTION;
char  modulo[] = "szfnAsigCobExt";
int   iResp = 0, iMetropolitana = 13, iAsignado = 0, i = 0, iMorososComuna = 0, iPorcentajeTotal = 0;
long  lTotalRows = 0;
float fPorcentajeDefinido = 0.0, fPorcentajeActual = 0.0;
char  szRutina[] = "A", szMovimiento[] = "A", szValParametro[21];
BOOL  bCalcularAgente = FALSE;
struct sqlca sqlca;
FILE  *pfLog=*ptArchLog;

	CXX = ctxCont;
	EXEC SQL CONTEXT USE :CXX;

	ifnTrazaHilos( modulo,&pfLog, "Ingreso modulo => [%s].", LOG03, modulo );
	ifnTrazaHilos( modulo,&pfLog, "VERSION : [%s].", LOG03, szVersion);

	strcpy(szhEjecutivoCob,"CAMBIA EJECUTIVO COBRANZA A PRE-JUDICIAL");
	strcpy(szhYYYYMMDDHH24MISS,"YYYYMMDDHH24MISS");
	strcpy(szhRutinaACEXT,"ACEXT");
	strcpy(szhEstadoEJE  ,"EJE");
	strcpy(szhMovimSM, "SM");
	strcpy(szhLetra_R,"R");
   strcpy(szhLetra_I,"I");
   strcpy(szhLetra_G,"G");
   strcpy(szhLetra_V,"V");
   strcpy(szhLetra_N,"N");
   strcpy(szhLetra_E,"E");
   strcpy(szhLetra_B,"B");
   strcpy(szhLetra_J,"J");
	

	memset( szhEntGestCob, '\0', sizeof( szhEntGestCob ) );
	memset( szhEntGestCob, '\0', sizeof( szhEntGestCob ) );
	memset( szhCodRegion, '\0', sizeof( szhCodRegion ) );
	memset( szhCodComuna, '\0', sizeof( szhCodComuna ) );
	memset( szhCodEntidadAsig, '\0', sizeof( szhCodEntidadAsig ) );
	memset( szhCodAgenteAsig, '\0', sizeof( szhCodAgenteAsig ) );
	memset( szhCodAgenteNew, '\0', sizeof( szhCodAgenteNew ) );
	memset( szhAuxHoy, '\0', sizeof( szhAuxHoy ) );
	memset( szCodOperadora, '\0', sizeof( szCodOperadora ) );
	memset( szValParametro, '\0', sizeof( szValParametro ) );
	memset( szhUser, '\0', sizeof( szhUser ) );
	memset( szhNomUsuario, '\0', sizeof( szhNomUsuario ) );

   lhCodCliente = lCliente;
	stDatosCob.lCodCliente = 0;
	strcpy( stDatosCob.szRutSantiago, "N" );

	/* obtenemos la entidad a la cual va dirigida la Cobranza Externa */
   if (ifnRecuperaGedParametro(&pfLog, "ENTIDAD_GESTION_COB", "CO", szhEntGestCob, CXX )!=0) 
      return "ERENC";
    
	stDatosCob.lCodCliente = lhCodCliente;
	stDatosCob.dMtoDeuda = 0;

	/* Obtiene el Rut del Cliente -*/
    iResp = ifnGetRutCliente(&pfLog, lCliente, stDatosCob.szNumIdent, stDatosCob.szCodTipIdent, CXX );
    if( iResp == 0 ) 
        return "NORUT";		/* No encontro el rut */
    else if( iResp < 0 )
        return "PND";		/* error oracle */

	iResp = 0; /* todo ok */

	ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], NumIdent => [%s], TipIdent => [%s].", LOG06, lhCodCliente, stDatosCob.szNumIdent, stDatosCob.szCodTipIdent );

	if( !strcmp( szhEntGestCob, "C" ) )
	{
		/* Obtener la deuda del cliente */
	    if( !ifnGetSaldoVencidoAcc(&pfLog, lhCodCliente, &stDatosCob.dMtoVencido, CXX ) )
			return "PND";

		/* vemos en que situacion se encuentra */
		sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
		EXEC SQL
		SELECT COD_MOVIMIENTO,
			   COD_ENVIO,
			   TO_CHAR( SYSDATE, :szhYYYYMMDDHH24MISS ),
			   USER,
			   NOM_USUARIO
		  INTO :stDatosCob.szCodMovimiento,
		  	   :stDatosCob.szCodEnvio,
		  	   :szhAuxHoy,
			   :szhUser,
			   :szhNomUsuario
		  FROM CO_COBEXTERNA
		 WHERE COD_CLIENTE = :lhCodCliente
		   AND COD_MOVIMIENTO <> :szhLetra_R 
		   AND COD_ENVIO NOT IN ( :szhLetra_R, :szhLetra_I, :szhLetra_G, :szhLetra_V, :szhLetra_N, :szhLetra_E ); /* Reasignado:Ingresado:Generado:Visado */

		if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
		{
			ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], SELECT CO_COBEXTERNA CLIENTE => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
			return "SECOB";
		}
		else if( sqlca.sqlcode != SQLNOTFOUND )
		{
			/* el cliente esta en Cobranza Externa */
			rtrim( stDatosCob.szCodMovimiento );
			rtrim( stDatosCob.szCodEnvio );

			ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], Movimiento => [%s] Envio => [%s].", LOG03, lhCodCliente, stDatosCob.szCodMovimiento, stDatosCob.szCodEnvio );  
	
	    	if( !strcmp( stDatosCob.szCodMovimiento, "SM" ) )				/* si no tiene movimiento */
			{
				if( !strcmp( stDatosCob.szCodEnvio, "B" ) )               	/* si el envio es de baja */
				{ 
		        	bCalcularAgente = TRUE;
	            }                                    
				else
				{
					if( !strcmp( szhUser, szhNomUsuario ) ) /* el usuario varia entre automatica y puntual */
					{
						ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], Ya se encuentra en Cobranza Externa.", LOG03, lhCodCliente );  
						return "CESCO";											/* inconsistencia en datos de cobranza */
					}
				}
			}
            else if( !strcmp( stDatosCob.szCodMovimiento, "B" ) )
	        { 
 				/* si se iba a dar de baja */
	        	bCalcularAgente = TRUE;
		    }
			else															 /* puede ser A o M */
			{
				if( !strcmp( szhUser, szhNomUsuario ) ) /* el usuario varia entre automatica y puntual */
				{
					ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], Ya se encuentra en Cobranza Externa.", LOG03, lhCodCliente );  
					return "CESCO";											/* inconsistencia en datos de cobranza */
				}
			}

			return "OK";

		} /* if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND ) */

		/* debemos buscar si hay otro cliente asignado a cobranza externa y sea de la misma operadora y misma cuenta */
		sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
		EXEC SQL
		SELECT E.DES_ENTIDAD,
			   C.COD_ENTIDAD
		  INTO :szhCodAgenteAsig,
		  	   :stDatosCob.szCodEntidad
		  FROM CO_ENTCOB E, GE_CLIENTES G, CO_COBEXTERNA C
		 WHERE C.NUM_IDENT = :stDatosCob.szNumIdent
		   AND C.COD_TIPIDENT = :stDatosCob.szCodTipIdent
		   AND C.COD_CLIENTE != :lhCodCliente
		   AND C.COD_MOVIMIENTO NOT IN ( :szhLetra_R )
		   AND C.COD_ENVIO NOT IN ( :szhLetra_B, :szhLetra_R, :szhLetra_I, :szhLetra_G, :szhLetra_V, :szhLetra_N, :szhLetra_E ) /* Reasignado:Ingresado:Generado:Visado */
		   AND C.COD_CLIENTE = G.COD_CLIENTE
		   AND G.COD_OPERADORA IN ( SELECT COD_OPERADORA
		   							  FROM GE_CLIENTES
		   							 WHERE COD_CLIENTE = :lhCodCliente )
		   AND C.COD_ENTIDAD = E.COD_ENTIDAD
		   AND E.TIP_ENTIDAD = :szhLetra_E			   							 
		   AND ROWNUM < :ihValor_dos;

		if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
		{
			ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], Error al buscar Entidad => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
			return "BUSEN";
		}
		else if( sqlca.sqlcode != SQLNOTFOUND ) /* hay otro, asignar el mismo agente */
		{		
			rtrim( szhCodAgenteAsig );
			rtrim( stDatosCob.szCodEntidad );

			ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], Entidad => [%s], Ya existe otro cliente en Cobranza.", LOG05, lhCodCliente, szhCodAgenteAsig );  

			sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
			EXEC SQL 
			UPDATE CO_MOROSOS
			   SET COD_AGENTE  = :szhCodAgenteAsig
			 WHERE COD_CLIENTE = :lhCodCliente;
			 
			if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
			{
				ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], UPDATE CO_MOROSOS => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
				return "UPMOR";
			}

		    strcpy( stDatosCob.szRutSantiago, "N" );

			if( !bfnInsertaCobExterna( &pfLog, &stDatosCob, szhEntGestCob, CXX ) )
				return "INCOB";

			/* debemos actualizar la co_gestion, con un alta transitoria */
			if( !bfnActualizaCoGestionClienteAcc(&pfLog, lhCodCliente, stDatosCob.lCodCuenta, stDatosCob.szNumIdent, stDatosCob.szCodTipIdent, stDatosCob.szCodEntidad, szRutina, szMovimiento, CXX ) )
				return "UPGES";

            /****** GAC 08.09.03 **** Se actualiza COD_AGENTE para todos los clientes del rut *******/
            sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
            EXEC SQL UPDATE CO_MOROSOS
                     SET COD_AGENTE = (SELECT UNIQUE DES_ENTIDAD  /*Se agrega UNIQUE para que rtorne solo una entidad 20.06.2004 PR-505 CAPC */
	                                 FROM CO_ENTCOB A, CO_COBEXTERNA B
	                                WHERE A.COD_ENTIDAD = B.COD_ENTIDAD
	                                  AND B.NUM_IDENT   =  :stDatosCob.szNumIdent 
                                          AND B.COD_TIPIDENT = :stDatosCob.szCodTipIdent
                                          AND b.cod_movimiento not in ( :szhLetra_B, :szhLetra_R )  /* Homol.a PR-0505 17.08.2004 GAC */
                                          AND b.cod_envio not in ( :szhLetra_B, :szhLetra_R ))      /* Homol.a PR-0505  17.08.2004 GAC */
                     WHERE NUM_IDENT  = :stDatosCob.szNumIdent
                     AND COD_TIPIDENT = :stDatosCob.szCodTipIdent;
            
			if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND ) {
				ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], UPDATE CO_MOROSOS COD_AGENTE de RUT => [%s]", LOG00,lhCodCliente, sqlca.sqlerrm.sqlerrmc );
				return "UPCON"; /* error oracle*/
			}                     
	
			return "OK"; /* No hace nada mas, ya hay agente de Cobranza Pre-Judicial */
		}
		/* si no existe otro cliente, debe buscar un agente */
	}
	else /* la gestion esta dirigida a la cuenta */
	{
		/* Obtener la deuda del rut del cliente */
		if( !bfnGetSaldoPorRutAcc(&pfLog, stDatosCob.szNumIdent, stDatosCob.szCodTipIdent, &stDatosCob.dMtoVencido, CXX ) ) 
			return "PND";

		sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
		EXEC SQL
		SELECT A.COD_ENTIDAD, 
			   A.COD_MOVIMIENTO, 
			   A.COD_ENVIO,
			   TO_CHAR( A.FEC_MOVIMIENTO, :szhYYYYMMDDHH24MISS ),
			   TO_CHAR( SYSDATE, :szhYYYYMMDDHH24MISS ),
			   COD_CUENTA
		  INTO :stDatosCob.szCodEntidad,
			   :stDatosCob.szCodMovimiento,
			   :stDatosCob.szCodEnvio,
			   :stDatosCob.szFecMovimiento,
			   :szhAuxHoy,
			   :stDatosCob.lCodCuenta
		  FROM CO_COBEXTERNA A
		 WHERE A.NUM_IDENT 	= :stDatosCob.szNumIdent
		   AND A.COD_TIPIDENT = :stDatosCob.szCodTipIdent
		   AND COD_MOVIMIENTO <> :szhLetra_R
		   AND COD_ENVIO NOT IN ( :szhLetra_R, :szhLetra_I, :szhLetra_G, :szhLetra_V, :szhLetra_N, :szhLetra_E ); /* Reasignado:Ingresado:Generado:Visado */

		if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
		{
			ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], SELECT CO_COBEXTERNA CUENTA => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
			return "SECOB";
		}

		if( sqlca.sqlcode != SQLNOTFOUND ) /* La cuenta ya esta en cobranza */
		{
			rtrim( stDatosCob.szCodEntidad );
			rtrim( stDatosCob.szCodMovimiento );
			rtrim( stDatosCob.szCodEnvio );
			rtrim( stDatosCob.szFecMovimiento );
			rtrim( szhAuxHoy );

			/* debemos validar si el cliente a ingresar, ya estaba en forma puntual */
			sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
			EXEC SQL
			SELECT COUNT(1)
			  INTO :ihCnt
			  FROM CO_ACCIONES
			 WHERE COD_CLIENTE = :lhCodCliente
			   AND NUM_SECUENCIA > :ihValor_cero
			   AND COD_RUTINA = :szhRutinaACEXT
			   AND COD_ESTADO = :szhEstadoEJE; 

			if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
			{
				ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], SELECT COUNT(1) CO_ACCIONES => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
				return "SECOB";
			}
			
			if( ihCnt == 0 ) /* solo si el cliente no esta en Cobranza Externa */
			{
				/* debemos actualizar la co_gestion, con un alta transitoria */
				if( !bfnActualizaCoGestionClienteAcc(&pfLog, lhCodCliente, stDatosCob.lCodCuenta, stDatosCob.szNumIdent, stDatosCob.szCodTipIdent, stDatosCob.szCodEntidad, szRutina, szMovimiento, CXX ) )
					return "UPGES";
	
				ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], Entidad => [%s] stDatosCob.szCodMovimiento => [%s].", LOG03, lhCodCliente, stDatosCob.szCodEntidad,stDatosCob.szCodMovimiento );  
	
		    	if( !strcmp( stDatosCob.szCodMovimiento, "SM" ) )				/* si no tiene movimiento */
				{
			       if( !strcmp( stDatosCob.szCodEnvio,"B" ) )               	/* si el envio es de baja */
		            { 
		                strcpy( stDatosCob.szCodMovimiento, "A" );            	/* cambiar cod_movimiento a 'A' */
		                strcpy( stDatosCob.szFecMovimiento, szhAuxHoy );      	/* cambiar fecha del movimiento */
		                ihIncrementoClientes = 0;                   			/* no incrementa la cantidad de clientes */
		            }                                    
		            else                                            			/* puede ser A o M */
		            { 
		                strcpy( stDatosCob.szCodMovimiento, "M" );            	/* cambiar cod_movimiento a 'M' */
		                strcpy( stDatosCob.szFecMovimiento, szhAuxHoy );      	/* cambiar fecha del movimiento */
		                ihIncrementoClientes = 1;                   			/* incrementa la cantidad de clientes */
		            }                                    
		        }
		        else
			   	{
			   		if( !strcmp( stDatosCob.szCodMovimiento, "B" ) )			/* si se iba a dar de baja */
		            {
		            	strcpy( stDatosCob.szCodMovimiento, "M" );            	/* cambiar cod_movimiento a 'A' */
		                strcpy( stDatosCob.szFecMovimiento, szhAuxHoy );      	/* cambiar fecha del movimiento */
		                ihIncrementoClientes = 0;                   			/* no incrementa la cantidad de clientes */
				    }
				    else                                            			/* puede ser A o M */
				    {
		                strcpy( stDatosCob.szFecMovimiento, szhAuxHoy );      	/* cambiar fecha del movimiento */
		                ihIncrementoClientes = 1;                   			/* incrementa la cantidad de clientes */
		            }
				} /* if( strcmp( stDatosCob.szCodMovimiento,"SM" ) == 0 ) */                                        
	
				/* transformamos decimales segun definicion para la operadora tratada */
				ifnTrazaHilos( modulo,&pfLog, "Valores antes de transformer stDatosCob.dMtoVencido = [%.4f].", LOG08, stDatosCob.dMtoVencido );  
				stDatosCob.dMtoVencido = fnCnvDouble( stDatosCob.dMtoVencido, 0 );
				ifnTrazaHilos( modulo,&pfLog, "Valores despues de transformer stDatosCob.dMtoVencido = [%.4f].", LOG08, stDatosCob.dMtoVencido );  
	
				sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
				EXEC SQL
				UPDATE CO_COBEXTERNA
				   SET CNT_CLIENTES = CNT_CLIENTES + :ihIncrementoClientes,
				       COD_MOVIMIENTO = :stDatosCob.szCodMovimiento, 
				       FEC_MOVIMIENTO = TO_DATE( :stDatosCob.szFecMovimiento, :szhYYYYMMDDHH24MISS ),
				       MTO_VENCIDO = :stDatosCob.dMtoVencido
				 WHERE NUM_IDENT = :stDatosCob.szNumIdent
				   AND COD_TIPIDENT = :stDatosCob.szCodTipIdent
				   AND COD_MOVIMIENTO <> :szhLetra_R 
				   AND COD_ENVIO NOT IN ( :szhLetra_R, :szhLetra_I, :szhLetra_G, :szhLetra_V, :szhLetra_N, :szhLetra_E ); /* Reasignado:Ingresado:Generado:Visado */
	
				if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
				{
					ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] UPDATE CO_COBEXTERNA => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
					return "UPCOB"; /* error oracle*/
				}
	
				if( ihIncrementoClientes > 0 ) /* si se incrementan los clientes */
				{
					/*  debemos dejar consistente el registro de no clientes, si existiera */
					sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
					EXEC SQL
					UPDATE CO_COBEXTERNA
					   SET CNT_CLIENTES = CNT_CLIENTES + :ihIncrementoClientes,
					       MTO_VENCIDO = :stDatosCob.dMtoVencido
					 WHERE NUM_IDENT = :stDatosCob.szNumIdent
					   AND COD_TIPIDENT = :stDatosCob.szCodTipIdent
					   AND COD_MOVIMIENTO = :szhMovimSM
					   AND COD_ENVIO IN ( :szhLetra_I, :szhLetra_G, :szhLetra_V ); /* Ingresado:Generado:Visado */
	
					if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
					{
						ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], UPDATE CO_COBEXTERNA NO CLIENTE => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
						return "UPCON"; /* error oracle*/
					}
					
				} /* if( ihIncrementoClientes > 0 ) */
				
			} /* if( ihCnt == 0 ) */

            sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
            EXEC SQL UPDATE CO_MOROSOS
                     SET COD_AGENTE = (SELECT UNIQUE DES_ENTIDAD  
	                                 FROM CO_ENTCOB A, CO_COBEXTERNA B
	                                WHERE A.COD_ENTIDAD = B.COD_ENTIDAD
	                                  AND B.NUM_IDENT   =  :stDatosCob.szNumIdent 
                                          AND B.COD_TIPIDENT = :stDatosCob.szCodTipIdent
                                          AND b.cod_movimiento not in ( :szhLetra_B, :szhLetra_R ) 
                                          AND b.cod_envio not in ( :szhLetra_B, :szhLetra_R ))     
                     WHERE NUM_IDENT  = :stDatosCob.szNumIdent
                     AND COD_TIPIDENT = :stDatosCob.szCodTipIdent;

            if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
            {
               ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld], UPDATE CO_MOROSOS COD_AGENTE de RUT => [%s]", LOG00,lhCodCliente, sqlca.sqlerrm.sqlerrmc );
               return "UPCON"; /* error oracle*/
            }

			return "OK"; /* No hace nada mas, porque ya esta como cobranza Pre-Judicial */
			
		} /* if( sqlca.sqlcode != SQLNOTFOUND ) */

	} /* if( !strcmp( szhEntGestCob, "C" ) ) */

    /* debemos actualizar la co_gestion, con un alta transitoria */
	sprintf( stDatosCob.szCodEntidad, "X\0" );
	if( !bfnActualizaCoGestionClienteAcc(&pfLog, lhCodCliente, 0, stDatosCob.szNumIdent, stDatosCob.szCodTipIdent, stDatosCob.szCodEntidad, szRutina, szMovimiento, CXX ) )
		return "UPGES";

	/* Determinar comuna asociada a la direccion de correspondencia del cliente */
	sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
	EXEC SQL
	SELECT C.COD_REGION, 
		   C.COD_COMUNA
	  INTO :szhCodRegion, 
		   :szhCodComuna
	  FROM GE_DIRECCIONES C, GA_DIRECCLI B
	 WHERE B.COD_CLIENTE = :lhCodCliente
	   AND B.COD_TIPDIRECCION = :ihDirCorrespondencia  	/* 3 */
	   AND C.COD_DIRECCION = B.COD_DIRECCION;

    if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
    {   
        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] SELECT GE_DIRECCIONES => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
        return "PND";
    } 
	else if( sqlca.sqlcode == SQLNOTFOUND )
	{
    	/* Si el cliente no tiene direccion de correspondencia, se busca el menor codigo de las que tiene mgg_27.03.01 */
		sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
		EXEC SQL
		SELECT C.COD_REGION, C.COD_COMUNA
		  INTO :szhCodRegion, :szhCodComuna
		  FROM GE_DIRECCIONES C, GA_DIRECCLI B
		 WHERE B.COD_CLIENTE = :lhCodCliente
		   AND B.COD_TIPDIRECCION = ( SELECT MIN( COD_TIPDIRECCION ) FROM GA_DIRECCLI WHERE COD_CLIENTE = :lhCodCliente )
		   AND C.COD_DIRECCION = B.COD_DIRECCION;

		if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
		{
        	ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] SELECT GE_DIRECCIONES => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
        	return "PND";
		} 
		else if( sqlca.sqlcode == SQLNOTFOUND )
		{
        	ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] NO TIENE DIRECCION DE CORRESPONDENCIA.", LOG00, lhCodCliente );  
        	return "NODIR";     /* No encontro direccion para el cliente */
		}
	}

	sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
	EXEC SQL
	SELECT COD_OPERADORA_SCL
	INTO   :szCodOperadora
	FROM   GE_OPERADORA_SCL_LOCAL;
	if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND ) 	{  
		ifnTrazaHilos( modulo,&pfLog,  "Error al recuperar Codigo Operadora Local ==> [%s].", LOG00, sqlca.sqlerrm.sqlerrmc );
		return "EPARG";
	}  

	ifnTrazaHilos( modulo,&pfLog,  "Valor de Operadora recuperado ==> [%s].", LOG05, szCodOperadora);

   if (ifnRecuperaGedParametro(&pfLog, "OPER_CALCULO_REGION", "CO", szValParametro, CXX )!=0) 
      return "EPARG";

	rtrim( szCodOperadora );
	rtrim( szValParametro );

	/* esto es valido solo para la operadora TMC */
	if( !strcmp( szCodOperadora, szValParametro ) )
    {
	    if( atoi( szhCodRegion ) != iMetropolitana ) /* la direccion no es de la region metropolitana */
	    {
	        /*-- Verificar si el Rut tiene asociados clientes con direccion en Santiago */
	        iResp = ifnRutMetropolitano(&pfLog, lhCodCliente, &i, CXX );
	        if( iResp < 0 )
	            return "PND";       /* error oracle */
	        else if( iResp == 0 )
	            return "NORUT";     /* no hallo el rut */
	    }
	    else
	    {
	        i = 1 ; /* marca como metropolitano */
	    }

	    strcpy( stDatosCob.szRutSantiago, "N" );
	    if( i == 1 )   
	    {
			 if (ifnRecuperaGedParametro(&pfLog, "COMUNA_STGO_CENTRO", "CO", szhCodComuna, CXX )!=0) 
			    return "EPARG";

          strcpy( stDatosCob.szRutSantiago, "S" );
	    }
	}
   ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] Comuna => [%s].", LOG03, lhCodCliente, szhCodComuna );  
   /* Obtiene los agentes de cobranzas de la comuna y sus porcentajes definidos */
    sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
    EXEC SQL 
    DECLARE curEntExt CURSOR FOR
    SELECT A.COD_AGENTE,
           A.PRC_ASIGNACION,
           C.COD_ENTIDAD
      FROM CO_ENTCOB C,
           CO_AGENCOB B,
           CO_AGENCOMU A
     WHERE A.COD_COMUNA  = :szhCodComuna 
       AND B.COD_AGENTE  = A.COD_AGENTE
       AND C.COD_ENTIDAD = B.COD_ENTIDAD
       AND C.TIP_ENTIDAD = :szhLetra_E  /* EXTERNO */
       AND C.TIP_COBRANZA != :szhLetra_J ; /* JUDICIAL */

    if( sqlca.sqlcode )
    {   
        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] DECLARE curEntExt => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
        return "BUSEN";   
    }

    sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
    EXEC SQL OPEN curEntExt ;
    if( sqlca.sqlcode )
    {   
        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] OPEN curEntExt => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
        return "BUSEN";   
    }

    sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
    EXEC SQL 
    FETCH curEntExt 
     INTO :szhCodAgente, :ihPrcAsignado, :szhCodEntidad;

    lTotalRows = SQLROWS;    

    if ( sqlca.sqlcode != SQLNOTFOUND && sqlca.sqlcode != SQLOK )
	{
        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] FETCH curEntExt => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
		return "BUSEN";
	}
	else if ( sqlca.sqlcode != SQLNOTFOUND )
	{
        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] FETCH curEntExt => Sobrepasado Maximo de elementos.", LOG01, lhCodCliente );  
        return "PND";
	}

    sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
    EXEC SQL CLOSE curEntExt ;
    if( sqlca.sqlcode )
    {   
        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] CLOSE curEntExt => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
        return "PND";            
    }

	iAsignado = 0;

	if( lTotalRows > 0 ) 
	{
		if( ( ihPrcAsignado[0] == 100 ) ) 
		{    
			/* transformamos decimales segun definicion para la operadora tratada */
			ifnTrazaHilos( modulo,&pfLog, "Valores antes de transformer stDatosCob.dMtoVencido = [%.4f].", LOG05, stDatosCob.dMtoVencido );  
			stDatosCob.dMtoVencido = fnCnvDouble( stDatosCob.dMtoVencido, 0 );
			ifnTrazaHilos( modulo,&pfLog, "Valores despues de transformer stDatosCob.dMtoVencido = [%.4f].", LOG05, stDatosCob.dMtoVencido );  
			
			rtrim( szhCodAgente[0] );
			rtrim( szhCodEntidad[0] );
		    
		    sprintf( stDatosCob.szCodEntidad, "%s\0", szhCodEntidad[0] );

			if( !bfnInsertaCobExterna( &pfLog, &stDatosCob, szhEntGestCob, CXX ) )
				return "INCOB";

			sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
			EXEC SQL 
			UPDATE CO_MOROSOS
			   SET COD_AGENTE  = :szhCodAgente[0] 
			 WHERE COD_CLIENTE = :lhCodCliente;

			if( sqlca.sqlcode )
			{   
				ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] Agente => [%s] INSERT CO_COBEXTERNA => [%s].", LOG00, lhCodCliente, szhCodAgente[0], sqlca.sqlerrm.sqlerrmc );  
				return "UPMOR";            
			}
			else
			{   
				ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] Agente => [%s] Ok.", LOG03, lhCodCliente, szhCodAgente[0] );
				sprintf( szhCodEntidadAsig, "%s", szhCodEntidad[0] );
				sprintf( szhCodAgenteAsig, "%s", szhCodAgente[0] );
				iAsignado = 1;
			} /* ( ( ihPrcAsignado[0] == 100 ) ) */
		}            
		else /* el primero no tenia el 100% */
		{
			for( i = 0; i < lTotalRows; i++ ) /* procesar cada agente (contar sus morosos) */
			{
				rtrim( szhCodEntidad[i] );

				sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
				EXEC SQL      
				SELECT COUNT( UNIQUE E.NUM_IDENT )   
				  INTO :ihMorososAgente[i]
				  FROM CO_MOROSOS M, CO_COBEXTERNA E
				 WHERE E.COD_ENTIDAD = :szhCodEntidad[i]
				   AND E.COD_ENVIO NOT IN ( :szhLetra_I, :szhLetra_G, :szhLetra_V, :szhLetra_E, :szhLetra_N )
				   AND E.NUM_IDENT = M.NUM_IDENT
				   AND E.COD_TIPIDENT = M.COD_TIPIDENT
				   AND M.COD_COMUNA= :szhCodComuna;

				if( sqlca.sqlcode )
				{   
					ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] Agente => [%s] SELECT COUNT CO_COBEXTERNA => [%s].", LOG00, lhCodCliente, szhCodAgente[i], sqlca.sqlerrm.sqlerrmc );  
					return "SEMOR";
				}

				iMorososComuna += ihMorososAgente[i];      /* Acumula el total de morosos de la comuna */
				iPorcentajeTotal += ihPrcAsignado[i];      /* Suma los porcentajes de cada agente */
			}/* end for i  */

			rtrim( szhCodAgente[i] );

			if( iPorcentajeTotal != 100 )
				ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] LA SUMA DE PORCENTAJES NO DA 100%% [%d].", LOG02, lhCodCliente, iPorcentajeTotal );  

			for( i = 0; i < lTotalRows; i++ ) /* procesar cada agente (elegir cual asignar) */
			{
				rtrim( szhCodAgente[i] );
				rtrim( szhCodEntidad[i] );

				fPorcentajeDefinido = (float) ihPrcAsignado[i];
				fPorcentajeActual = ( iMorososComuna == 0 ) ? 0.0 : (float)( ( 100 * (float)ihMorososAgente[i] ) / (float)iMorososComuna );
				
				ifnTrazaHilos( modulo,&pfLog, "[%d] COD_AGENTE => [%s] fPorcentajeDefinido => [%f] fPorcentajeActual => [%f].",
									  LOG05, i, szhCodAgente[i], fPorcentajeDefinido, fPorcentajeActual );  

				if( fPorcentajeDefinido >= fPorcentajeActual )
				{   
					/* transformamos decimales segun definicion para la operadora tratada */
					ifnTrazaHilos( modulo,&pfLog, "Valores antes de transformer stDatosCob.dMtoVencido = [%.4f].", LOG05, stDatosCob.dMtoVencido );  
					stDatosCob.dMtoVencido = fnCnvDouble( stDatosCob.dMtoVencido, 0 );
					ifnTrazaHilos( modulo,&pfLog, "Valores despues de transformer stDatosCob.dMtoVencido = [%.4f].", LOG05, stDatosCob.dMtoVencido );  

				    sprintf( stDatosCob.szCodEntidad, "%s\0", szhCodEntidad[i] );
		
					if( !bfnInsertaCobExterna( &pfLog, &stDatosCob, szhEntGestCob, CXX ) )
						return "INCOB";

					sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
					EXEC SQL 
					UPDATE CO_MOROSOS
					   SET COD_AGENTE = :szhCodAgente[i] 
					 WHERE COD_CLIENTE = :lhCodCliente;

					if (sqlca.sqlcode)
					{   
						ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] Agente => [%s] UPDATE CO_MOROSOS => [%s].", LOG00, lhCodCliente, szhCodAgente[i], sqlca.sqlerrm.sqlerrmc );  
						return "UPMOR";
					}  
					else
					{   
						ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] Agente => [%s] Ok.", LOG03, lhCodCliente, szhCodAgente[i] );  
						sprintf( szhCodEntidadAsig, "%s", szhCodEntidad[i] );
						sprintf( szhCodAgenteAsig, "%s", szhCodAgente[i] );
						iAsignado = 1;     
					}
					break;
				}
			} /* end for i */
		} 
	}

    if( iAsignado == 0)
    {
        /* 2 situaciones : ( lTotalRows <= 0 ) o nunca se cumplio que (fPorcentajeDefinido >= fPorcentajeActual ) */
        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] NOAGE => No se encontro agente", LOG01, lhCodCliente );  
        return "NOAGE";
    }

	if( !strcmp( szhEntGestCob, szENTIDADCUENTA ) )	/* si la cobranza es a nivel de cuenta */
	{
		/* Se debe actualizar el agente de cobranza a los otros clientes de la cuenta */
		sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
		EXEC SQL 
		DECLARE curClientes CURSOR FOR
		SELECT COD_CLIENTE,
			   COD_AGENTE, 
			   COD_CUENTA
		  FROM CO_MOROSOS
		 WHERE NUM_IDENT = :stDatosCob.szNumIdent
		   AND COD_TIPIDENT = :stDatosCob.szCodTipIdent;
	
	    if( sqlca.sqlcode )
	    {
	        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] DECLARE curClientes => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
	        return "SEMOR";
	    }
	
	    sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
	    EXEC SQL 
	    OPEN curClientes ;
	    
	    if( sqlca.sqlcode )
	    {
	        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] OPEN curClientes => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
	        return "SEMOR";
	    }

		iResp = 0;
	    
	    while( 1 )
	    {
			sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
			EXEC SQL
	        FETCH curClientes
	         INTO :lhCodClienteNew,
	        	  :szhCodAgenteNew,
	        	  :lhCodCuentaNew;
	
	        if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
	        {
		        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] FETCH curClientes => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );
	            iResp = 1;
	            break;
	        }
	        else if( sqlca.sqlcode == SQLNOTFOUND )
	        {
	            ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] FIN CURSOR Clientes.", LOG03, lhCodCliente );
	            iResp = 0;
	            break; /* no mas datos */
	        }
	
	        if( strcmp( szhCodAgenteNew, szhCodAgenteAsig ) ) /* si son != */
	        {
	            sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
	            EXEC SQL
	            UPDATE CO_MOROSOS
				   SET COD_AGENTE = :szhCodAgenteAsig
	             WHERE COD_CLIENTE = :lhCodClienteNew;
	             
	            if( sqlca.sqlcode )
	            {
	                ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] UPDATE CO_MOROSOS => [%s]", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );
	                iResp = 1;
	                break; /* error sql */
	            }

                memset(szCodGestion, 0, sizeof(szCodGestion));
                strcpy(szCodGestion,"007");
                sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
                EXEC SQL SELECT count(*)
                         INTO   :iCountGest
                         FROM CO_GESTION
                         WHERE COD_CLIENTE = :lhCodClienteNew
                         AND   COD_GESTION = :szCodGestion;

                if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
                {
                   ifnTrazaHilos( modulo,&pfLog, "(Cliente:%ld)(COD_GESTION:%s) SELECT count(*) FROM CO_GESTION: %s", LOG00, lhCodClienteNew, szCodGestion, sqlca.sqlerrm.sqlerrmc );
                   return FALSE;
                }

                /* Si no existe el cliente + codigo de gestion se inserta*/
                if (iCountGest == 0)
                {
				   ifnTrazaHilos( modulo,&pfLog, "Datos Insert CO_GESTION.\n"
									"\t\t   lhCodClienteNew         => [%ld],\n"
									"\t\t   lhCodCuentaNew          => [%ld],\n"
									"\t\t   stDatosCob.szCodEntidad => [%s],\n"
									"\t\t   stDatosCob.szNumIdent   => [%s],\n",
									LOG06,
									lhCodClienteNew,
									lhCodCuentaNew,
									stDatosCob.szCodEntidad,
									stDatosCob.szNumIdent );
				   sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
				   EXEC SQL
				   INSERT INTO CO_GESTION
				   (
					   COD_CLIENTE,
					   COD_CUENTA,
					   COD_TIPIDENT,
					   NUM_IDENT,
					   COD_GESTION,
					   FEC_GESTION,
					   OBS_GESTION,
					   NOM_USUARIO 
				   )
				   VALUES
				   (
					   :lhCodClienteNew,
					   :lhCodCuentaNew,
					   :stDatosCob.szCodTipIdent,
					   :stDatosCob.szNumIdent,
					   :szCodGestion,
					   SYSDATE,
					   :szhEjecutivoCob,
					   USER
				   );
	
	               if( sqlca.sqlcode )
	               {
	                   ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] INSERT CO_GESTION => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
	                   iResp = 1; 
	                   break; /* error sql */
	               }
               }
               else
               {
                  /* Si existe el cliente + codigo de gestion se actualiza fecha*/
                  sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
                  EXEC SQL UPDATE CO_GESTION
                           SET    FEC_GESTION = SYSDATE
                           WHERE  COD_CLIENTE = :lhCodClienteNew
                            AND   COD_GESTION = :szCodGestion;

                  if( sqlca.sqlcode != SQLOK )
                  {
                     ifnTrazaHilos( modulo,&pfLog, "(Cliente:%ld) Actualizando CO_GESTION %s.", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );
                     return FALSE;
                  }
               } /* if (iCountGest == 0) */

	        }
	    } /* End While */
	
	    sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
	    EXEC SQL
	    CLOSE curClientes;
	
		if( sqlca.sqlcode )
		{
			ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] FIN CURSOR Clientes.", LOG03, lhCodCliente );  
			iResp = 1; 
		}
	
	    if( iResp == 1 )
	        return "INGES";
	} /* if( !strcmp( szhEntGestCob, szENTIDADCUENTA ) ) */

    ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] Entidad => [%s] OK.", LOG03, lhCodCliente, szhCodEntidadAsig );
    return "OK";
}

/****************************************************************************************************/
/* bfnInsertaCobExterna()   													   					*/
/****************************************************************************************************/
BOOL bfnInsertaCobExterna(FILE **ptArchLog,  TDATOSCOB *stDatosCobros, char *szpEntGestCob, sql_context ctxCont )
/*
	Definicion		:	Inserta un registro en la tabla co_cobexterna
	
	Parametros		:	stDatosCobros		Estructura con los datos a insertar
*/	
{
EXEC SQL BEGIN DECLARE SECTION;
	long	 lhCodCliente   = 0;
	long   lhCodCuenta    = 0;
	char   szhRutStgo     [2];
	char   szhCodEntidad  [6];
	char   szhNumIdent   [21];
	char   szhCodTipIdent [3];
	double dhMtoVencido = 0.0;
	double dhMtoDeuda   = 0.0;
	/* Vbls Bind */
	char   szhLetra_P [2];
	char   szhLetra_A [2];
	char   szhLetra_X [2];
	
	int   ihValor_cero= 0;
	int   ihValor_uno = 1;
	sql_context CXX;
EXEC SQL END DECLARE SECTION;

char modulo[] = "bfnInsertaCobExterna", szEntGestCob[2];
FILE *pfLog=*ptArchLog;
struct sqlca sqlca;

	CXX = ctxCont;
	EXEC SQL CONTEXT USE :CXX;

 	ifnTrazaHilos( modulo,&pfLog, "Ingreso modulo : [%s].", LOG05, modulo );

	memset( szhNumIdent, '\0', sizeof( szhNumIdent ) );
	memset( szhCodTipIdent, '\0', sizeof( szhCodTipIdent ) );
	memset( szhCodEntidad, '\0', sizeof( szhCodEntidad ) );
	memset( szhRutStgo, '\0', sizeof( szhRutStgo ) );
	memset( szEntGestCob, '\0', sizeof( szEntGestCob ) );
	strcpy(szhLetra_P,"P");
	strcpy(szhLetra_A,"A");
	strcpy(szhLetra_X,"X");

	strcpy( szEntGestCob, szpEntGestCob );
	strcpy( szhNumIdent, stDatosCobros->szNumIdent );
	strcpy( szhCodTipIdent, stDatosCobros->szCodTipIdent );
	strcpy( szhCodEntidad, stDatosCobros->szCodEntidad );
	strcpy( szhRutStgo, stDatosCobros->szRutSantiago );
	lhCodCliente = stDatosCobros->lCodCliente;
	dhMtoVencido = stDatosCobros->dMtoVencido;
	dhMtoDeuda = stDatosCobros->dMtoDeuda;

	rtrim( szhNumIdent );
	rtrim( szhCodTipIdent );
	rtrim( szhCodEntidad );
	rtrim( szhRutStgo );

    /* Obtiene el cod_cuenta del cliente en la CO_MOROSOS */
	sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
	EXEC SQL
	SELECT COD_CUENTA
	  INTO :lhCodCuenta
	  FROM CO_MOROSOS
	 WHERE COD_CLIENTE = :lhCodCliente;

    if( sqlca.sqlcode )
    {
        ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] SELECT CUENTA CO_MOROSOS => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
        return FALSE;
    }

	stDatosCobros->lCodCuenta = lhCodCuenta;

	ifnTrazaHilos( modulo,&pfLog, "Valores Insert CO_COBEXTERNA\n"  
						  "\t\t   szhNumIdent    => [%s],\n"
						  "\t\t   szhCodTipIdent => [%s],\n"
						  "\t\t   szhCodEntidad  => [%s],\n"
						  "\t\t   szhRutStgo     => [%s],\n"
						  "\t\t   lhCodCliente   => [%ld],\n"
						  "\t\t   dhMtoVencido   => [%.2f],\n"
						  "\t\t   dhMtoDeuda     => [%.2f],\n"
						  "\t\t   lhCodCuenta    => [%ld],\n",
						  LOG07,
						  szhNumIdent,
						  szhCodTipIdent,
						  szhCodEntidad,
						  szhRutStgo,
						  lhCodCliente,
						  dhMtoVencido,
						  dhMtoDeuda,
						  lhCodCuenta );

	if( !strcmp( szEntGestCob, "R" ) )
		lhCodCliente = 0;
	
	sqlca.sqlcode=0; /* se resetea la vble sql en caso de memoria saturada*/
	EXEC SQL 
	INSERT INTO CO_COBEXTERNA
			  (NUM_IDENT     ,  COD_TIPIDENT  ,	 COD_CLIENTE       ,	 COD_CUENTA,      
				COD_ENTIDAD   ,  TIP_COBRANZA  ,  FEC_INGRESO       ,	 NUM_PROCESO,
				COD_MOVIMIENTO,  FEC_MOVIMIENTO,	 MTO_DEUDA         ,	 MTO_VENCIDO,
				CNT_CLIENTES  ,  COD_ENVIO     ,	 NUM_IDENT_SANTIAGO,	 NOM_USUARIO,
				DIA_PRORROCOM )
	VALUES  (:szhNumIdent  ,  :szhCodTipIdent, :lhCodCliente     ,	 :lhCodCuenta,
		      :szhCodEntidad,  :szhLetra_P    , SYSDATE           ,  :ihValor_cero ,
		      :szhLetra_A   ,  SYSDATE        , :dhMtoDeuda       ,  :dhMtoVencido,
		      :ihValor_uno  ,  :szhLetra_X    , :szhRutStgo       ,  USER,
		      :ihValor_cero );

	if( sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND )
	{   
		ifnTrazaHilos( modulo,&pfLog, "Cliente => [%ld] INSERT CO_COBEXTERNA => [%s].", LOG00, lhCodCliente, sqlca.sqlerrm.sqlerrmc );  
		return FALSE;
	}  

	return TRUE;
} /* bfnInsertaCobExterna */


/******************************************************************************************/
/** Información de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisión                                            : */
/**  %PR% */
/** Autor de la Revisión                                : */
/**  %AUTHOR% */
/** Estado de la Revisión ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creación de la Revisión                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/

