/*=============================================================================
   Nombre         : gen_saldos.pc
   Programa       : Generacion de Archivo de saldos de la cartera de clientes
   Autor          : G.A.C.
   Fecha Creacion : 09 - Mayo - 2005
   Proyecto       : Ecuador
==============================================================================*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pasoc.h>
#include <unistd.h>
#include "gen_saldos.h"

EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
	int   ihDecimal            ;
	char  szHoraIni        [11]; EXEC SQL VAR szHoraIni IS STRING(11);
	char  szhhhmiss        [11];
    char  szFechayyyymmdd  [9] ; EXEC SQL VAR szFechayyyymmdd IS STRING(9);
   	char  szhYYYYMMDD      [9] ;
   	char  szhHH24miss      [11];
   	char  szFechaddmmyyyy  [11]; EXEC SQL VAR szFechaddmmyyyy IS STRING(11);
	char  szhDDMMYYYY      [11];
EXEC SQL END DECLARE SECTION;
int   iDiffSeg = 0;
char  szHoraFin[9];
char  szTmpProc[9];
long  lTotalReg;
char  szFileDat  [128]   ="" ;

Lista_Pasoc pLista_Aux=NULL;
Lista_Pasoc stListaAux=NULL;

char szUsage[] = "\n\tUso : gen_saldos  -u [Usuario]/[Password]\n"
                 "\t                  -l [Nivel de log. Por default es 3]\n\n";
 
int main( int argc, char* argv[] )
{
char modulo[]="main";
	
   	memset (&stConfig,0,sizeof (CONFIGLOCAL));
	memset( szHoraIni, '\0', sizeof( szHoraIni ) );

   	if (argc < 2) {
   		fprintf (stdout,"\n\tFaltan parametros.\n%s",szUsage);
      	fflush  (stdout);
      	exit(1);
   	}

   	/*- Validacion de parametros de entrada -*/
   	memset(&stConfig,0,sizeof(CONFIGLOCAL));
   	if (ifnValidaParametros(argc,argv,&stConfig) != 0)  {
        fprintf (stdout,"\n\tError >> Fallo en la Validacion de Parametros \n");
        fflush  (stdout);

   	} else {

		if (ifnInicio(stConfig) != 0 ) {
		    fprintf (stdout,"\n\tError >> Fallo Archivo de Log (Local al proceso) \n");
		    fflush  (stdout);
		} else {
			fprintf (stdout,"\t Generando Saldos.... \n");
			if (ifnSaldos() != 0) {
		   		vDTrazasLog( modulo, "\tProceso de Generacion de Saldos Finalizado con ERROR.\n\n", LOG03,modulo);
		   		fprintf (stdout,"\n\tError >> Fallo Funcion Principal \n");
		   		fflush  (stdout);
			}
		}

		if( ifnExitSaldos() != 0 ) {
			fprintf (stdout,"\n\tError >> Fallo Funcion de estadistica \n");
			fflush  (stdout);
		}
	}
	
	fprintf(stderr, "\t< FIN DEL PROCESO: GENERACION DE SALDOS DE CLIENTES SCL >\n\n");
	return 0;

}/* Fin main */

/* ============================================================================= */
/* ifnValidaParametros : Realiza la validacion de los Parametros de Entrada      */
/* ============================================================================= */
int ifnValidaParametros( int argc, char *argv[], CONFIGLOCAL *pstLC )
{
char modulo[]="ifnValidaParametros";
/*-- Definicion de variables para controlar la lista de argumentos recibidos ----*/
extern char  *optarg;
extern int  optind, opterr, optopt;
int    iOpt=0;
char   opt[] = ":u:l:";

char szUsuario[61] = "";
char *pszTmp       = "";

/*-- Flags de los valores recibidos ----------------------------------------------*/
int  Userflag=0;
int  Logflag=0;

/*-- Seteo de Valores Iniciales y por defecto -------------------------------------*/
    opterr=0;

    while ( (iOpt = getopt (argc,argv,opt)) != EOF) {
          switch (iOpt) {
                 case 'u':
                   if ( strlen (optarg) )  {
                        strcpy (szUsuario,optarg)  ;
                        stConfig.bOptUsuario = TRUE; 
                   }
                   break;
                 case 'l':
                   if ( strlen (optarg) ) {
                        stConfig.bOptNivelLog = TRUE;
                        stConfig.iNivelLog    = atoi(optarg);
                   }
                   break;   

             }/* fin switch */
    }/* fin While de Opciones */
    if (!stConfig.bOptUsuario) {
         fprintf(stderr,"\n\tError Falta Usuario en Parametros de Entrada: \n%s\n", szUsage);
         return -1;
    } else  {
       if ( (pszTmp=(char *)strstr (szUsuario,"/"))==(char *)NULL) {
             fprintf (stderr,"\n\tFormato Usuario Oracle Incorrecto:\n%s\n", szUsage);
             return -1;
       } else {
          strncpy (stConfig.szUsuario ,szUsuario,pszTmp-szUsuario);
          strcpy  (stConfig.szPassWord, pszTmp+1);
       }
    }


    if( !stConfig.bOptNivelLog )
         stConfig.iNivelLog = iNIVEL_DEF;

    stStatus.LogNivel = stConfig.iNivelLog;
    
    return 0;

} /* ifnValidaParametros */
/* ============================================================================= */

/* ============================================================================= */
/* ifnConexionDB() : Intenta Conectarse a la Base de Datos                       */
/* ============================================================================= */
int ifnConexionDB( CONFIGLOCAL pstLC)
{
char modulo[]="ifnConexionDB";

   	if( !bfnConnectORA( pstLC.szUsuario, pstLC.szPassWord ) )   {
       fprintf (stderr,"\nNo hay conexion a ORACLE \n");
       fflush  (stderr);
       return -1;
    }

    return 0;
}
/* ============================================================================= */

/* ============================================================================= */
/* Funcion : ifnInicio										                     */
/* ============================================================================= */
int ifnInicio (CONFIGLOCAL pstConfig)
{
char modulo[]="ifnInicio";

	if (ifnConexionDB(pstConfig) != 0)   {
		fprintf (stdout,"\n\tError >> Fallo la Conexion a la Base \n");
      fflush  (stdout);
      return -1;
	}

	strcpy(szhYYYYMMDD,"YYYYMMDD");
	strcpy(szhHH24miss,"hh24:mi:ss");
	strcpy(szhDDMMYYYY,"DD-MM-YYYY");

	EXEC SQL EXECUTE
		BEGIN
			:szHoraIni := TO_CHAR(SYSDATE,:szhHH24miss);
        	:szFechayyyymmdd := TO_CHAR(SYSDATE,:szhYYYYMMDD);
			:szFechaddmmyyyy := TO_CHAR(SYSDATE,:szhDDMMYYYY);
		END;
	END-EXEC;

	/*-----------------------------------------------------------------------*/
  	/* Inicializacion de Archivos LOG										 */
	/*-----------------------------------------------------------------------*/
  	if (ifnAbreArchivosLog(0)!=0) return -1;
  	

	vDTrazasLog( modulo, "\n\t***************************************************************"
					 	  "\n\t%s  Generacion de Saldos de Clientes       Hora : %s      "
						  "\n\t***************************************************************\n",LOG03,szhVersion,szHoraIni);	
	vDTrazasError( modulo, "\n\t***************************************************************"
					 	  "\n\t%s  Errores en Generacion de Saldos        Hora : %s      "
						  "\n\t***************************************************************\n",LOG03,szhVersion,szHoraIni);	
	return 0;
}/* fin a ifnInicio */

/*===========================================================================*/
/* Funcion que abre los archivos de log y de error                           */
/*===========================================================================*/
int ifnAbreArchivosLog(int iTipfile)
{
char modulo[]="ifnAbreArchivosLog";
char *pathDir               ;
char szComando  [128]   ="" ;
char szPathLog  [128]   ="" ;
char szFileBanco[60] = "";
   /*-----------------------------------------------------------------------*/
   /* Inicializacion de estructura	de archivo								*/
   /*-----------------------------------------------------------------------*/
	memset(szArchivo,'\0',sizeof(szArchivo));

	sprintf(szArchivo,"gen_saldos");
	pathDir =(char *)malloc(228);
	pathDir =szGetEnv("HOME");

	if (iTipfile == 0) {
		sprintf(szPathLog  ,"%s/LOG/Recaudacion/Gen_saldos/%s",pathDir,szFechayyyymmdd);
		free(pathDir);
		sprintf(szComando,"/usr/bin/mkdir -p %s", szPathLog);
		system (szComando);
	
		sprintf(stStatus.ErrName,"%s/%s.err",szPathLog,szArchivo);
		if((stStatus.ErrFile = fopen(stStatus.ErrName,"a")) == (FILE*)NULL ){
		    fprintf( stderr, "\n<< No pudo crearse el archivo de errores %s >> \n", stStatus.ErrName);
		    return -1;
		}
	
		sprintf(stStatus.LogName,"%s/%s.log",szPathLog,szArchivo);
		if((stStatus.LogFile = fopen(stStatus.LogName,"a")) == (FILE*)NULL ) {
		    fprintf(stderr, "\n<< No pudo crearse el archivo de log %s >>\n", stStatus.LogName);
	    	return -1;
	   }
    
	} else {
		sprintf( szFileBanco, "Saldo_clientes_%s.dat",szFechayyyymmdd);
		sprintf(szPathDat  ,"%s/DAT/Recaudacion/%s",pathDir,szFechayyyymmdd);
		free(pathDir);
		sprintf(szComando,"/usr/bin/mkdir -p %s", szPathDat);
		system (szComando);
	
		sprintf(szFileDat,"%s/%s\0",szPathDat,szFileBanco);
		fprintf( stderr, "\nArchivo de Saldos : %s\n\n\n", szFileDat);
		if( ( FichBancos = fopen( szFileDat,"a" ) ) == (FILE*)NULL )  {
		    vDTrazasError(modulo, "\t\t### Error: No puede abrirse el archivo de saldos\n\n\t [%s]\n", LOG01, szFilePac );
			return -1;
		}
	}
	
   return 0;
}/* ifnAbreArchivosLog */


/* ============================================================================= */
/* Funcion ifnExitSaldos: finaliza proceso    				                     */
/* ============================================================================= */
int ifnExitSaldos (void)
{
char modulo[]="ifnExitSaldos";

	strcpy(szhhhmiss,"HH24:MI:SS");

	/* Datos Fin de Tiempo */
	EXEC SQL EXECUTE
		BEGIN
			:szHoraFin := TO_CHAR(SYSDATE,:szhhhmiss);
		END;
	END-EXEC;

	iDiffSeg = ifnRestaHoras(szHoraIni,szHoraFin,szTmpProc);

   vDTrazasLog(modulo,"\n\t         HORA INICIO  : %s "
                       "\n\t         HORA TERMINO : %s "
                       "\n\t         TIEMPO TOTAL : %s  (%d segs)"
                       "\n\t REGISTROS PROCESADOS : %ld"
                       "\n\t PROMEDIO  x  REGISTRO: %.5f segs "
                       "\n\n",LOG03,szHoraIni,szHoraFin,szTmpProc,iDiffSeg,lTotalReg,(float)((float)iDiffSeg/(float)lTotalReg) );

	vDTrazasLog( modulo, "\tFin del Proceso de Generacion de Saldos.\n\n", LOG03,modulo);
	
	if ( fclose(stStatus.LogFile) != 0 )    {
	    fprintf (stderr,"Error al cerrar archivo de Log\n");
	    fflush  (stderr);
	}

	if ( fclose(stStatus.ErrFile) != 0 )    {
	    fprintf (stderr,"Error al cerrar archivo de Errores\n");
	    fflush  (stderr);
	}
	/* XO-200508240446 Soporte RyC 26-08-2005 capc*/
	if ( fclose(FichBancos) != 0 )    {
	    fprintf (stderr,"Error al cerrar archivo DAT\n");
	    fflush  (stderr);
	}
	

	return 0;
}/* fin a ifnExitSaldos */


/* ============================================================================= */
/* ============================================================================= */
/* Inserta el elemento e en la lista ant */
/* Devuelve -1 si no hay memoria suficiente para la inserción. */
int ifnInsertaPasoc(Lista_Pasoc *ant)
{
	Lista_Pasoc p;
	if ((p=(struct SALDOS *) malloc(sizeof(struct SALDOS))) == NULL)
		return -1;
	p->sig=*ant;
	*ant=p;
	return 0;
}

/* Destruye la lista totalmente, liberando toda la memoria. */
/* Tras esto ES necesario Inicializar la lista para reusarla. */
void vfnBorraListaPasoc(Lista_Pasoc *list)
{
	Lista_Pasoc L = NULL;
	if ((*list) != NULL)
	  L = (*list)->sig;

	while (L != NULL){
	   ifnBorraPasoc(&L);
	}
	free((*list)); /* Liberar la cabecera */
	(*list)=NULL;
}

/* Borra el elemento en la posición pos de la lista ant. */
int ifnBorraPasoc(Lista_Pasoc *ant)
{
	Lista_Pasoc aux ;
	if ((*ant) == NULL)
	   return -1; /* Lista Vacia */
	else{
		/* Borrar elemento apuntado por aux, teniendo un puntero al siguiente */
		aux = (*ant);
		(*ant)=aux->sig;
		free(aux);
		return 0;
	} /* end if */
}
/* ============================================================================= */
/* ============================================================================= */

/* ============================================================================= */
/* Funcion principal que ejecuta llamadas a distintas funciones de seleccion     */
/* ============================================================================= */
int ifnSaldos()
{
char modulo[]="ifnSaldos";
EXEC SQL BEGIN DECLARE SECTION;
	long   lhCod_cliente     ;

	char   szhNum_decimal  [12];
	int    ihValor_cero    = 0 ;
	int    ihValor_uno     = 1 ;
EXEC SQL END DECLARE SECTION;

	vDTrazasLog( modulo, "\n\tEn funcion %s", LOG03,modulo);
	strcpy(szhNum_decimal,"num_decimal");

	EXEC SQL EXECUTE
		BEGIN
			:ihDecimal := GE_PAC_GENERAL.PARAM_GENERAL( :szhNum_decimal );
		END;
	END-EXEC;

	if( SQLCODE!=SQLOK ) 	{
		vDTrazasLog( modulo, "\tGE_PAC_GENERAL.PARAM_GENERAL( 'num_decimal' ) - %s", LOG00,SQLERRM );
		return -1;
	}

	/* Genera lista de trabajo*/
	if (ifnCargaListaQuery()!=0) return -1;
	
	if (lTotalReg > 0 ) {
		/* Abre archivo plano de saldos a generar*/
		if (ifnAbreArchivosLog(1)!=0) return -1;

		stListaAux=pLista_Aux;
     	while (stListaAux!= NULL)  {
			/* Va a poblar el archivo de saldos */
			if (ifnGeneraArchivo()!=0) return -1;

			stListaAux=stListaAux->sig;
		}

		vDTrazasLog( modulo, "\tArchivo de Saldos Generado con %ld registros", LOG03, lTotalReg );
		vDTrazasLog( modulo, "\tFin a funcion %s", LOG03, modulo );
		vDTrazasLog( modulo, "\tDestruyendo lista de trabajo. Liberando memoria...", LOG03);

		if (ifnOrdenaArchivo()!=0) {
			vDTrazasLog( modulo, "\tFallo el Ordenamiento del archivo", LOG03);
		}
		
	} else {
		vDTrazasLog( modulo, "\tNo existen registos para generar Saldos....", LOG03);

	}
	/* Destruye la lista liberando memoria */
	vfnBorraListaPasoc( &pLista_Aux );


	return 0;

}/* Fin ifnSaldos */

/*===========================================================================*/
/* Funcion ifnFormatoUnico : Imprime en archivo plano, con formato Unico     */
/*===========================================================================*/
int ifnGeneraArchivo()
{
char modulo[]="ifnGeneraArchivo";
char szFiller [2]=" ";
double dTot_IvaIce= 0.0;

	/* Inicio RA-200511160113 Soporte RyC 18.11.2005 */
    dTot_IvaIce  = (stListaAux->dValor_Iva) + (stListaAux->dValor_Ice);
	vDTrazasLog( modulo, "\t\t stListaAux->lCod_cliente===>  [%ld]", LOG03,stListaAux->lCod_cliente);			
	vDTrazasLog( modulo, "\t\t stListaAux->dValor_Iva  ===>  [%f]", LOG03,stListaAux->dValor_Iva);			
	vDTrazasLog( modulo, "\t\t stLista_Aux->dValor_Ice ===>  [%f]", LOG03,stListaAux->dValor_Ice);			
    vDTrazasLog( modulo, "\t\t dTot_IvaIce  ===>  [%f]", LOG03,dTot_IvaIce);			
    /* Fin RA-200511160113 Soporte RyC 18.11.2005 */

	if( (fprintf( FichBancos , "%-5s%10s%15s%08ld%-50s%-60s%015ld%21s%11s%1s%02dUSD%09ld%015.04f%015.04f%015.04f%015.04f%015.04f%015.04f%20s%2s\n",
	             			    stListaAux->szCod_Operadora,
	             			    szFechaddmmyyyy,
	             			    stListaAux->szCod_banco,
	             			    stListaAux->lCod_cliente,
	             			    stListaAux->szNom_cliente,
	             			    stListaAux->szDirec_clie,
	             			    stListaAux->lNum_celular,
	             			    stListaAux->szNum_contrato,
	             			    szFiller,
	             			    stListaAux->szInd_pertrib,
	             			    stListaAux->iCod_tipdocum,
	             			    stListaAux->lNum_folio,
	             			    dTot_IvaIce,
	             			    stListaAux->dBase_Imponible,
	             			    stListaAux->dTot_pagar_fa,
	             			    stListaAux->dTot_pagar_ca,
	             			    stListaAux->dValor_Iva   ,
	             			    stListaAux->dValor_Ice   ,
	             			    stListaAux->szNum_Ident  ,
	             			    stListaAux->szCod_Tipident )   ) == -1 )
	{	
		vDTrazasError(modulo,"Error al Escribir en Archivo de Saldos",LOG01);
		vDTrazasLog( modulo, "Error al Escribir en Archivo de Saldos", LOG01);
		return -1; 
	}
	fflush(FichBancos); /* XO-200508240446 Soporte RyC 26-08-2005 capc*/
	return 0;

}/*ifnFormatoUnico*/


/* ============================================================================= */
/* Genera listas enlazadas con clientes rechazados                               */
/* ============================================================================= */
int ifnCargaListaQuery() 
{
char   modulo[]="ifnCargaListaQuery";
long   lRowsCiclo=0, lTotalRows=0,lRowsProcesadas=0;
long   lRowsCicloAbo=0, lTotalRowsAbo=0,lRowsProcesadasAbo=0;/* RA-xxx Soporte R&C 18.11.2005 */

int    iSalir=FALSE;
long   j=0;
long   k=0; /* RA-xxx Soporte R&C 18.11.2005 */
char   szCod_banco	  [16];
char   szInd_pertrib  [2] ;
char   szNom_cliente  [51];
char   szDirec_clie   [61];
char   szOperadora    [6] ;
char   szNum_Ident    [21] ;
char   szCod_Tipident [3] ;
long   lNum_celular   ;
char   szNum_contrato [22];
int    iCod_tipdocum  ;
long   lNum_folio     ;
double dTot_pagar     ;
double dValor_Iva     ;
double dValor_Ice     ;
int    iRet           ;
int    iBuscoAbonados = FALSE;  /* RA-200511160113 Soporte R&C 18.11.2005 */
int    iPaso          = 0;      /* RA-200511160113 Soporte R&C 18.11.2005 */
EXEC SQL BEGIN DECLARE SECTION;
	long   	lhCod_cliente   [MAX_ARRAY];
	double 	dhImporte       [MAX_ARRAY];
   	long	lhNum_celular  	[MAX_ARRAY];											        /* RA-200511160113 Soporte R&C 18.11.2005 */
	char    szhNum_contrato	[MAX_ARRAY][22]; EXEC SQL VAR szhNum_contrato IS STRING(22);	/* RA-200511160113 Soporte R&C 18.11.2005 */
	
	int    	iValorCero = 0;
	int    	iValorUno  = 1;
	int    	iValorTres = 3;
	char   	szFiller     [2];
	char   	szhCartera  [11];
	char   	szhTipDocum [13];
EXEC SQL END DECLARE SECTION;

	vDTrazasLog( modulo, "\n\tEn funcion %s", LOG03,modulo);
	strcpy(szhCartera  ,"CO_CARTERA");
	strcpy(szhTipDocum ,"COD_TIPDOCUM");
	strcpy(szFiller    ," ");

	/************************************************************************/
	/* Toma el Universo de clientes pac rechazados por ciclo                */
	/************************************************************************/
	EXEC SQL DECLARE Cur_SaldosCar CURSOR FOR
   	SELECT NVL(SUM(A.IMPORTE_DEBE - A.IMPORTE_HABER),:iValorCero), A.COD_CLIENTE
   	FROM   CO_CARTERA A
   	WHERE  A.FEC_VENCIMIE < SYSDATE-:iValorUno
   	/*AND    A.COD_PRODUCTO  = :iValorUno RA-200511160113 Soporte RyC 18.11.2005 */
    AND  A.IMPORTE_HABER <= A.IMPORTE_DEBE  /* RA-200511160113 Soporte RyC 18.11.2005 */
	AND  A.IND_FACTURADO = :iValorUno
	AND NOT EXISTS (SELECT :iValorUno 
	                FROM  CO_CODIGOS COD
  		  	        WHERE TO_NUMBER (COD.COD_VALOR) = A.COD_TIPDOCUM 
  			  	    AND   COD.NOM_COLUMNA = :szhTipDocum AND COD.NOM_TABLA = :szhCartera)
	GROUP BY A.COD_CLIENTE;
	
	if( SQLCODE != SQLOK )	{
		iDError(modulo,ERR000,vInsertarIncidencia,"DECLARE Cur_SaldosCar",SQLERRM);
		return -1;
	}

	EXEC SQL OPEN Cur_SaldosCar;
	if( SQLCODE != SQLOK )	{
		iDError(modulo,ERR000,vInsertarIncidencia,"OPEN Cur_SaldosCar",SQLERRM);
		return -1;
	}

	iSalir=FALSE;
	while(!iSalir) {
		EXEC SQL
		FETCH Cur_SaldosCar
		INTO  :dhImporte, 
			  :lhCod_cliente;
		
		if( SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND )  {
			iDError(modulo,ERR000,vInsertarIncidencia,"FETCH Cur_SaldosCar",SQLERRM);
			break;
		}

		if( SQLCODE == SQLNOTFOUND )  {
			iSalir = TRUE;
		}

      	lTotalRows = SQLROWS;
      	lRowsCiclo = ( lTotalRows - lRowsProcesadas );
		vDTrazasLog( modulo, "\tlTotalRows[%ld]", LOG03,lTotalRows);
		vDTrazasLog( modulo, "\tlRowsCiclo[%ld]\n", LOG03,lRowsCiclo);

		/* traspasamos los datos desde el host array a la lista de trabajo */
		for( j = 0; j < lRowsCiclo; j++ )	{

			vDTrazasLog( modulo, "\n\t[%d] ",LOG05, j+1);
			vDTrazasLog( modulo, "\tlCod_cliente  ======>  [%ld]",LOG03, lhCod_cliente[j]);
			/* Selecciona datos de la Fa_histdocu*/
			iRet=ifnDatosFa_Histdocu(lhCod_cliente [j], &iCod_tipdocum , &lNum_folio , &dTot_pagar);

			if (iRet==0) {

				/* Inicio RA-200511160113 Soporte R&C 18.11.2005 */
				iPaso          = 0; 
				lRowsCicloAbo  = 0;
				lTotalRowsAbo  = 0;
                lRowsProcesadasAbo=0;
				k = 0;

				EXEC SQL DECLARE Cur_Abonados CURSOR FOR
   				SELECT 	NVL(A.NUM_CONTRATO,:szFiller) , 
           				NVL(A.NUM_CELULAR ,:iValorCero)
   				FROM   GA_ABOCEL A
    			WHERE  A.COD_CLIENTE   = :lhCod_cliente[j];
    			/*AND   (A.COD_SITUACION = :szhSituacion OR A.FEC_BAJA IS NULL)
    			 AND    A.COD_PRODUCTO  = :iValorUno; RA-200511160113 Soporte RyC 18.11.2005 */
    
				if( SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND )  {
					iDError(modulo,ERR000,vInsertarIncidencia,"DECLARE Cur_Abonados",SQLERRM);
					return -1;
				} /* end if( SQLCODE != SQLOK )	*/

				EXEC SQL OPEN Cur_Abonados;
				if( SQLCODE != SQLOK )	{
					iDError(modulo,ERR000,vInsertarIncidencia,"OPEN Cur_Abonados",SQLERRM);
					return -1;
				} /* end if( SQLCODE != SQLOK ) */

				iBuscoAbonados = FALSE; 
				while(!iBuscoAbonados) {
					EXEC SQL FETCH Cur_Abonados 
						INTO	:szhNum_contrato, :lhNum_celular;
	
					if( SQLCODE == SQLNOTFOUND )  {
						iBuscoAbonados = TRUE;
					}

      				lTotalRowsAbo = SQLROWS;
      				lRowsCicloAbo = ( lTotalRowsAbo - lRowsProcesadasAbo );
					vDTrazasLog( modulo, "\tlTotalRowsAbo[%ld]", LOG03,lTotalRowsAbo);
					vDTrazasLog( modulo, "\tlRowsCicloAbo[%ld]\n", LOG03,lRowsCicloAbo);

					/* traspasamos los datos del abonado */
					for( k = 0; k < lRowsCicloAbo; k++ )	{

						vDTrazasLog( modulo, "\n\t[%d] ",LOG05, k+1);
						vDTrazasLog( modulo, "\t  lhNum_celular ======>  [%ld]",LOG03, lhNum_celular[k]);
 
						if (iPaso == 0) {   /*Solo una vez obtiene los datos del cliente e IVA*/
							/* Selecciona datos de la Ge_clientes*/
							iRet=ifnDatosGe_Clientes(lhCod_cliente [j], szCod_banco, szInd_pertrib, szNom_cliente, szDirec_clie, szOperadora, szNum_Ident,szCod_Tipident );
		
							if (iRet==0) {
								/* Selecciona Valores IVA e ICE de la cartera  */
								iRet=ifnValores_Iva_Ice(lhCod_cliente [j], &dValor_Iva, &dValor_Ice);

							} /* end if (iRet==0) */
							iPaso = 1;
						} /* end if (iPaso == 0)*/				        
								   
						if (iRet==0) {
				   			/* Insertamos un nodo para el codigo de cliente */
				   			if (ifnInsertaPasoc(&pLista_Aux)!=0) {
								vDTrazasLog( modulo, "\tError al Insertar Nodo en pLista_Aux.", LOG00);
				   				return -1;
				   			} /* end if (ifnInsertaPasoc(&pLista_Aux)!=0) */
						}    /* end if (iRet==0) */

						/* Vacía los valores de variables a los campos de la lista */
						pLista_Aux->lCod_cliente   = lhCod_cliente [j];
						pLista_Aux->dTot_pagar_ca  = dhImporte [j];
						pLista_Aux->iCod_tipdocum  = iCod_tipdocum;
						pLista_Aux->lNum_folio     = lNum_folio;
						pLista_Aux->dTot_pagar_fa  = dTot_pagar;
						pLista_Aux->lNum_celular   = lhNum_celular[k];
						pLista_Aux->dValor_Iva     = dValor_Iva;
						pLista_Aux->dValor_Ice     = dValor_Ice;
						pLista_Aux->dBase_Imponible= dhImporte [j]-dValor_Iva-dValor_Ice;
						strcpy(pLista_Aux->szNum_contrato ,szhNum_contrato[k]);
						strcpy(pLista_Aux->szCod_banco	  ,szCod_banco	);
						strcpy(pLista_Aux->szInd_pertrib  ,szInd_pertrib);
						strcpy(pLista_Aux->szNom_cliente  ,szNom_cliente);
						strcpy(pLista_Aux->szDirec_clie   ,szDirec_clie );
						strcpy(pLista_Aux->szCod_Operadora,szOperadora);
						strcpy(pLista_Aux->szNum_Ident    ,szNum_Ident );
						strcpy(pLista_Aux->szCod_Tipident ,szCod_Tipident);
						
						vDTrazasLog( modulo, "\t\t pLista_Aux->lNum_folio      ===>  [%ld]", LOG05,pLista_Aux->lNum_folio);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->szCod_banco     ===>  [%s]", LOG05,pLista_Aux->szCod_banco);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->iCod_tipdocum   ===>  [%d]", LOG06,pLista_Aux->iCod_tipdocum);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->lNum_celular    ===>  [%ld]", LOG06,pLista_Aux->lNum_celular);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->szNum_contrato  ===>  [%s]", LOG07,pLista_Aux->szNum_contrato);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->szInd_pertrib   ===>  [%s]", LOG07,pLista_Aux->szInd_pertrib);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->szNom_cliente   ===>  [%s]", LOG06,pLista_Aux->szNom_cliente);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->szDirec_clie    ===>  [%s]", LOG07,pLista_Aux->szDirec_clie);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->szCod_Operadora ===>  [%s]", LOG07,pLista_Aux->szCod_Operadora);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->dTot_pagar_ca   ===>  [%f]", LOG07,pLista_Aux->dTot_pagar_ca);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->dTot_pagar_fa   ===>  [%f]", LOG07,pLista_Aux->dTot_pagar_fa);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->dValor_Iva      ===>  [%f]", LOG07,pLista_Aux->dValor_Iva);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->dValor_Ice      ===>  [%f]", LOG07,pLista_Aux->dValor_Ice);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->dBase_Imponible ===>  [%f]", LOG07,pLista_Aux->dBase_Imponible);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->szNum_Ident     ===>  [%s]", LOG07,pLista_Aux->szNum_Ident);			
						vDTrazasLog( modulo, "\t\t pLista_Aux->szCod_Tipident  ===>  [%s]\n", LOG07,pLista_Aux->szCod_Tipident);			
				
						lTotalReg++;
						memset(&szhNum_contrato[k],'\0',sizeof(szhNum_contrato[k]));        
						lhNum_celular[k] = 0;

					} /* end for  */

					lRowsProcesadasAbo = lRowsProcesadasAbo + lRowsCicloAbo; 

				} /* fin while cursor Cur_Abonados */

				EXEC SQL CLOSE Cur_Abonados;
				if ( SQLCODE != SQLOK  )  {
					iDError(modulo,ERR000,vInsertarIncidencia,"\t En CLOSE Cur_Abonados.\n\t\t\t\t ",SQLERRM);
					return -1;
				}
				/* Fin RA-200511160113 Soporte R&C 18.11.2005 */

			} /* end if (iRet==0)*/
		} /* end for */

		lRowsProcesadas = lRowsProcesadas + lRowsCiclo; /* Resetea Contador, ya que las filas recuperadas se han procesado */
		if( iSalir )	vDTrazasLog( modulo, "\tAlcanzando Fin de Datos Cur_SaldosCar.\n", LOG03);

	} /* fin while cursor Cur_SaldosCar */

	EXEC SQL
	CLOSE Cur_SaldosCar;
	if( SQLCODE != SQLOK )  {
		iDError(modulo,ERR000,vInsertarIncidencia,"CLOSE Cur_SaldosCar",SQLERRM);
	}
	
	vDTrazasLog( modulo, "\tLista de trabajo cargada con %ld registros\n", LOG03,lTotalReg);
	return 0;
		
} /* end ifnCargaListaQuery */

/*==================================================================================*/
/* Funcion que selecciona los datos necesarios de la Fa_Histdocu  para el archivo   */
/*==================================================================================*/
int ifnDatosFa_Histdocu(long plCod_cliente, int *piCod_tipdocum , long *plNum_folio , double *pdTot_pagar)
{
char modulo[]="ifnDatosFa_Histdocu";
EXEC SQL BEGIN DECLARE SECTION;
	long   lhCod_cliente ;
   	int    ihCod_tipdocum;
   	long   lhNum_folio   ;
   	double dhTot_pagar   ;

	int    iValorCero = 0;
	int    iValorUno  = 1;
EXEC SQL END DECLARE SECTION;

   	vDTrazasLog( modulo, "\tEn funcion [%s]  <====>  Cliente [%ld]", LOG05,modulo,plCod_cliente);
   	lhCod_cliente = plCod_cliente;

	EXEC SQL
   	SELECT UNIQUE NVL(A.COD_TIPDOCUM,:iValorCero)  , 
           NVL(A.NUM_FOLIO,:iValorCero) , 
           NVL(C.TOT_PAGAR,:iValorCero)
   	INTO :ihCod_tipdocum , 
   	  	 :lhNum_folio    , 
   		 :dhTot_pagar   
   	FROM   FA_HISTDOCU A , 
         	(SELECT MAX(FA.FEC_EMISION) AS FEC_EMISION	FROM  FA_HISTDOCU FA
   	    	 WHERE  FA.COD_CLIENTE = :lhCod_cliente
   	    	 AND    FA.COD_TIPDOCUM IN (SELECT COD_TIPDOCUMMOV FROM FA_TIPDOCUMEN WHERE IND_CICLO = :iValorUno)) B,
   	   		(SELECT  SUM(HI.TOT_PAGAR) AS TOT_PAGAR, HI.COD_CLIENTE
   	    	 FROM    FA_HISTDOCU HI  
   	    	 WHERE   HI.COD_CLIENTE = :lhCod_cliente GROUP BY HI.COD_CLIENTE) C
   	WHERE  A.COD_CLIENTE = :lhCod_cliente
   	AND    A.COD_CLIENTE = C.COD_CLIENTE
   	AND    A.FEC_EMISION = B.FEC_EMISION
   	AND    A.COD_TIPDOCUM IN (SELECT COD_TIPDOCUMMOV FROM FA_TIPDOCUMEN WHERE IND_CICLO = :iValorUno);

	if( (SQLCODE != SQLOK ) && (SQLCODE != SQLNOTFOUND))	{
		iDError(modulo,ERR000,vInsertarIncidencia,"Select Fa_Histdocu",SQLERRM);
		return -1;
	}

   	if (SQLCODE == SQLNOTFOUND) {
   		ihCod_tipdocum=0;
   		lhNum_folio =0;
   		dhTot_pagar =0;
	}

   	*piCod_tipdocum=ihCod_tipdocum;
   	*plNum_folio=lhNum_folio;
   	*pdTot_pagar=dhTot_pagar;  

	return 0;
}

/*==================================================================================*/
/* Funcion que selecciona los datos necesarios de la Ga_abocel  para el archivo     */
/*==================================================================================*/
/* Inicio RA-200511160113 Soporte R&C 18.11.2005   NO SE UTILIZA */
/*int ifnDatosGa_Abocel(long plCod_cliente, long *plNum_celular, char *pszNum_contrato)
{
char modulo[]="ifnDatosGa_Abocel";
EXEC SQL BEGIN DECLARE SECTION;
	long   lhCod_cliente       ;
	long   lhNum_celular       ;
	char   szhNum_contrato [22]; EXEC SQL VAR szhNum_contrato IS STRING(22);

	int    iValorCero = 0;
	int    iValorUno  = 1;
	char   szhSituacion[4];
	char   szFiller   [2];
EXEC SQL END DECLARE SECTION;

   	vDTrazasLog( modulo, "\tEn funcion [%s]    <====>  Cliente [%ld]", LOG06,modulo,plCod_cliente);
	strcpy(szhSituacion,"AAA");
	strcpy(szFiller," ");
   	lhCod_cliente = plCod_cliente;

	* Selecciona datos de la Ga_Abocel*
   	EXEC SQL
   	SELECT UNIQUE NVL(A.NUM_CONTRATO,:szFiller) , 
           NVL(A.NUM_CELULAR,:iValorCero)
   	INTO   :szhNum_contrato , 
           :lhNum_celular 
   	FROM   GA_ABOCEL A, (SELECT MAX(GA.FEC_ALTA) AS FEC_ALTA , MAX(NUM_ABONADO) AS NUM_ABONADO
                         FROM GA_ABOCEL GA 
   				         WHERE GA.COD_CLIENTE=:lhCod_cliente 
   				         AND   (GA.COD_SITUACION = :szhSituacion OR GA.FEC_BAJA IS NULL)) B
    WHERE  A.COD_CLIENTE   = :lhCod_cliente
    AND   (A.COD_SITUACION = :szhSituacion OR A.FEC_BAJA IS NULL)
    AND    A.COD_PRODUCTO  = :iValorUno
    AND    A.NUM_ABONADO   = B.NUM_ABONADO
	AND    A.FEC_ALTA      = B.FEC_ALTA;

	if( (SQLCODE != SQLOK ) && (SQLCODE != SQLNOTFOUND))	{
		iDError(modulo,ERR000,vInsertarIncidencia,"Select Ga_Abocel ",SQLERRM);
		return -1;
	}

    if (SQLCODE == SQLNOTFOUND) {
	   lhNum_celular=0;
	   strcpy(szhNum_contrato," ");
   	}

   	*plNum_celular=lhNum_celular;
   	strcpy(pszNum_contrato,szhNum_contrato	);

	return 0;
}*/
/* FIN RA-200511160113 Soporte R&C 18.11.2005   NO SE UTILIZA */
/*==================================================================================*/
/* Funcion que selecciona los datos necesarios de la Ge_clientes  para el archivo   */
/*==================================================================================*/
int ifnDatosGe_Clientes(long plCod_cliente, char *pszCod_banco, char *pszInd_pertrib, char *pszNom_cliente, 
                        char *pszDirec_clie, char *pszOperadora, char *pszNum_Ident , char *pszCod_Tipident)
{
char modulo[]="ifnDatosGe_Clientes";
EXEC SQL BEGIN DECLARE SECTION;
	long   lhCod_cliente       ;
	char   szhCod_banco	  [16] ; EXEC SQL VAR szhCod_banco IS STRING(16); 
	char   szhInd_pertrib  [2] ; EXEC SQL VAR szhInd_pertrib IS STRING(2);
	char   szhNom_cliente  [51]; EXEC SQL VAR szhNom_cliente IS STRING(51);
	char   szhDirec_clie   [61]; EXEC SQL VAR szhDirec_clie IS STRING(61);
	char   szhDireccion   [961]; EXEC SQL VAR szhDireccion IS STRING(961);
	char   szhCod_Operadora[6] ; EXEC SQL VAR szhCod_Operadora IS STRING(6);
	char   szhNum_Ident    [21]; EXEC SQL VAR szhNum_Ident IS STRING(21);
	char   szhCod_Tipident [3] ; EXEC SQL VAR szhCod_Tipident IS STRING(3);

	int    iValorUno  = 1;
	int    iValorTres = 3;
	char   szFiller   [2];
EXEC SQL END DECLARE SECTION;

   	vDTrazasLog( modulo, "\tEn funcion [%s]  <====>  Cliente [%ld]", LOG07,modulo,plCod_cliente);
	strcpy(szFiller," ");
   	lhCod_cliente = plCod_cliente;

   	EXEC SQL
   	SELECT DECODE(A.COD_BANCO, NULL, (DECODE(A.COD_BANCOTARJ, NULL, :szFiller, A.COD_BANCOTARJ)),A.COD_BANCO), 
           NVL(B.IND_PERTRIB,:szFiller) ,
           NVL(A.NOM_CLIENTE,:szFiller)||' '||NVL(A.NOM_APECLIEN1,:szFiller)||' '||NVL(A.NOM_APECLIEN2,:szFiller),
           A.COD_OPERADORA,
           A.NUM_IDENT    ,
           A.COD_TIPIDENT
    INTO   :szhCod_banco	 ,
           :szhInd_pertrib,
           :szhNom_cliente,
           :szhCod_Operadora,
           :szhNum_Ident  ,
           :szhCod_Tipident
   	FROM   GE_CLIENTES A ,GE_TIPIDENT B
   	WHERE  A.COD_CLIENTE = :lhCod_cliente
   	AND    A.COD_TIPIDENT= B.COD_TIPIDENT;
   
   	if( (SQLCODE != SQLOK ) && (SQLCODE != SQLNOTFOUND))	{
		iDError(modulo,ERR000,vInsertarIncidencia,"Select Ge_Clientes",SQLERRM);
      	return -1;
   	}

   	if (SQLCODE == SQLNOTFOUND) {
      	vDTrazasLog( modulo, "\tSelect Ge_Clientes - %s", LOG00,SQLERRM );
      	return 100;
   	}
   
   	EXEC SQL EXECUTE
   		BEGIN
   			:szhDireccion:=GE_FN_OBTIENE_DIRCLIE(:lhCod_cliente,:iValorUno,:iValorTres,:iValorUno);
		END;
	END-EXEC;
   	if (SQLCODE != SQLOK ) 	{
      	strcpy(szhDirec_clie," ");
      	vDTrazasLog( modulo, "\tDireccion no encontrada - %s", LOG02,SQLERRM );
   	} else {
	   	strncpy(szhDirec_clie,&szhDireccion[0],60);
   	}
   
   	strcpy(pszCod_banco,szhCod_banco	);
   	strcpy(pszInd_pertrib,szhInd_pertrib);
   	strcpy(pszNom_cliente,szhNom_cliente);
   	strcpy(pszDirec_clie,szhDirec_clie );
   	strcpy(pszOperadora,szhCod_Operadora);
   	strcpy(pszNum_Ident,szhNum_Ident);
   	strcpy(pszCod_Tipident,szhCod_Tipident);

	return 0;
}

/*==================================================================================*/
/* Funcion que selecciona los datos necesarios de la Ga_abocel  para el archivo     */
/*==================================================================================*/
int ifnValores_Iva_Ice(long plCod_cliente, double *dValor_Iva, double *dValor_Ice)
{
char modulo[]="ifnValores_Iva_Ice";
EXEC SQL BEGIN DECLARE SECTION;
	long   lhCod_cliente   ;
	int    ihCod_Concepto  ;
	double dhValor_concepto;

	int    iCont      = 0;
	int    iValorCero = 0;
	int    iValorUno  = 1;
	char   szhCartera  [11];
	char   szhTipDocum [13];
	char   szhValor_IVA[18];
	char   szhValor_ICE[18];
	char   szhCod_Modulo[3];
EXEC SQL END DECLARE SECTION;

   	vDTrazasLog( modulo, "\tEn funcion [%s]   <====>  Cliente [%ld]", LOG05,modulo,plCod_cliente);
	strcpy(szhCartera	,"CO_CARTERA");
	strcpy(szhTipDocum	,"COD_TIPDOCUM");
	strcpy(szhValor_IVA	,"VALOR_IVA_ECU_COL");
	strcpy(szhValor_ICE	,"VALOR_ICE_ECU_COL");
	strcpy(szhCod_Modulo,"CO");
   	lhCod_cliente = plCod_cliente;

	/* Seleccionamos el parametro para el valor_iva*/
	EXEC SQL
	SELECT UNIQUE VAL_PARAMETRO 
	INTO   :ihCod_Concepto
	FROM   GED_PARAMETROS 
	WHERE  NOM_PARAMETRO = :szhValor_IVA
	AND    COD_MODULO    = :szhCod_Modulo;

	if (SQLCODE == SQLNOTFOUND)	{
		iDError(modulo,ERR000,vInsertarIncidencia,"Parametro [VALOR_IVA_ECU_COL] no esta definido",SQLERRM);
		return -1;
	}
	if (SQLCODE != SQLOK ) {
		iDError(modulo,ERR000,vInsertarIncidencia,"Select Parametro [VALOR_IVA_ECU_COL]",SQLERRM);
		return -1;
	}
	
	iCont=0;
	while (1) {
		/* Selecciona datos de la Co_Cartera*/
	   	EXEC SQL
	   	SELECT NVL(SUM(A.IMPORTE_DEBE - A.IMPORTE_HABER),:iValorCero)
	   	INTO   :dhValor_concepto
	   	FROM   CO_CARTERA A
	   	WHERE  A.COD_CLIENTE   = :lhCod_cliente
	   	AND    A.COD_CONCEPTO  = :ihCod_Concepto
	   	AND    A.FEC_VENCIMIE < SYSDATE-:iValorUno
	   	/* AND    A.COD_PRODUCTO  = :iValorUno RA-200511160113 Soporte RyC 18.11.2005 */
		AND    A.IND_FACTURADO = :iValorUno
		AND NOT EXISTS (SELECT :iValorUno 
		                FROM  CO_CODIGOS COD
	  			  	    WHERE TO_NUMBER (COD.COD_VALOR) = A.COD_TIPDOCUM 
	  			  	    AND   COD.NOM_COLUMNA = :szhTipDocum AND COD.NOM_TABLA = :szhCartera);
	
		if( (SQLCODE != SQLOK ) && (SQLCODE != SQLNOTFOUND))	{
			iDError(modulo,ERR000,vInsertarIncidencia,"Select Valor Iva-Ice ",SQLERRM);
			return -1;
		}
	
	   	if (iCont > 0) break;
	   	*dValor_Iva=dhValor_concepto;
	   	iCont++; /*Se incrementa para salir de bucle*/

		/* Seleccionamos el parametro para el valor_ice*/
		EXEC SQL
		SELECT UNIQUE VAL_PARAMETRO 
		INTO   :ihCod_Concepto
		FROM   GED_PARAMETROS 
		WHERE  NOM_PARAMETRO = :szhValor_ICE
		AND    COD_MODULO    = :szhCod_Modulo;
	
		if (SQLCODE == SQLNOTFOUND)	{
			iDError(modulo,ERR000,vInsertarIncidencia,"Parametro [VALOR_ICE_ECU_COL] no esta definido",SQLERRM);
			return -1;
		}

		if (SQLCODE != SQLOK ) {
			iDError(modulo,ERR000,vInsertarIncidencia,"Select Parametro [VALOR_ICE_ECU_COL]",SQLERRM);
			return -1;
		}
	}
   
   	vDTrazasLog( modulo, "\t\t dValor_Iva [%f]", LOG05,*dValor_Iva);
   	vDTrazasLog( modulo, "\t\t dValor_Ice [%f]", LOG05,*dValor_Ice);
   	*dValor_Ice=dhValor_concepto;

	return 0;
}

/*===========================================================================*/
/* Ordenamiento x banco Archivo Salida		     	 */
/*===========================================================================*/
int ifnOrdenaArchivo(void)
{
char modulo[]="ifnOrdenaArchivo";
char 	szComando      [500]; 
   
   vDTrazasLog(modulo,"\t=> Ordenando Archivo [%s].\n",LOG03,szFileDat);
   memset(&szComando,'\0',sizeof(szComando));
   strcpy(szComando,"sort -o ");
   strcat(szComando,szFileDat);
   strcat(szComando,"-tmp");   /* Salida */
   strcat(szComando," +0.0 -0.31 ");
   strcat(szComando,szFileDat);  /* Entrada */
   vDTrazasLog(modulo,"\t=> 1er Comando a ejecutar [%s].\n",LOG03,szComando);
   system(szComando);

   memset(&szComando,'\0',sizeof(szComando));
   strcpy(szComando,"mv ");
   strcat(szComando,szFileDat);
   strcat(szComando,"-tmp  ");
   strcat(szComando,szFileDat);
   vDTrazasLog(modulo,"\t=> 2do Comando a ejecutar [%s].\n",LOG03,szComando);
   system(szComando);
   return 0;
}

/*===========================================================================*/
/* Funcion RighTrim : Limpia blancos a la derecha                            */
/*===========================================================================*/
int RighTrim (char *szVar)
{
int  iLenVar = 0;
int  i       = 0;

   iLenVar = strlen(szVar);
   for (i=iLenVar-1;i>-1;i--) {
        if (szVar[i]==' ') {
            szVar[i]='\0';
        } else break;
   }
   return (0);        
} /* RighTrim */

/* ============================================================================= */
/* Copia un substr de un char a otro                                             */
/* ============================================================================= */
void Strcpysub(char *str1, int Largo, char *str2)
{
   int i;
   str2[0]='\0';
   for(i=0;i<=Largo-1;str2[i]=str1[i],i++);
   str2[i]='\0';
}

/* ============================================================================= */
/* Lleva una Hora dada a un valor equivalente en segundos                        */
/* ============================================================================= */
int HoraToSegs(char *HoraFmto)
{
  char *Hora,HH[3],MI[3],SS[3];
  int iHH,iMI,iSS;
  Hora=HoraFmto;
  Strcpysub(Hora,2,HH); Hora=Hora+3; /*HH:*/ iHH=atoi(HH); if (iHH<00||iHH>23) return -1;
  Strcpysub(Hora,2,MI); Hora=Hora+3; /*MI:*/ iMI=atoi(MI); if (iMI<00||iMI>59) return -1;
  Strcpysub(Hora,2,SS);              /*SS */ iSS=atoi(SS); if (iSS<00||iSS>59) return -1;
  return (iHH*3600+iMI*60+iSS);
}

/* ============================================================================= */
/* Resta dos string en fmto hora y retorna la diferencia en fmto hora y segundos */
/* ============================================================================= */
int ifnRestaHoras( char *h1, char *h2, char *hh)
{
  int ih1,ih2,ih;
  div_t hmsH,hmsMS;
  if ((ih1=HoraToSegs(h1))<0) return -1;
  if ((ih2=HoraToSegs(h2))<0) return -1;
  ih=(ih2>=ih1)?(ih2-ih1):(((24*3600)-ih1)+ih2); /* restando horas en segundos , considerando cambio de dia */
  hmsH=div(ih,3600);
  hmsMS=div(hmsH.rem,60);
  sprintf(hh,"%02d:%02d:%02d\0",hmsH.quot,hmsMS.quot,hmsMS.rem);
  return ih;
}


/******************************************************************************************/
/** Informaci¢n de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisi¢n                                            : */
/**  %PR% */
/** Autor de la Revisi¢n                                : */
/**  %AUTHOR% */
/** Estado de la Revisi¢n ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creaci¢n de la Revisi¢n                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/
