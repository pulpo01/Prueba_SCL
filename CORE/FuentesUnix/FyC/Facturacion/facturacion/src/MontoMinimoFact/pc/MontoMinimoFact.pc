/*****************************************************************************/
/*  Fichero    : MontoMinimoFact.pc                                          */
/*  Descripcion: Proceso Validación Monto Minimo Facturable                  */
/*****************************************************************************/
#define _MONTOMINIMOFACT_PC_

#include <deftypes.h>
#include <string.h>
#include "MontoMinimoFact.h"

EXEC SQL INCLUDE sqlca;

/*********************************************************************/
/* PROCESO PRINCICPAL : main                                         */
/*********************************************************************/
int main( int  argc, char *argv[])
{
    char        modulo       []="main";
    char        szFecha       [20]= "";
    long        lCiclFact             ;
    char        szNomTabla        [20];
    extern char *optarg               ;
    int         iOpt                  ;
    char        opt []  = "u:l:c:i:f:";
    char        szUsuario    [102]= "";
    char        szFormato     [10]= "";
    char        szaux             [10];    
    char        *psztmp           = "";
    char        *szDirLogs            ;
    char        *szDirDats            ;
    char        szComando   [1024]= "";
    BOOL        bOptUsuario    = FALSE;
    BOOL        bClieIniFlag   = FALSE;   
    BOOL        bClieFinFlag   = FALSE;    
    char        szValParametro [512+1];
    long        lhMontoMinimo         ;

    puts("\n MontoMinimoFact version " __DATE__ " " __TIME__ " TMG\n");

    memset(&stLineaComando,0,sizeof(stLineaComando));
    memset(&stStatus    ,'\0'   ,sizeof(STATUS)); 
    
    stLineaComando.bOptUsuario  = FALSE;
    stLineaComando.bOptCiclo    = FALSE;


    if(argc == 1)
    {
       fprintf (stderr,"\n<< Error : Parámetros insuficientes >>\n%s\n",szUsage);
       return FALSE;
    }


    while( (iOpt = getopt(argc, argv, opt) ) != EOF )
    {
	    switch( iOpt )
	    {
		    case 'u':
			     if( strlen (optarg) )
			     {			     	
				 strcpy(szUsuario, optarg);
				 bOptUsuario = TRUE;
				 fprintf (stdout," -u %s ", szUsuario);			 
			     }
			     break;
		    case 'l':
			     if( strlen (optarg) )
			     {
				 stStatus.LogNivel = (atoi(optarg) > 0)? atoi(optarg):iLOGNIVEL_DEF;
				 fprintf (stdout,"-l %d ", stStatus.LogNivel)     ;
			     }
			     break;
		    case 'c':
			     if( strlen (optarg) )
			     {		 			     
                                 stLineaComando.bOptCiclo = TRUE;
                                 strcpy(szaux,optarg);
                                 stLineaComando.lCodCiclFact = atol(szaux);
                                 fprintf(stdout,"-c %ld ", stLineaComando.lCodCiclFact);
                             }			     			     
			     break;			     
                    case 'i':
                             stLineaComando.lCodClienteIni = atol(optarg);
                             bClieIniFlag = TRUE;
                             break;
                    case 'f':
                             stLineaComando.lCodClienteFin = atol(optarg);
                             bClieFinFlag = TRUE;
                             break; 
                    case '?':
                             fprintf(stdout,"\n\t<< Error: opcion '-%c' es desconocida >>\n%s\n",optopt,szUsage);
                             return (FALSE);
                    case ':':
                             fprintf(stdout,"\n\t<< Error: falta parametro para opcion '-%c' >>\n%s\n",optopt,szUsage);
                             return (FALSE);                             			     
			     
	    } /* Fin Case */
    }/* Fin While */

    /* Validación de Usuario a conectar */
    if( !bOptUsuario )
    {
	 fprintf (stderr, "\n\t# Faltan Parametros de Entrada:\n%s\n", szUsage);
	 return(2);
    }
    else
    {
	 if( (psztmp=(char *)strstr (szUsuario,"/"))==(char *)NULL )
	 {
	      fprintf (stderr,"\n\tUsuario Oracle no Valido\n%s\n",szUsage);
	      return(3);
	 }
	 else
	 {
	      strncpy (stLineaComando.szUser,szUsuario,psztmp-szUsuario);
	      strcpy  (stLineaComando.szPass, psztmp+1)                 ;
	 }
    }

    /* Asignación de Nivel de Log */
    if( stStatus.LogNivel <= 0 )
    {
	stStatus.LogNivel = iLOGNIVEL_DEF     ;
    }

    stLineaComando.iNivLog = stStatus.LogNivel;
    
    /* Rango de Clientes */
    if ((bClieIniFlag==FALSE) && (bClieFinFlag==FALSE))
    {
    	stLineaComando.bRngClientes = FALSE;
    }
    else
    {
        if(((bClieIniFlag==TRUE) && (bClieFinFlag==FALSE)) ||
	   ((bClieIniFlag==FALSE) && (bClieFinFlag==TRUE)))
        {
             fprintf (stderr,"\n\t<< Error : Rango de Clientes no valido, debe indicar Cliente Inicial y Cliente Final >>\n%s\n"
                            , szUsage);
             return (FALSE);
        }
    }

    if((bClieIniFlag==TRUE) && (bClieFinFlag==TRUE))
    {
	 stLineaComando.bRngClientes = TRUE;    
    }        
        
    /* Conexion a ORACLE */
    if( !bfnConnectORA(stLineaComando.szUser,stLineaComando.szPass) )
    {
	 fprintf(stderr, "\n\tUsuario/Passwd Invalido\n");
	 return(1);
    }
    else
    {
	 printf( "\n\t-------------------------------------------------------"
	         "\n\tConectado a ORACLE: Usuario %s Passwd xxxxxxxx "
		 "\n\t-------------------------------------------------------"
		,stLineaComando.szUser);
    }

    /* Carga parametros de la estructura pstParamGener */
    if (!bGetParamDecimales() )
    {
        return FALSE;
    }
	
    /* Carga parametros Generales */
    if( !bGetDatosGener (&stDatosGener, szSysDate) )
    {
	return(FALSE);
    }

    /* Creación de archivo LOG y ERR */
    if( (szDirLogs = szGetEnv("XPFACTUR_LOG")) == (char *)NULL )
    {
	 return(FALSE);
    }

    /* Creación de Directorio en LOG */
    sprintf(stLineaComando.szDirLogs,"%s/MontoMinimoFact/Ciclo/%ld/"
	                                 ,szDirLogs,stLineaComando.lCodCiclFact);
    free(szDirLogs);
    sprintf (szComando, "/usr/bin/mkdir -p %s",stLineaComando.szDirLogs );
    fprintf( stdout, "\n\tCrea Directorio Log  : %s\n", stLineaComando.szDirLogs);
    if( system (szComando) )
    {
	printf( "\n\t***   Fallo mkdir de Directorio Logs : %s \n",szComando);
	return(FALSE);
    }

    /* Creación de Archivo ERR */
    sprintf(stStatus.ErrName, "%sMontoMinimoFact_%s.err",
    stLineaComando.szDirLogs,szSysDate);

    unlink (stStatus.ErrName);

    if( (stStatus.ErrFile = (FILE *)fopen(stStatus.ErrName,"a")) == (FILE*)NULL )
    {
	 fprintf( stderr, "\n ### Error: No puede abrirse el fichero de error %s\n", stStatus.ErrName);
	 return(4);
    }

    sprintf(stStatus.LogName, "%sMontoMinimoFact_%s.log",
    stLineaComando.szDirLogs,szSysDate);

    unlink (stStatus.LogName);

    if( (stStatus.LogFile = (FILE *)fopen(stStatus.LogName,"a")) == (FILE*)NULL )
    {
	 fprintf( stderr, "\n ### Error: No puede abrirse el fichero de log %s\n", stStatus.LogName);
	 return(5);
    }

    vDTrazasLog (modulo, "\n\t\t********************************************************************************************"
	                 "\n\t\t*                 MONTO MINIMO FACTURABLE versión " __DATE__ " " __TIME__ " TMG                 *"
	                 "\n\t\t*               NIVEL DE LOG  %d                                                            *"
	                 "\n\t\t********************************************************************************************"
	               , LOG03,stLineaComando.iNivLog);
    vDTrazasError(modulo,"\n\t\t*******************************************************************************************"
	                 "\n\t\t*                 MONTO MINIMO FACTURABLE versión " __DATE__ " " __TIME__ " TMG                *"
	                 "\n\t\t*               NIVEL DE LOG  %d                                                           *"
	                 "\n\t\t*******************************************************************************************"
	                ,LOG03,stLineaComando.iNivLog);

    lCiclFact = stLineaComando.lCodCiclFact;
    if( !bfnValidaTrazaProc(lCiclFact, iPROC_MONTOMINIMOFACT, iIND_FACT_ENPROCESO) )
    {
        printf("\n\t** Proceso Monto Mínimo Facturable con Error **\n") ;    	
	return(FALSE);
    }
    if( !fnOraCommit() )
    {
        vDTrazasLog  (modulo , "\n\tERROR AL HACER EL COMMIT EN VALIDA TRAZA",LOG03, SQLERRM);
	vDTrazasError(modulo , "\n\tERROR AL HACER EL COMMIT EN VALIDA TRAZA",LOG01, SQLERRM);
	return(FALSE);
    }

    if( !bfnSelectSysDate(szFecha) )
    {
	return(FALSE);
    }
	 
    bfnSelectTrazaProc (lCiclFact, iPROC_MONTOMINIMOFACT, &stTrazaProc);
    bPrintTrazaProc(stTrazaProc);
    
    /***********************************/
    /* Proceso Monto Minimo Facturable */
    /***********************************/
    vDTrazasLog  (modulo , "\n\t** INICIO Proceso Monto Mínimo Facturable **",LOG03);      
    
    /* Recupera parámetro Monto Mínimo Facturable */
    if (!bGetParamMontoMinimo(szValParametro))
    {
    	return (FALSE);
    }    
    lhMontoMinimo = atol(szValParametro);    
    vDTrazasLog  (modulo , "\n\tParámetro Monto Mínimo Facturable : [%ld]",LOG03, lhMontoMinimo);    
    
    if( !bfnProcMontoMinimoFact( lCiclFact, lhMontoMinimo ) )
    {
	 stTrazaProc.iCodEstaProc       = iPROC_EST_ERR ;
	 strcpy(stTrazaProc.szGlsProceso,"Proceso Monto Minimo Fact. Finalizado con Error");
	 printf("\n\t** Proceso Monto Minimo Facturable con Error **\n");
    }
    else
    {
	 stTrazaProc.iCodEstaProc       = iPROC_EST_OK  ;
	 strcpy(stTrazaProc.szGlsProceso,"Proceso Monto Minimo Facturable Terminado OK") ;
	 printf("\n\t** Proceso Monto Minimo Facturable Ok **\n");
    }    

    if( !bfnSelectSysDate(szFecha) )
    {
	printf("\n\t<< Error en Funcion bfnSelectSysDate!!!. >> \n");
	printf("\n\t<< No se Actualizo Traza con Ultimo Proceso de Monto Minimo Facturable. >>\n");
    }
    else
    {
	strcpy(stTrazaProc.szFecTermino,szFecha)      ;
	stTrazaProc.lCodCliente        = 0 ;
	stTrazaProc.lNumAbonado        = 0            ;
	stTrazaProc.lNumRegistros      = 0            ;
	bPrintTrazaProc(stTrazaProc)                  ;
	if( !bfnUpdateTrazaProc(stTrazaProc) )
	{
	    return(FALSE);
	}
    }

    if( !bfnDisconnectORA(0) )
    {
	printf("\n Desconexion de Oracle con Error \n");
    }
    else
    {
	printf("\n Desconexion de Oracle OK\n");
	vDTrazasLog(modulo, "\n\t-------------------------------------------------------"
		            "\n\tDesconectado de ORACLE "
		            "\n\t-------------------------------------------------------\n"
		          , LOG03);
	vDTrazasError(modulo,"\n\t-------------------------------------------------------"
		             "\n\tDesconectado de ORACLE "
		             "\n\t-------------------------------------------------------\n"
		            ,LOG03);
    }

    fclose(stStatus.LogFile);
    fclose(stStatus.ErrFile);

    return(0);
}
/****************************   FIN MAIN    **********************************/

/*****************************************************************************/
/* FUNCION     : bfnProcMontoMinimoFact                                      */
/* DESCRIPCION : Función Principal                                           */
/*****************************************************************************/
BOOL bfnProcMontoMinimoFact (long lCiclFact, long lMontoMinimo)
{
    char szFuncion []= "bfnProcMontoMinimoFact";
    
    EXEC SQL BEGIN DECLARE SECTION;
         long lhCodCiclFact;
         long lhMontoMinimo; 
    EXEC SQL END DECLARE SECTION;    
    
    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);    
    
    lhMontoMinimo = lMontoMinimo;
    lhCodCiclFact = lCiclFact;    
    
    if(!bfnSelectFactDocu( lhCodCiclFact, lhMontoMinimo ))
    {
       return FALSE;
    }
    
    if( !fnOraCommit() )
    {
        vDTrazasLog  ("" , "\n\tERROR AL HACER EL COMMIT ",LOG03, SQLERRM);
		vDTrazasError("" , "\n\tERROR AL HACER EL COMMIT ",LOG01, SQLERRM);
		return(FALSE);
    }
    
    if(!bfnUpdateFactDocuCicloAnt( lhCodCiclFact))
    {
       return FALSE;
    }
    
    return TRUE;
}    

/*****************************************************************************/
/* FUNCION     : bfnSelectFactDocu                                           */
/* DESCRIPCION : Recuperar Datos desde Tabla FA_FACTDOCU....                 */
/*****************************************************************************/
BOOL bfnSelectFactDocu ( long lCodCiclFact, long lMontoMinimo)
{
    char  szFuncion   []="bfnSelectFactDocu";
    char  szTabla1                   [50]="";
    char  szTabla2                   [50]="";
    char  szCadenaSQL              [2500]="";  
    char  szValParametro             [512+1];
    char  szNextFecEmision         [19+1]="";
    long  lNextCodCiclFact                  ;

    EXEC SQL BEGIN DECLARE SECTION;
         long   lhCodCiclFact           ;
         long   lhMontoMinimo           ;          
         long   lhCodConcepto           ;
         long   lhCodTipoDocumento      ;         
         int    ihAplicaAcumNetoGrav    ; /* P-MIX-09003 138632 */
         long   lhCodCliente            ;
         long   lhNumAbonado            ;
         double dhMontoCargo        =0.0; /* P-MIX-09003 138632 */         
         long   lhNextCodCiclFact       ;         
         char   szhNextFecEmision [19+1]; EXEC SQL VAR szhNextFecEmision IS STRING(19+1);
         long   lhCodClienteIni         ;
         long   lhCodClienteFin         ;         
    EXEC SQL END DECLARE SECTION;
                                
    lhCodCiclFact = lCodCiclFact;
    lhMontoMinimo = lMontoMinimo;     

    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);
    
    /* Recupera parámetro Cod. Concepto */
    /*if (!bGetParamCodConcepto(szValParametro))
    {
    	return (FALSE);
    }    
    lhCodConcepto = atol(szValParametro);    */ /* JEM - Se cambia al concepto de origen */
    
    /* Recupera parámetro Cod. Tipo Documento */
    if (!bGetParamTipoDocumento(szValParametro))
    {
    	return (FALSE);
    }    
    lhCodTipoDocumento = atol(szValParametro);  
    
    /* Recupera parámetro Aplica Acum. Neto Grav. */
    if (!bGetParamAplicaAcumNetoGrav(szValParametro))
    {
    	return (FALSE);
    }    
    ihAplicaAcumNetoGrav = atol(szValParametro);      

    sprintf(szTabla1,"FA_FACTDOCU_%ld",stLineaComando.lCodCiclFact);
    sprintf(szTabla2,"FA_FACTCONC_%ld",stLineaComando.lCodCiclFact);
    
    if (stLineaComando.bRngClientes)
    {   
    	/* Con Rango de Clientes */
    	
        lhCodClienteIni = stLineaComando.lCodClienteIni;
        lhCodClienteFin = stLineaComando.lCodClienteFin; 
        
        vDTrazasLog ( szFuncion, "\n\t** Con Rango de Clientes : Cliente Inicial [%ld] **\n"
                                 "  \t**                         Cliente Final   [%ld] **\n"
                               , LOG05
                               , lhCodClienteIni
                               , lhCodClienteFin);           	
   /*
        sprintf(szCadenaSQL, "\t SELECT A.COD_CLIENTE, C.COD_CONCEPTO, C.IMP_FACTURABLE, C.NUM_ABONADO " 
                             "\n\t FROM %s A, FA_CUOTCREDITO B, %s C " 
                             "\n\t WHERE A.TOT_FACTURA   < %ld "
                             "\n\t  AND  A.IMP_SALDOANT  = 0 "
                             "\n\t  AND  A.COD_TIPDOCUM  != %ld "
                             "\n\t  AND  A.COD_CLIENTE   >= %ld "
                             "\n\t  AND  A.COD_CLIENTE   <= %ld "       
                             "\n\t  AND  A.COD_CLIENTE  = B.COD_CLIENTE (+) "     
                             "\n\t  AND  A.COD_CICLFACT = B.COD_CICLFACT (+) "    
                             "\n\t  AND  NVL(B.MTO_CUOTA, 0) = 0 "
							 							 "\n\t  AND  C.COD_TIPCONCE=3 " --INC 181741 JHJ 22-03-2012	se agrego esta condicion	 
                             "\n\t  AND  A.IND_ORDENTOTAL = C.IND_ORDENTOTAL "
                           , szTabla1
                           , szTabla2
                           , lhMontoMinimo
                           , lhCodTipoDocumento
                           , lhCodClienteIni
                           , lhCodClienteFin);
	  */
	  
	  /* PGG - INC. 212971 - SE CAMBIA LA QUERY ORIGINAL POR ESTA - 27-08-2019 */
						sprintf(szCadenaSQL, "\t SELECT C.COD_CLIENTE, A.COD_CONCEPTO, (A.IMP_FACTURABLE + NVL(B.DCTO, 0)) IMPORTE , A.NUM_ABONADO "
										"\n\t FROM %s A, "
										"\n\t (SELECT IND_ORDENTOTAL, NUM_ABONADO, COD_CONCEREL, COLUMNA_REL, NVL(SUM(IMP_FACTURABLE), 0) DCTO FROM %s WHERE COD_TIPCONCE = 2 GROUP BY IND_ORDENTOTAL, NUM_ABONADO, COD_CONCEREL, COLUMNA_REL) B, "
										"\n\t %s C, FA_CUOTCREDITO D "
										"\n\t WHERE C.TOT_FACTURA   < %ld "
										"\n\t AND C.IMP_SALDOANT  = 0 "
										"\n\t AND C.COD_TIPDOCUM  != %ld "
										"\n\t AND C.IND_ORDENTOTAL = A.IND_ORDENTOTAL "
										"\n\t AND A.COD_TIPCONCE = 3 "
										"\n\t AND A.IMP_FACTURABLE <> 0 "
										"\n\t AND C.COD_CLIENTE   >= %ld "
										"\n\t AND C.COD_CLIENTE   <= %ld " 
										"\n\t AND C.COD_CLIENTE  = D.COD_CLIENTE (+) "
										"\n\t AND C.COD_CICLFACT = D.COD_CICLFACT (+) "
										"\n\t AND NVL(D.MTO_CUOTA, 0) = 0 "
										"\n\t AND A.IND_ORDENTOTAL = B.IND_ORDENTOTAL(+) "
										"\n\t AND A.NUM_ABONADO = B.NUM_ABONADO(+) "
										"\n\t AND A.COD_CONCEPTO = B.COD_CONCEREL(+) "
										"\n\t AND A.COLUMNA = B.COLUMNA_REL(+) "
										"\n\t AND A.IMP_FACTURABLE + NVL(B.DCTO, 0) <> 0 "
										, szTabla2
										, szTabla2
										, szTabla1
										, lhMontoMinimo
										, lhCodTipoDocumento
										, lhCodClienteIni
										, lhCodClienteFin);
	  
    }
    else
    {
    	/* Sin Rango de Clientes */
    	 
        vDTrazasLog ( szFuncion, "\n\t** Sin Rango de Clientes **\n"
                            , LOG05);     	
 				/*                             
        sprintf(szCadenaSQL, "\t SELECT A.COD_CLIENTE, C.COD_CONCEPTO, C.IMP_FACTURABLE, C.NUM_ABONADO " 
                             "\n\t FROM %s A, FA_CUOTCREDITO B, %s C " 
                             "\n\t WHERE A.TOT_FACTURA   < %ld "
                             "\n\t  AND  A.IMP_SALDOANT  = 0 "
                             "\n\t  AND  A.COD_TIPDOCUM  != %ld "
                             "\n\t  AND  A.COD_CLIENTE  = B.COD_CLIENTE (+) "     
                             "\n\t  AND  A.COD_CICLFACT = B.COD_CICLFACT (+) "    
                             "\n\t  AND  NVL(B.MTO_CUOTA, 0) = 0 "
							 							 "\n\t  AND  C.COD_TIPCONCE=3 "		-- INC 181741 JHJ 22-03-2012 se agrego esta condicion		 
                             "\n\t  AND  A.IND_ORDENTOTAL = C.IND_ORDENTOTAL "          
                           , szTabla1
                           , szTabla2
                           , lhMontoMinimo
                           , lhCodTipoDocumento); 	
				*/                 
				
				 /* PGG - INC. 212971 - SE CAMBIA LA QUERY ORIGINAL POR ESTA - 27-08-2019 */
						sprintf(szCadenaSQL, "\t SELECT C.COD_CLIENTE, A.COD_CONCEPTO, (A.IMP_FACTURABLE + NVL(B.DCTO, 0)) IMPORTE , A.NUM_ABONADO "
										"\n\t FROM %s A, "
										"\n\t (SELECT IND_ORDENTOTAL, NUM_ABONADO, COD_CONCEREL, COLUMNA_REL, NVL(SUM(IMP_FACTURABLE), 0) DCTO FROM %s WHERE COD_TIPCONCE = 2 GROUP BY IND_ORDENTOTAL, NUM_ABONADO, COD_CONCEREL, COLUMNA_REL) B, "
										"\n\t %s C, FA_CUOTCREDITO D "
										"\n\t WHERE C.TOT_FACTURA   < %ld "
										"\n\t AND C.IMP_SALDOANT  = 0 "
										"\n\t AND C.COD_TIPDOCUM  != %ld "
										"\n\t AND C.IND_ORDENTOTAL = A.IND_ORDENTOTAL "
										"\n\t AND A.COD_TIPCONCE = 3 "
										"\n\t AND A.IMP_FACTURABLE <> 0 "
										"\n\t AND C.COD_CLIENTE  = D.COD_CLIENTE (+) "
										"\n\t AND C.COD_CICLFACT = D.COD_CICLFACT (+) "
										"\n\t AND NVL(D.MTO_CUOTA, 0) = 0 "
										"\n\t AND A.IND_ORDENTOTAL = B.IND_ORDENTOTAL(+) "
										"\n\t AND A.NUM_ABONADO = B.NUM_ABONADO(+) "
										"\n\t AND A.COD_CONCEPTO = B.COD_CONCEREL(+) "
										"\n\t AND A.COLUMNA = B.COLUMNA_REL(+) "
										"\n\t AND A.IMP_FACTURABLE + NVL(B.DCTO, 0) <> 0 "
										, szTabla2
										, szTabla2
										, szTabla1
										, lhMontoMinimo
										, lhCodTipoDocumento);
				          
	}
    
	if (ihAplicaAcumNetoGrav == 1) /* Aplica Acum. Neto Grav. */ /* P-MIX-09003 138632 */
    {
		/* strcat(szCadenaSQL," AND  C.COD_TIPCONCE != 1 ");	*/  /* PGG - INC. 212971 - C.XXX por A.XXX - 02-09-2019 */
		strcat(szCadenaSQL," AND  A.COD_TIPCONCE != 1 ");	        /* PGG - INC. 212971 - C.XXX por A.XXX - 02-09-2019 */
    }
    
    vDTrazasLog( szFuncion,"\n\t=> query curFactDocu (\n%s\n\t)",LOG05,szCadenaSQL);

    EXEC SQL PREPARE sql_Facturas FROM :szCadenaSQL;
    
    if (sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog (szFuncion, "\n\tError en PREPARE sql_Facturas. Error [%d][%s]"
                             ,LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }

    EXEC SQL DECLARE curFactDocu CURSOR FOR sql_Facturas;
    if (sqlca.sqlcode < SQLOK)
    {
        vDTrazasLog (szFuncion, "\n\tError en DECLARE. curFactDocu. Error [%d][%s]"
                             , LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }
        
    vDTrazasLog( szFuncion, "\n\t CiclFact      : [%ld] "
                            "\n\t MontoMinimo   : [%ld] "
                         , LOG05,lhCodCiclFact,lhMontoMinimo);        
    
    /* Recupera Valores proximo Ciclo Facturacion */
    memset(szNextFecEmision,'\0',sizeof(szNextFecEmision));
    memset(szhNextFecEmision,'\0',sizeof(szhNextFecEmision));
    if (!bfnGetProxCiclFact(lhCodCiclFact, &lNextCodCiclFact,szNextFecEmision))
    {
    	return (FALSE);
    }           
    lhNextCodCiclFact = lNextCodCiclFact;    
    strcpy(szhNextFecEmision, szNextFecEmision);
    
    vDTrazasLog  (szFuncion, "\n\t** Ciclo Proceso Clientes **",LOG05);    
    
    EXEC SQL OPEN curFactDocu;
    
    if(SQLCODE == SQLNOTFOUND)
    {
       vDTrazasLog  (szFuncion," ** No Existen Datos en curFactDocu **",LOG01);
       vDTrazasError(szFuncion," ** No Existen Datos en curFactDocu **",LOG01);
       return (FALSE);
    }       
    
    if(sqlca.sqlcode < SQLOK)
    {
        vDTrazasLog ( szFuncion, "\n\tError en OPEN curFactDocu. Error [%i][%s]"
                             , LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }    
    
    while (SQLCODE != SQLNOTFOUND)
    {
    	vDTrazasLog  (szFuncion, "\n\t** Leyendo Cursor curFactDocu **",LOG05);     	
           
        EXEC SQL 
        FETCH curFactDocu
        INTO  :lhCodCliente,
        	  :lhCodConcepto, 
              :dhMontoCargo,
              :lhNumAbonado;  
                
        if(SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
        {
           vDTrazasError(szFuncion, "\t\tError en Fetch de Cursor curFactDocu [%ld]: %s",LOG01, SQLCODE, SQLERRM);        	
           vDTrazasLog  (szFuncion, "\t\tError en Fetch de Cursor curFactDocu [%ld]: %s",LOG01, SQLCODE, SQLERRM);
           return (FALSE);
        }
        else
        {        	        	
			if (SQLCODE != SQLNOTFOUND)
           	{
            	/* Evaluando Total Factura para generar cargo*/
                vDTrazasLog  (szFuncion, "\n\t** PROCESANDO CLIENTE [%ld]**"
                                         "\n\t=> Cod.  Concepto    [%ld]"                                         
                                         "\n\t=> Monto Concepto    [%f]"                                         
                                       , LOG05
                                       , lhCodCliente 
                                       , lhCodConcepto                                      
                                       , dhMontoCargo);
                                       
           	
                if ( dhMontoCargo > 0.0) 
                {
                     vDTrazasLog  (szFuncion, "\n\t\tINSERTANDO CARGO"
                                              "\n\t\tCod. Concepto       [%ld]"
                                              "\n\t\tCod. Cliente        [%ld]"
                                              "\n\t\tNum. Abonado        [%ld]"
                                              "\n\t\tMonto Cargo         [%f]"
                                              "\n\t\tProx. Ciclo Fact.   [%ld]"
                                              "\n\t\tProx. Fecha Emision [%s]"                                                                                                                                                                                    
                                            , LOG05
                                            , lhCodConcepto
                                            , lhCodCliente
                                            , lhNumAbonado
                                            , dhMontoCargo
                                            , lhNextCodCiclFact
                                            , szhNextFecEmision);                	
                                            
                    /* Insertando Cargo en Tabla GE_CARGOS */                                            
                    if (!bfnDBInsertCargo( lhCodConcepto, lhCodCliente, lhNumAbonado, dhMontoCargo,  
           	                       lhNextCodCiclFact, szhNextFecEmision))
	           	    {
	           	        return FALSE;
	           	    }
           		}else{
           	    	vDTrazasLog  (szFuncion, "\n\t*** No se genera cargo por Monto Cargo <= 0 ***", LOG03);
           		}
           	
                vDTrazasLog  (szFuncion, "\n\t\tACTUALIZANDO DOCUMENTO"
                                         "\n\t\tCod. Ciclo Fact     [%ld]"
                                         "\n\t\tCod. Cliente        [%ld]"
                                         "\n\t\tCod. Tipo Documento [%ld]"
                                       , LOG05
                                       , lhCodCiclFact
                                       , lhCodCliente
                                       , lhCodTipoDocumento);         	
	           	if (!bfnUpdateFactDocu(lhCodCiclFact, lhCodCliente, lhCodTipoDocumento))
	           	{
	           	     return FALSE;
	           	}           	           	           	           	           	           	           	           	
           }
        }                                 	
    } /* Fin WHILE */
    
    EXEC SQL CLOSE curFactDocu;
    
    if(SQLCODE != SQLOK)
    {
       vDTrazasError(szFuncion,"\t\tError al cerrar el Cursor curFactDocu [%ld]: %s",LOG01, SQLCODE, SQLERRM);
       vDTrazasLog  (szFuncion,"\t\tError al cerrar el Cursor curFactDocu [%ld]: %s",LOG01, SQLCODE, SQLERRM);       
       return FALSE;
    }    
    
    return (TRUE);

}/**************************** Final bfnSelectFactDocu ****************************/

/*******************************************************************************/
/* FUNCION     : bfnUpdateFactDocu                                             */
/* DESCRIPCION : Actualiza Tabla FA_FACTDOCU de acuerdo a Ciclo que se procesa */
/*******************************************************************************/
BOOL bfnUpdateFactDocu( long  lCodCiclFact, long lCodCliente, long lCodTipoDocumento)
{
    char szFuncion []= "bfnUpdateFactDocu";
    char  szTabla                  [50]="";
    char  szCadenaSQL            [2500]="";       
    
    EXEC SQL BEGIN DECLARE SECTION;
         long  lhCodCiclFact     ;
         long  lhCodCliente      ;         
         long  lhCodTipoDocumento;                  
    EXEC SQL END DECLARE SECTION;    
    	
    lhCodCiclFact      = lCodCiclFact;
    lhCodCliente       = lCodCliente;
    lhCodTipoDocumento = lCodTipoDocumento;
    
    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);
    
    sprintf(szTabla,"FA_FACTDOCU_%ld",stLineaComando.lCodCiclFact);    
    
    vDTrazasLog( szFuncion , "\n\t**  Valores UPDATE %s **"
                                 "\n\t\t=> Tipo Documento [%ld]"
                                 "\n\t\t=> Ind. Impresa   [1] "
                                 "\n\t\t=> Ind. PasoCobro [1] "                                 
                                 "\n\t\t=> Ind. LibroIva  [1] "                                 
                               , LOG05, szTabla, lhCodTipoDocumento);    
    
    sprintf(szCadenaSQL, "\t UPDATE %s "
                         "\t SET COD_TIPDOCUM  = %ld, "
                         "\t     IND_IMPRESA   = 1, "
                         "\t     IND_PASOCOBRO = 1, "
                         "\t     IND_LIBROIVA  = 1  "                         
                         "\n\tWHERE COD_CLIENTE = %ld "
                       , szTabla
                       , lhCodTipoDocumento
                       , lhCodCliente); 
                       
    EXEC SQL PREPARE sql_update_dinamica FROM :szCadenaSQL;
    
    if (SQLCODE)
    {
	vDTrazasError(szFuncion, "\n\tError PREPARE sql_update_dinamica Tabla [%s] [%s]"
	                       , LOG01, szTabla, SQLERRM);
	vDTrazasLog  (szFuncion, "\n\tError PREPARE sql_update_dinamica Tabla [%s] [%s]"
	                       , LOG01, szTabla, SQLERRM);
	return FALSE;
    }    
    
    EXEC SQL EXECUTE sql_update_dinamica;    
                       
    if ( SQLCODE != SQLOK)
    {
        vDTrazasLog( szFuncion , "\n\t**  Error UPDATE %s **"
                                 "\n\t\t=> Error : [%d]  [%s] "
                               , LOG01, szTabla, SQLCODE, SQLERRM);
        vDTrazasError( szFuncion , "\n\t**  Error UPDATE %s **"
                                   "\n\t\t=> Error : [%d]  [%s] "
                                 , LOG01, szTabla, SQLCODE, SQLERRM);
        return FALSE;
    }  
    	
    return TRUE;
}

/*****************************************************************************/
/* FUNCION     : bfnUpdateFactDocuCicloAnt                                           */
/* DESCRIPCION : Actualiza FA_FACTDOCU....                 */
/*****************************************************************************/
BOOL bfnUpdateFactDocuCicloAnt ( long lCodCiclFact)
{
    char  szFuncion   []="bfnUpdateFactDocuCicloAnt";
    char  szTabla                   [50]="";
    char  szTabla2                  [50]=""; /* PGG -  INC 214112 - 31-03-2021 */
    
    char  szCadenaSQL              [2500]="";  
    char  szValParametro             [512+1];

    EXEC SQL BEGIN DECLARE SECTION;
         long   lhCodCiclFact           ;
         long   lhCodConcepto           ;
         long   lhCodTipoDocumento      ;         
         long   lhCodCliente            ;
         long   lhNumAbonado            ;
         long   lhCodCiclFactAnt        ;         
         long   lhCodClienteIni         ;
         long   lhCodClienteFin         ;
         double dhImpFacturable         ;
         char   szhCodPlanTarif      [4];EXEC SQL VAR szhCodPlanTarif IS STRING(4);
         char   szhTipPlanTarif      [2];EXEC SQL VAR szhTipPlanTarif IS STRING(2);
         char   szhCodCargoBasico    [4];EXEC SQL VAR szhCodCargoBasico IS STRING(4);
    EXEC SQL END DECLARE SECTION;
                                
    lhCodCiclFact = lCodCiclFact;

    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);
    
    
    /* Recupera parámetro Cod. Tipo Documento */
    if (!bGetParamTipoDocumento(szValParametro))
    {
    	return (FALSE);
    }    
    lhCodTipoDocumento = atol(szValParametro);  
/*    
    EXEC SQL
    SELECT MAX(COD_CICLFACT) 
	INTO :lhCodCiclFactAnt
    FROM   FA_CICLFACT 
    WHERE  COD_CICLO = (SELECT COD_CICLO FROM FA_CICLFACT 
    					WHERE  COD_CICLFACT = :lhCodCiclFact)
	AND    FEC_EMISION < (SELECT FEC_EMISION FROM FA_CICLFACT 
    					  WHERE COD_CICLFACT = :lhCodCiclFact);
*/ /* PGG - 181741 - Nuevo Problema reportado en la misma incidencia  */
		EXEC SQL
		SELECT MAX(COD_CICLFACT)
		INTO :lhCodCiclFactAnt
		FROM FA_CICLFACT 
		WHERE FEC_EMISION = ( SELECT MAX(FEC_EMISION)
		FROM  FA_CICLFACT 
		WHERE COD_CICLO = (SELECT COD_CICLO FROM FA_CICLFACT 
		WHERE COD_CICLFACT = :lhCodCiclFact)
		AND   FEC_EMISION < (SELECT FEC_EMISION FROM FA_CICLFACT 
		WHERE COD_CICLFACT = :lhCodCiclFact));

    					  
    if (SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
    {
        vDTrazasLog( szFuncion , "\n\t**  Error SELECT FA_CICLFACT **"
                                 "\n\t\t=> Error : [%d]  [%s] "
                               , LOG01,SQLCODE,SQLERRM);
        vDTrazasError( szFuncion , "\n\t**  Error SELECT FA_CICLFACT **"
                                   "\n\t\t=> Error : [%d]  [%s] "
                                 , LOG01,SQLCODE,SQLERRM);
        return FALSE;
    }    					  

    
    if (stLineaComando.bRngClientes)
    {   
    	/* Con Rango de Clientes */
    	
        lhCodClienteIni = stLineaComando.lCodClienteIni;
        lhCodClienteFin = stLineaComando.lCodClienteFin; 
        
        vDTrazasLog ( szFuncion, "\n\t** Con Rango de Clientes : Cliente Inicial [%ld] **\n"
                                 "  \t**                         Cliente Final   [%ld] **\n"
                               , LOG05
                               , lhCodClienteIni
                               , lhCodClienteFin);           	
 
        /* sprintf(szCadenaSQL, "\t SELECT A.COD_CLIENTE, B.COD_PLANTARIF, B.COD_CONCEPTO, B.COD_CARGOBASICO, B.NUM_ABONADO, B.TIP_PLANTARIF, B.IMP_FACTURABLE " */ /* PGG  - INC 213416 - 13-04-2019 - SE COMENTA */
        sprintf(szCadenaSQL, "\t SELECT A.COD_CLIENTE, NVL(B.COD_PLANTARIF,'X'), B.COD_CONCEPTO, NVL(B.COD_CARGOBASICO,'X'), B.NUM_ABONADO, NVL(B.TIP_PLANTARIF,'I'), B.IMP_FACTURABLE " /* PGG  - INC 213416 - 13-04-2019 - SE AGREGAN NVL */
                             "\n\t FROM FA_HISTDOCU A, FA_HISTCONC_%ld B " 
                             "\n\t WHERE A.COD_TIPDOCUM = %ld "
                             "\n\t  AND  A.COD_CICLFACT = %ld "
                             "\n\t  AND  A.COD_CLIENTE   >= %ld "
                             "\n\t  AND  A.COD_CLIENTE   <= %ld "       
                             "\n\t  AND  A.IND_ORDENTOTAL = B.IND_ORDENTOTAL "
                             "\n\t  AND  B.COD_CONCEPTO   = 1 "
                             "\n\t  AND  B.COD_TIPCONCE  != 1 "
                             "\n\t  AND  B.IMP_FACTURABLE > 0 "
                           , lhCodCiclFactAnt
                           , lhCodTipoDocumento
                           , lhCodCiclFactAnt
                           , lhCodClienteIni
                           , lhCodClienteFin);
    }
    else
    {
    	/* Sin Rango de Clientes */
    	 
        vDTrazasLog ( szFuncion, "\n\t** Sin Rango de Clientes **\n"
                            , LOG05);     	
                            
        /* sprintf(szCadenaSQL, "\t SELECT A.COD_CLIENTE, B.COD_PLANTARIF, B.COD_CONCEPTO, B.COD_CARGOBASICO, B.NUM_ABONADO, B.TIP_PLANTARIF, B.IMP_FACTURABLE  " */ /* PGG  - INC 213416 - 13-04-2019 - SE COMENTA */
        sprintf(szCadenaSQL, "\t SELECT A.COD_CLIENTE, NVL(B.COD_PLANTARIF,'X'), B.COD_CONCEPTO, NVL(B.COD_CARGOBASICO,'X'), B.NUM_ABONADO, NVL(B.TIP_PLANTARIF,'I'), B.IMP_FACTURABLE  " /* PGG  - INC 213416 - 13-04-2019 - SE AGREGAN NVL */
                             "\n\t FROM FA_HISTDOCU A, FA_HISTCONC_%ld B " 
                             "\n\t WHERE A.COD_TIPDOCUM   = %ld "
                             "\n\t  AND  A.COD_CICLFACT   = %ld "
                             "\n\t  AND  A.IND_ORDENTOTAL = B.IND_ORDENTOTAL "
                             "\n\t  AND  B.COD_CONCEPTO   = 1 "
                             "\n\t  AND  B.COD_TIPCONCE  != 1 "
                             "\n\t  AND  B.IMP_FACTURABLE > 0 "      
                           , lhCodCiclFactAnt
                           , lhCodTipoDocumento
                           , lhCodCiclFactAnt);
	}
    
    
    vDTrazasLog( szFuncion,"\n\t=> query curFactHistDocu (\n%s\n\t)",LOG05,szCadenaSQL);

    EXEC SQL PREPARE sql_HistFacturas FROM :szCadenaSQL;
    
    if (sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog (szFuncion, "\n\tError en PREPARE sql_HistFacturas. Error [%d][%s]"
                             ,LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }

    EXEC SQL DECLARE curHistFactDocu CURSOR FOR sql_HistFacturas;
    if (sqlca.sqlcode < SQLOK)
    {
        vDTrazasLog (szFuncion, "\n\tError en DECLARE. curHistFactDocu. Error [%d][%s]"
                             , LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }
        
    EXEC SQL OPEN curHistFactDocu;
    
    if(SQLCODE == SQLNOTFOUND)
    {
       vDTrazasLog  (szFuncion," ** No Existen Datos en curHistFactDocu **",LOG01);
       vDTrazasError(szFuncion," ** No Existen Datos en curHistFactDocu **",LOG01);
       return (FALSE);
    }       
    
    if(sqlca.sqlcode < SQLOK)
    {
        vDTrazasLog ( szFuncion, "\n\tError en OPEN curHistFactDocu. Error [%i][%s]"
                             , LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }    
    
    while (1)
    {
    	vDTrazasLog  (szFuncion, "\n\t** Leyendo Cursor curHistFactDocu **",LOG05);     	
           
        EXEC SQL 
        FETCH curHistFactDocu
        INTO  :lhCodCliente,
        	  :szhCodPlanTarif,
        	  :lhCodConcepto,
        	  :szhCodCargoBasico,
        	  :lhNumAbonado,
        	  :szhTipPlanTarif,
        	  :dhImpFacturable; 
        	  
        if (SQLCODE == SQLNOTFOUND)
        	break;
                
        if(SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
        {
           vDTrazasError(szFuncion, "\t\tError en Fetch de Cursor curHistFactDocu [%ld]: %s",LOG01, SQLCODE, SQLERRM);        	
           vDTrazasLog  (szFuncion, "\t\tError en Fetch de Cursor curHistFactDocu [%ld]: %s",LOG01, SQLCODE, SQLERRM);
           return (FALSE);
        }
                	        	
       vDTrazasLog  (szFuncion, "\n\t\tACTUALIZANDO DOCUMENTO"
                                 "\n\t\tCod. Ciclo Fact     [%ld]"
                                 "\n\t\tCod. Cliente        [%ld]"
                                 "\n\t\tNum. Abonado        [%ld]"
                                 "\n\t\tCod. Plan Tarif.    [%s]"
                                 "\n\t\tTip. Plan Tarif.    [%s]"
                                 "\n\t\tCod. Cargo Basico   [%s]"
                                 "\n\t\tCod. Concepto       [%ld]"
                                 "\n\t\tImp. Facturable     [%f]"
                               , LOG05
                               , lhCodCiclFact
                               , lhCodCliente
                               , lhNumAbonado
                               , szhCodPlanTarif
                               , szhTipPlanTarif
                               , szhCodCargoBasico
                               , lhCodConcepto
                               , dhImpFacturable);    
                               

	    sprintf(szTabla,"FA_FACTCONC_%ld",stLineaComando.lCodCiclFact);
	    sprintf(szTabla2,"FA_FACTABON_%ld",stLineaComando.lCodCiclFact); /* PGG -  INC 214112 - 31-03-2021 */
	    
	    sprintf(szCadenaSQL, " UPDATE %s "
	                         " SET COD_PLANTARIF     = :szhCodPlanTarif ,"
	                         "     COD_CARGOBASICO   = :szhCodCargoBasico ,"
	                         "     TIP_PLANTARIF     = :szhTipPlanTarif "
	                         " WHERE IND_ORDENTOTAL  = (SELECT IND_ORDENTOTAL FROM %s WHERE NUM_ABONADO = %ld AND ROWNUM < 2) " /* PGG -  INC 214112 - 31-03-2021 */
	                         "   AND NUM_ABONADO     = %ld "  /* PGG -  INC 214112 - 12-04-2021 SE AGREGA EL  AND   */
	                         "   AND COD_CONCEPTO    = %ld "
	                         "   AND COD_PLANTARIF   IS NULL "
	                         "   AND COD_CARGOBASICO IS NULL "
	                         "   AND IMP_FACTURABLE  = :dhImpFacturable "
	                         "   AND ROWNUM < 2 "
	                       , szTabla
	                       , szTabla2 /* PGG -  INC 214112 - 31-03-2021 */
	                       , lhNumAbonado
	                       , lhNumAbonado /* PGG -  INC 214112 - 31-03-2021 */
	                       , lhCodConcepto); 
	                       
	    vDTrazasLog( szFuncion,"\n\t=> Update curFactHistDocu (\n%s\n\t)",LOG05,szCadenaSQL);
	    
	    EXEC SQL PREPARE sql_update_dinamica FROM :szCadenaSQL;
	    
	    if (SQLCODE)
	    {
		vDTrazasError(szFuncion, "\n\tError PREPARE sql_update_dinamica Tabla [%s] [%s]"
		                       , LOG01, szTabla, SQLERRM);
		vDTrazasLog  (szFuncion, "\n\tError PREPARE sql_update_dinamica Tabla [%s] [%s]"
		                       , LOG01, szTabla, SQLERRM);
		return FALSE;
	    }    
	    

/* PGG  - INC 213416 - 13-04-2019 - SE agrega IF desde aqui */
	    
	    if ( (strcmp(szhCodPlanTarif, "X")==0 ) || (strcmp(szhCodCargoBasico, "X")==0 ))
	    {
	        vDTrazasLog( szFuncion , "\n\t** No realiza UPDATE con valores NULL... Siguiente registro ... \n" , LOG01);
	    }  
	    else
	    {
	       	EXEC SQL EXECUTE sql_update_dinamica USING :szhCodPlanTarif, :szhCodCargoBasico, :szhTipPlanTarif, :dhImpFacturable; 
	                     
					/*if ( SQLCODE != SQLOK) */ /* PGG - INC. 212971 - se cambia condiciones para no finalizar proceso ante NOT FOUND - 02-09-2019 */
					if (SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK) /* PGG - INC. 212971 - se cambia condiciones para no finalizar proceso ante NOT FOUND - 02-09-2019 */
					{
					  vDTrazasLog( szFuncion , "\n\t**  Error UPDATE %s **"
					                           "\n\t\t=> Error : [%d]  [%s] "
					                         , LOG01, szTabla, SQLCODE, SQLERRM);
					  vDTrazasError( szFuncion , "\n\t**  Error UPDATE %s **"
					                             "\n\t\t=> Error : [%d]  [%s] "
					                           , LOG01, szTabla, SQLCODE, SQLERRM);
					  return FALSE;
					}                                              	
      } 

/* PGG  - INC 213416 - 13-04-2019 - SE agrega IF hasta aqui */      
	        	           	           	           	           	           	           	           	
    } /* Fin WHILE */
    
    EXEC SQL CLOSE curHistFactDocu;
    
    if(SQLCODE != SQLOK)
    {
       vDTrazasError(szFuncion,"\t\tError al cerrar el Cursor curHistFactDocu [%ld]: %s",LOG01, SQLCODE, SQLERRM);
       vDTrazasLog  (szFuncion,"\t\tError al cerrar el Cursor curHistFactDocu [%ld]: %s",LOG01, SQLCODE, SQLERRM);       
       return FALSE;
    }    
    
    return (TRUE);

}/**************************** Final bfnUpdateFactDocuCicloAnt ****************************/

/*****************************************************************************/
/* FUNCION     : bfnGetProxCiclFact                                          */
/* DESCRIPCION : Recuperar Valores Proximo Ciclo Facturación y Fecha Emision */
/*****************************************************************************/
BOOL bfnGetProxCiclFact(long lCodCiclFact, long *lNextCiclFact, char *szNextFecEmision)
{
    char szFuncion []= "bfnGetProxCiclFact";
    
    EXEC SQL BEGIN DECLARE SECTION;
         long  lhCodCiclFact;
         long  lhNextCodCiclFact;         
         char  szhNextFecEmision [19+1]; EXEC SQL VAR szhNextFecEmision IS STRING(19+1);
    EXEC SQL END DECLARE SECTION;    

    memset(szhNextFecEmision,'\0',sizeof(szhNextFecEmision));
    lhCodCiclFact = lCodCiclFact;

    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);
    
    EXEC SQL
         SELECT TO_CHAR(MIN(FEC_EMISION),'DD-MM-YYYY HH24:MI:SS'), COD_CICLFACT 
         INTO   :szhNextFecEmision,:lhNextCodCiclFact
         FROM   FA_CICLFACT 
         WHERE  COD_CICLO = (SELECT COD_CICLO FROM FA_CICLFACT 
                             WHERE  COD_CICLFACT = :lhCodCiclFact)
         AND    FEC_EMISION > (SELECT FEC_EMISION FROM FA_CICLFACT 
                               WHERE COD_CICLFACT = :lhCodCiclFact)
         AND    ROWNUM = 1                     
         GROUP BY COD_CICLFACT;    
    
    
    if (SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
    {
        vDTrazasLog( szFuncion , "\n\t**  Error SELECT FA_CICLFACT **"
                                 "\n\t\t=> Error : [%d]  [%s] "
                               , LOG01,SQLCODE,SQLERRM);
        vDTrazasError( szFuncion , "\n\t**  Error SELECT FA_CICLFACT **"
                                   "\n\t\t=> Error : [%d]  [%s] "
                                 , LOG01,SQLCODE,SQLERRM);
        return FALSE;
    }
        
    *lNextCiclFact = lhNextCodCiclFact;    
    strcpy(szNextFecEmision,szhNextFecEmision);
    
    vDTrazasLog(szFuncion,"\n\tSiguiente Ciclo Facturacion : [%ld] ",LOG04,*lNextCiclFact);
    vDTrazasLog(szFuncion,"\n\t          Fecha Emision     : [%s] ",LOG04,szNextFecEmision);        
    
    return TRUE;
}

/*****************************************************************************/
/* FUNCION     : bGetParamTipoDocumento                                      */
/* DESCRIPCION : Recuperar parámetro Tipo Documento (673) desde              */
/*               Tabla FAD_PARAMETROS                                        */
/*****************************************************************************/
BOOL bGetParamTipoDocumento (char *szValor)
{
    char szFuncion []= "bGetParamTipoDocumento";
    
    EXEC SQL BEGIN DECLARE SECTION;
         char szhValorParametro[512+1]; EXEC SQL VAR szhValorParametro   IS STRING(512+1);
    EXEC SQL END DECLARE SECTION;

    char szTipParametro [32+1] ="";
    char szValParametro [512+1]="";
    int  iRes;

    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);

    /* Obtencion Valor Tipo Documento */
    iRes = ifnGetParametro(673,szTipParametro,szhValorParametro ) ;

    if (iRes != SQLNOTFOUND)
    {
        if (iRes != SQLOK)
        {
            vDTrazasLog(szFuncion, "\n\t** ERROR, al recuperar parámetro de TIPO DOCUMENTO 673 error [%d] **"
                                 , LOG01
                                 , iRes);
            return (FALSE);
        }
        strcpy(szValor,szhValorParametro);
    }
    else
    {
        vDTrazasLog (szFuncion,"\n\t\t=> ADVETENCIA, No existe parámetro 673 TIPO DOCUMENTO",LOG03);
        return (FALSE);
    }

    return (TRUE);
} /************************* FIN bGetParamTipoDocumento ************************/

/*****************************************************************************/
/* FUNCION     : bGetParamMontoMinimo                                        */
/* DESCRIPCION : Recuperar parámetro Monto Mínimo Facturable (671) desde     */
/*               Tabla FAD_PARAMETROS                                        */
/*****************************************************************************/
BOOL bGetParamMontoMinimo (char *szValor)
{
    char szFuncion []= "bGetParamMontoMinimo";
    
    EXEC SQL BEGIN DECLARE SECTION;
         char szhValorParametro[512+1]; EXEC SQL VAR szhValorParametro   IS STRING(512+1);
    EXEC SQL END DECLARE SECTION;

    char szTipParametro [32+1] ="";
    char szValParametro [512+1]="";
    int  iRes;

    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);

    /* Obtencion Valor Monto Minimo Facturable */
    iRes = ifnGetParametro(671,szTipParametro,szhValorParametro ) ;

    if (iRes != SQLNOTFOUND)
    {
        if (iRes != SQLOK)
        {
            vDTrazasLog(szFuncion, "\n\t** ERROR, al recuperar parámetro 671 MONTO MINIMO FACTURABLE error [%d] **"
                                 , LOG01
                                 , iRes);
            return (FALSE);
        }
        strcpy(szValor,szhValorParametro);
    }
    else
    {
        vDTrazasLog (szFuncion,"\n\t\t=> ADVERTENCIA, No existe parámetro 671 MONTO MINIMO FACTURABLE",LOG03);
        return (FALSE);
    }

    return (TRUE);
} /************************* FIN bGetParamMontoMinimo ************************/

/*******************************************************************************************/
/* FUNCION     : bGetParamCodConcepto                                                      */
/* DESCRIPCION : Recuperar parámetro Cod. Concepto Monto Mínimo Facturable (672) desde     */
/*               Tabla FAD_PARAMETROS                                                      */
/*******************************************************************************************/
BOOL bGetParamCodConcepto (char *szValor)
{
    char szFuncion []= "bGetParamCodConcepto";
    
    EXEC SQL BEGIN DECLARE SECTION;
         char szhValorParametro[512+1]; EXEC SQL VAR szhValorParametro   IS STRING(512+1);
    EXEC SQL END DECLARE SECTION;

    char szTipParametro [32+1] ="";
    char szValParametro [512+1]="";
    int  iRes;

    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);

    /* Obtencion Valor Cod. de Concepto */
    iRes = ifnGetParametro(672,szTipParametro,szhValorParametro ) ;

    if (iRes != SQLNOTFOUND)
    {
        if (iRes != SQLOK)
        {
            vDTrazasLog(szFuncion, "\n\t** ERROR, al recuperar parámetro 672 COD. CONCEPTO error [%d] **"
                                 , LOG01
                                 , iRes);
            return (FALSE);
        }
        strcpy(szValor,szhValorParametro);
    }
    else
    {
        vDTrazasLog (szFuncion,"\n\t\t=> ADVETENCIA, No existe parámetro 672 COD. CONCEPTO",LOG03);
        return (FALSE);
    }

    return (TRUE);
} /************************* FIN bGetParamCodConcepto ************************/

/* P-MIX-09003 138632 */
/*******************************************************************************************/
/* FUNCION     : bGetParamAplicaAcumNetoGrav                                               */
/* DESCRIPCION : Recuperar parámetro Aplica Acum. Neto Grav. (682) desde                   */
/*               Tabla FAD_PARAMETROS                                                      */
/*******************************************************************************************/
BOOL bGetParamAplicaAcumNetoGrav (char *szValor)
{
    char szFuncion []= "bGetParamAplicaAcumNetoGrav";
    
    EXEC SQL BEGIN DECLARE SECTION;
         char szhValorParametro[512+1]; EXEC SQL VAR szhValorParametro   IS STRING(512+1);
    EXEC SQL END DECLARE SECTION;

    char szTipParametro [32+1] ="";
    char szValParametro [512+1]="";
    int  iRes;

    vDTrazasLog(szFuncion,"\n\tEntrando a %s ",LOG04,szFuncion);

    /* Obtencion Valor Aplica Acum. Neto Grav. */
    iRes = ifnGetParametro(682,szTipParametro,szhValorParametro ) ;

    if (iRes != SQLNOTFOUND)
    {
        if (iRes != SQLOK)
        {
            vDTrazasLog(szFuncion, "\n\t** ERROR, al recuperar parámetro 682 Aplica Acum. Neto Grav. error [%d] **"
                                 , LOG01
                                 , iRes);
            return (FALSE);
        }
        strcpy(szValor,szhValorParametro);
    }
    else
    {
        vDTrazasLog (szFuncion,"\n\t\t=> ADVETENCIA, No existe parámetro 682 Aplica Acum. Neto Grav.",LOG03);
        return (FALSE);
    }

    return (TRUE);
} /************************* FIN bGetParamAplicaAcumNetoGrav ************************/
/* P-MIX-09003 138632 */

/*********************************************************************************/
/* FUNCION     : bfnDBInsertCargo()                                              */
/* DESCRIPCION : Pasamos datos a la tabla GE_CARGOS                              */
/*********************************************************************************/
BOOL bfnDBInsertCargo( long   lCodConcepto, 
                       long   lCodCliente,
                       long   lNumAbonado, 
                       double dMontoCargo, 
                       long   lNextCodCiclFact, 
                       char   *szNextFecEmision)
{
    char szFuncion          []="bfnDBInsertCargo";	
    char szCadenaInsert [2048]="";
    
    EXEC SQL BEGIN DECLARE SECTION;
         long    lhCodCliente;         
         long    lhNumAbonado;         
         long    lhCodConcepto;
         long    lhNextCodCiclFact;
         char    szhNextFecEmision [19+1]; EXEC SQL VAR szhNextFecEmision IS STRING(19+1);
         double  dhMontoCargo; /* P-MIX-09003 136182 */
    EXEC SQL END DECLARE SECTION;    

    memset(szhNextFecEmision,'\0',sizeof(szhNextFecEmision));

    lhCodCliente      = lCodCliente;
    lhNumAbonado      = lNumAbonado;
    lhCodConcepto     = lCodConcepto;
    dhMontoCargo      = dMontoCargo; /* P-MIX-09003 136182 */    
    lhNextCodCiclFact = lNextCodCiclFact;
    strcpy(szhNextFecEmision,szNextFecEmision);   

    vDTrazasLog ( szFuncion, "\n\tEntrada en bfnDBInsertCargo "
                             "\n\t=> Cód. Cliente               [%ld]"
                             "\n\t=> Cód. Concepto              [%ld]"
                             "\n\t=> Monto Cargo                [%f]"
                             "\n\t=> Prox. Ciclo Facturacion    [%ld]"
                             "\n\t=> Fecha Emision              [%s]"
                            , LOG05
                            , lhCodCliente
                            , lhCodConcepto
                            , dhMontoCargo
                            , lhNextCodCiclFact
                            , szhNextFecEmision);
                            
                      
    EXEC SQL 
         INSERT INTO GE_CARGOS (
                       NUM_CARGO,       COD_CLIENTE,
                       COD_PRODUCTO,    COD_CONCEPTO,
                       FEC_ALTA,        IMP_CARGO,
                       COD_MONEDA,      COD_PLANCOM,
                       NUM_UNIDADES,    IND_FACTUR,
                       NUM_TRANSACCION, NUM_VENTA,
                       NUM_PAQUETE,     NUM_ABONADO,
                       NUM_TERMINAL,    COD_CICLFACT,
                       NUM_SERIE,       NUM_SERIEMEC,
                       CAP_CODE,        MES_GARANTIA,
                       NUM_PREGUIA,     NUM_GUIA,
                       NUM_FACTURA,     COD_CONCEPTO_DTO,
                       VAL_DTO,         TIP_DTO,
                       IND_CUOTA,       IND_SUPERTEL,
                       IND_MANUAL,      NOM_USUARORA,
                       PREF_PLAZA,      COD_TECNOLOGIA
                      )
         VALUES (GE_SEQ_CARGOS.NEXTVAL, :lhCodCliente,
                 :iCodProducto,        :lhCodConcepto,
                 TO_DATE(:szhNextFecEmision,'DD-MM-YYYY HH24:MI:SS'), :dhMontoCargo, 
                 :szCodMoneda,          :iCodPlanCom,
                 :iNumUnidades,         :iIndFactur,
                 :iNumTransaccion,      :iNumVenta,
                 NULL,                  :lhNumAbonado,
                 NULL,                  :lhNextCodCiclFact,
                 NULL,                  NULL,
                 NULL,                  NULL,
                 NULL,                  NULL,
                 :iNumFactura ,         NULL,
                 NULL,                  NULL,
                 :iIndCuota,            NULL,
                 NULL,                  NULL,
                 NULL,                  NULL
                );                           
                           
    if (SQLCODE != SQLOK) 
    {
        vDTrazasError(szFuncion, "\n\tError en INSERT GE_CARGOS : %s"
                              , LOG01, SQLERRM);
        vDTrazasLog  (szFuncion, "\n\tError en INSERT GE_CARGOS : %s"
                               , LOG01, SQLERRM); 
        return(FALSE);
    }                               

    return (TRUE);
}/* **************** * END bfnDBPasarCargosConProceso * ******************** */

/******************************************************************************************/
/** Información de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisión                                            : */
/**  %PR% */
/** Autor de la Revisión                                : */
/**  %AUTHOR% */
/** Estado de la Revisión ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creación de la Revisión                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/

