/*  Version  FAC_DES_MAS ImpSclFnc.pc  7.000   */

#include <ImpSclFnc.h>
#include <math.h>

    EXEC SQL INCLUDE sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;
         long lhNumAbonado       ;
         long lhCodCilclFact     ;
         long lhIndOrdentotal    ;
         char szhStrCodCliente[9];
         long lhCodCliente       ;
         char szhFecDesde    [10];
         char szhFecHasta    [10];
    EXEC SQL END DECLARE SECTION ;

    EXEC SQL
        DECLARE curPagos CURSOR FOR
            SELECT
                MONTO,
                TO_CHAR(FECHA, 'YYYYMMDD'),
                DESCRIPCION,
                NVL(DES_TIPVALOR, 'NO REGISTRADO'),
                NVL(A.TIP_PAGO,0),
                NVL(COD_OPERADORA,' '),
                NVL(COD_TIPDOCUM,0)    
            FROM
                CO_ULTPAGO_TT A,
                CO_TIPVALOR B
            WHERE
                B.TIP_VALOR (+)=  A.COD_MODPAGO
                AND COD_CLIENTE = :lhCodCliente
                AND COD_CICLFACT = :lhCodCilclFact;

    EXEC SQL DECLARE curMensNoCiclo CURSOR FOR
                SELECT DESC_MENSLIN
                  FROM FA_MENSPROCESO A,
                       FA_MENSAJES B
                 WHERE A.NUM_PROCESO = :lhNumAbonado
                   AND A.CORR_MENSAJE = B.CORR_MENSAJE
                 ORDER BY A.CORR_MENSAJE,B.NUM_LINEA;

    EXEC SQL DECLARE curArrastre CURSOR FOR
                SELECT  COD_CLIENTE ,
                        COD_ABONADO ,
                        COD_BOLSA  ,
                        VAL_BOLSA,
                        IND_UNIDAD,
                        VAL_ARRASTRE,
                        VAL_EXPIRADO,
                        VAL_DISPONIBLE,
                        VAL_CONSUMO,
                        VAL_RESTO,
                        SUBSTR(TO_CHAR(COD_CLIENTE, :szhStrCodCliente),2)||SUBSTR(TO_CHAR(COD_ABONADO, :szhStrCodCliente),2)
                        FROM  TOL_HDARRASTRE_TH
                        WHERE COD_CICLFACT = :lhCodCilclFact
                        ORDER BY COD_CLIENTE,COD_ABONADO ;

    EXEC SQL DECLARE curDocsPeriodo CURSOR FOR
            SELECT
                A.COD_OPERADORA,
                A.COD_OFICINA,
                A.COD_TIPDOCUM,
                B.DES_TIPDOCUM,
                A.PREF_PLAZA,
                A.NUM_FOLIO,
                TO_CHAR(A.FEC_EMISION,'YYYYMMDD'),
                A.TOT_FACTURA
            FROM
                FA_HISTDOCU A, GE_TIPDOCUMEN B
            WHERE
                A.COD_TIPDOCUM = B.COD_TIPDOCUM
                AND A.COD_CLIENTE = :lhCodCliente
                AND A.FEC_EMISION >= TO_DATE(:szhFecDesde,'YYYYMMDD')
                AND A.FEC_EMISION <= TO_DATE(:szhFecHasta,'YYYYMMDD') + 1;

/*****************************************************************************************************/
/* FUNCION     : bfnBuscaNotaPedido                                                                  */
/* DESCRIPCION : Recuperar Numero de Guia y Numero Documento Pedido para impresión de Registro A1130 */
/*****************************************************************************************************/
BOOL bfnBuscaNotaPedido (long lNumProceso, char *szNumGuia, long *lNumDocPedido)
{
    char modulo[]   ="bfnBuscaNotaPedido";	
    
    EXEC SQL BEGIN DECLARE SECTION;
         long    lhNumProceso             ;
         char    szhNumGuia     [25+1]= ""; EXEC SQL VAR szhNumGuia IS STRING(25+1);
         long    lhNumDocPedido       = 0L;                
    EXEC SQL END DECLARE SECTION;
    
    vDTrazasLog(szModulo,"\n\t Entrando a Función [%s]",LOG06,szModulo);
    
    memset(szhNumGuia,0,sizeof(szhNumGuia));

    lhNumProceso = lNumProceso;
    
    EXEC SQL
         SELECT NVL(B.NUM_GUIA,' '),
                NVL(TO_CHAR(B.NUM_DOC_PEDIDO),' ')
         INTO   :szhNumGuia,
                :lhNumDocPedido
         FROM   GA_VENTAS A ,
                NPT_PEDIDO B,
                FA_INTERFACT C
         WHERE  A.NUM_VENTA = C.NUM_VENTA
         AND    A.NUM_VENTA = B.NUM_DOC_PEDIDO
         AND    C.NUM_PROCESO = :lhNumProceso;
         
    if(SQLCODE == SQLOK)
    {
    	strcpy(szNumGuia,szhNumGuia);
    	*lNumDocPedido = lhNumDocPedido;
        return(TRUE);
    }
    else
    {
        if(SQLCODE == SQLNOTFOUND)
        {
    	    strcpy(szNumGuia,szhNumGuia);
    	    *lNumDocPedido = lhNumDocPedido;
            return(TRUE);
        }
        else
        {
            vDTrazasLog (modulo,"\n\t\t* En sentencia SELECT, Codigo: [%d]", LOG01,sqlca.sqlcode);
            return(FALSE);
        }
    }                 
}/*********************************** FIN bfnBuscaNotaPedido ***********************************/

BOOL bfnOrdenaImpresionRC (ST_TABLA_ACUM  *pstTablaAcum, ST_TABLA_ORDEN *pstTablaOrden, int iUltimaPosicion)
{
    register int i,j,x;
    char        szKeyAux[50];
    int         iSocaloAux;

    vDTrazasLog(szModulo,"bfnOrdenaImpresionRC iUltimaPosicion[%d]",LOG06,iUltimaPosicion);

    for (i=0; i<iUltimaPosicion; i++)
    {
        strcpy(pstTablaOrden->szKey[i],pstTablaAcum->szKey[i]);
        vDTrazasLog(szModulo,"bfnOrdenaImpresionRC 1[%d] 2[%s] 3[%s]"
                             ,LOG06,i,pstTablaAcum->szKey[i],pstTablaOrden->szKey[i]);
        pstTablaOrden->iSocalo[i]       = i;
    }
    x = 0;
    for (j = iUltimaPosicion; j > 0; j--)
    {
        for (i=0; i < j-1; i++)
        {
            vDTrazasLog(szModulo,"bfnOrdenaImpresionRC COMPARA1[%s] COMPARA2[%s]"
                                ,LOG06,pstTablaOrden->szKey[i],pstTablaOrden->szKey[i+1]);
            if(strcmp(pstTablaOrden->szKey[i],pstTablaOrden->szKey[i+1])>0)
            {
                strcpy(szKeyAux,pstTablaOrden->szKey[i+1]);
                iSocaloAux  = pstTablaOrden->iSocalo[i+1];
                strcpy(pstTablaOrden->szKey[i+1],pstTablaOrden->szKey[i]);
                vDTrazasLog(szModulo,"bfnOrdenaImpresionRC SOCALO2[%d]\n"
                					 "bfnOrdenaImpresionRC SOCALO3[%s]"
                					 ,LOG06,pstTablaOrden->iSocalo[i+1]
                					 ,pstTablaOrden->szKey[i+1]);

                pstTablaOrden->iSocalo[i+1]    = pstTablaOrden->iSocalo[i];
                vDTrazasLog(szModulo,"bfnOrdenaImpresionRC SOCALO4[%d]",LOG06,pstTablaOrden->iSocalo[i+1]);

                strcpy(pstTablaOrden->szKey[i],szKeyAux);
                vDTrazasLog(szModulo,"bfnOrdenaImpresionRC SOCALO5[%s]",LOG06,pstTablaOrden->szKey[i]);
                pstTablaOrden->iSocalo[i]      = iSocaloAux;
            }
        }
        x++;
    }

    return (1);
}

int CalculaDigVerif (double Inumero, int * DigVerif )
{
    int i       = 0;
    int j       = 2;
    int iDigito = 0;

    char szAux[2]   = "";
    char szNum[100] = "";
    long IValor;

    div_t stRes         ;

	if ((long)Inumero != Inumero){
    	IValor = (long)Inumero*pow(10,atoi(szNumDecimal));
        if(IValor<0){
        	IValor*=-1;
        }
        sprintf (szNum ,"%ld",IValor );
 	}
    else{
    	sprintf (szNum,"%.0f",Inumero);
	}

    i = strlen(szNum)-1;

    while (i >= 0)
    {
    	if (j <= 0)
        	j  = 2;
		strncpy (szAux, &szNum [i], 1);
        iDigito += (atoi (szAux) * j);
        j--;
        i--;
	}

    stRes = div (iDigito, 10);
	if (stRes.rem == 0)
    	*DigVerif = 0;
	else
    	*DigVerif = 10 - stRes.rem;

return (1);

}/**************************** Final CalculaDigVerif **********************/

BOOL bEscribeEnArchivo(FILE *Fd_ArchImp, char * zsBuffImpArch, char * buffer_local)
{
    int rc = 0;

    strcpy (szModulo, "bEscribeEnArchivo");
    
    vDTrazasLog(szModulo,"\n\t Entrando a Función [%s]"
                             ,LOG06,szModulo);

// vDTrazasLog(szModulo,"\n\t RPL ENTRANDO A ESCRIBIR ARCHIVO [%s] buffer_local:[%s]  zsBuffImpArch:[%s]",LOG06,szModulo,buffer_local,zsBuffImpArch);
 
    if(strncmp(buffer_local,FLUSH,strlen(FLUSH))==0)
    {
 //    vDTrazasLog(szModulo,"\n\t RPL entro 1",LOG06);
        if(strlen(zsBuffImpArch)>0)
        {
//        vDTrazasLog(szModulo,"\n\t RPL entro 1-1",LOG06);
            rc = fputs(zsBuffImpArch,Fd_ArchImp);
            fflush(Fd_ArchImp);
            if(rc<=0)
            {
//            vDTrazasLog(szModulo,"\n\t RPL entro 1-2",LOG06);
                vDTrazasLog(szModulo,"\n\t Error en fputs() Archivo Salida [%s]",LOG06,szModulo);            	
                return(FALSE);
            }
            memset(zsBuffImpArch,0,sizeof(zsBuffImpArch));
        }
    }
    else
    {
//    vDTrazasLog(szModulo,"\n\t RPL entro 2",LOG06);
        if((strlen(buffer_local) + strlen(zsBuffImpArch)) < MAX_BYTES_BUFFER_IMP)
        {
//        vDTrazasLog(szModulo,"\n\t RPL entro 2-1",LOG06);
            strcat(zsBuffImpArch,buffer_local);
        }
        else
        {
       // vDTrazasLog(szModulo,"\n\t RPL entro 2-2",LOG06);
            rc = fputs(zsBuffImpArch,Fd_ArchImp);
            fflush(Fd_ArchImp);
            if(rc<=0){
       //     vDTrazasLog(szModulo,"\n\t RPL entro 2-3",LOG06);
                vDTrazasLog(szModulo,"\n\t bEscribeEnArchivo RETORNO ERROR",LOG02);
                return(FALSE);
            }
            memset(zsBuffImpArch,0,sizeof(zsBuffImpArch));
            strcpy(zsBuffImpArch,buffer_local);
        }
    }

    if (stStatus.LogNivel >= LOG06)
    {
 //   vDTrazasLog(szModulo,"\n\t RPL entro 3",LOG06);
        fflush(stStatus.LogFile);
    	fflush(stStatus.ErrFile);
	}
	
	//vDTrazasLog(szModulo,"\n\t RPL salida ",LOG06);
	
	return (1);
}
/****************** Final bEscribeEnArchivo *******************/

int FillCodIdioma(char *dat)
{
    int i;
    char aux[5+1];
    sprintf(aux,"%-5.5s\0",dat);
    for(i=0;i<strlen(aux);i++)
    {
    	if(aux[i]==' ')
    	{
        	aux[i]='0';
        }
    }
    sprintf(dat,"%5.5s\0",aux);
    return(0);
}

int RetPos(char *Cadena, ST_TABLA  *Tabla)
{
    int i;

    for(i=0; i<Tabla->iLastPosition; i++)
    {
        if (!strcmp (Tabla->szDes[i], Cadena))
                        return (Tabla->iPosition[i]);
    }
    strcpy(Tabla->szDes[i],Cadena);
    Tabla->iPosition[i]  = i;
    Tabla->iLastPosition = i + 1;

    return(i);

}/**************************** Final RetPos **********************/

int FormatoHora(long lNumero, int iLargoNum , char *szFormato)
{
        ldiv_t  division;
        long    lDivisor=60;
        long    lMinutos;
        long    lSegundos;

        if (lNumero < 0) lNumero = 0;
        division = ldiv (lNumero,lDivisor);
        lMinutos = division.quot;
        lSegundos= division.rem;

        sprintf (szFormato, "%*.*ld:%2.2ld",iLargoNum, iLargoNum,lMinutos, lSegundos);

        return(0);
}

int BuscaAbonado(ST_ABONADO *Abonado,int *pos,long NumAbo)
{
   	int i;

	if (Abonado->CantidadAbonados==1)
	{ 
            if(NumAbo==Abonado->lNumAbonado[0])
            {
               *pos=0;
               return(0);
            }
	}
	else 
	{	
	    for(i=0;i< Abonado->CantidadAbonados;i++)
	    {
	        if(NumAbo==Abonado->lNumAbonado[i])
	        {
	            *pos=i;
	            return(0);
	        }
	    }
	}
    *pos=-1;
    return(0);
}

int FormateaDireccion(char *Direccion,char *dir_noformateada)
{
   int  rc,CmpPos,Pos,ARGC_DIR01,ARGC_DIR02;
   char *ARGV_DIR01[20],*ARGV_DIR02[20],CampoFormateado[1000];

   rc=TRUE;
   strcpy (szModulo, "FormateaDireccion");

   dir_noformateada[0]=0;

   RecupParam(&ARGC_DIR01,ARGV_DIR01,Direccion,SEPARADOR_01);

   vDTrazasLog(szModulo,"\tFormateaDireccion:Direccion:(%s)",LOG04,Direccion);
   for(Pos=0;Pos<ARGC_DIR01;Pos++)
   {
      RecupParam(&ARGC_DIR02,ARGV_DIR02,ARGV_DIR01[Pos],SEPARADOR_02);
      if(ARGC_DIR02 <2)
      {
            vDTrazasLog(szModulo, "\tFormateaDireccion:error numero regitros (%d):campo(%s)"
                                , LOG04, ARGC_DIR02,ARGV_DIR01[Pos]);
            rc=FALSE;
      }
      else
      {
            sprintf(CampoFormateado,"%-*.*s" ,atoi(ARGV_DIR02[1]),atoi(ARGV_DIR02[1]),((ARGC_DIR02<3)? "":ARGV_DIR02[2]));
            vDTrazasLog(szModulo,"\tFormateaDireccion:campo:(%s)",LOG06,CampoFormateado);
            strcat(dir_noformateada,CampoFormateado);
      }
      for(CmpPos=0;CmpPos<ARGC_DIR02;CmpPos++){ free(ARGV_DIR02[CmpPos]);}
   }
   for(Pos=0;Pos<ARGC_DIR01;Pos++){
        free(ARGV_DIR01[Pos]);
   }

   vDTrazasLog(szModulo,"\tFormateaDireccion:dir_noformateada:(%s)",LOG04,dir_noformateada);

   return(rc);
}

int bfnAcumulaMontos(   ST_ACUMMTO      *AcumMto,
            double          dTotFactura,
            double          dTotalCuotas,
            double          dTotalAPagar,
            double          dTotalSaldo)
{
    strcpy (szModulo, "bfnAcumulaMontos");

    AcumMto->dTotFactura    =  AcumMto->dTotFactura  + dTotFactura;
    AcumMto->dTotCuotas     =  AcumMto->dTotCuotas   + dTotalCuotas;
    AcumMto->dTotPagar      =  AcumMto->dTotPagar    + dTotalAPagar;
    AcumMto->dTotSaldoAnt   =  AcumMto->dTotSaldoAnt + dTotalSaldo;

    vDTrazasLog (szModulo,"AcumMto->dTotFactura [%.4f] "
                          "AcumMto->dTotCuotas  [%.4f] "
                          "AcumMto->dTotPagar   [%.4f] "
                          "AcumMto->dTotSaldoAnt[%.4f] "
                          ,LOG04, AcumMto->dTotFactura
                          , AcumMto->dTotCuotas, AcumMto->dTotPagar
                          , AcumMto->dTotSaldoAnt);

    return (1);
}/*********************** Final bfnAcumulaMontos **********************/

BOOL bfnInsertar_FadCTLImpres( ST_ACUMMTO    *AcumMto,
                               LINEACOMANDO  *ParEntrada,
                               ST_INFGENERAL *sthFa_InfGeneral,
                               char          *szNomArch)
{
    EXEC SQL BEGIN DECLARE SECTION;
         char   szhCodInforme   [7]  ;
         long   lhNumSecuInfo        ;
         int    ihCodTipImpres       ;
         int    ihCodTipDocum        ;
         char   szhCodDespacho  [6]  ;
         char   szhNomArchivo   [255];
         long   lhNumClientes        ;
         double dhTot_Factura        ;
         double dhTot_Cuotas         ;
         double dhTot_Pagar          ;
         double dhTot_SaldoAnt       ;
    EXEC SQL END DECLARE SECTION;
    
    strcpy (szModulo, "bfnInsertar_FadCTLImpres");

    sprintf(szhCodInforme,"%s",szCODINFORME_GENERAR);
    lhNumSecuInfo  = ParEntrada->lNum_SecuInfo;
    ihCodTipImpres = COD_TIP_IMPRE;
    ihCodTipDocum  = ParEntrada->iCodTipDocum;
    sprintf(szhCodDespacho,"%s",ParEntrada->szCodDespacho);
    sprintf(szhNomArchivo,"%s",szNomArch);
    lhNumClientes  = (long) sthFa_InfGeneral->iContClientesProcesados;
    dhTot_Factura   = AcumMto->dTotFactura ;
    dhTot_Cuotas    = AcumMto->dTotCuotas  ;
    dhTot_Pagar     = AcumMto->dTotPagar   ;
    dhTot_SaldoAnt  = AcumMto->dTotSaldoAnt;

    vDTrazasLog(szModulo,"Proceso de Insercion en la FAD_CTLIMPRES(%s|%ld|%d|%d|%s|%s|%ld|%.4f|%.4f|%.4f|%.4f|)\n",
        LOG04,
        szhCodInforme,
        lhNumSecuInfo,
        ihCodTipImpres,
        ihCodTipDocum,
        szhCodDespacho,
        szhNomArchivo,
        lhNumClientes,
        dhTot_Factura,
        dhTot_Cuotas,
        dhTot_Pagar,
        dhTot_SaldoAnt
    );

    EXEC SQL INSERT
               INTO  FAD_CTLIMPRES (COD_INFORME,
                                    NUM_SECUINFO,
                                    COD_TIPIMPRES,
                                    COD_TIPDOCUM,
                                    COD_DESPACHO,
                                    NOM_ARCHIVO,
                                    NUM_CLIENTES,
                                    TOT_FACTURAS,
                                    TOT_CUOTAS,
                                    TOT_PAGAR,
                                    TOT_SALDOANT,
                                    TOT_LOCALES,
                                    TOT_INTERZONA,
                                    TOT_ESPECIALES,
                                    TOT_CARRIER,
                                    TOT_ROAMING,
                                    COD_ESTADO)
               VALUES ( :szhCodInforme,
                        :lhNumSecuInfo,
                        :ihCodTipImpres,
                        :ihCodTipDocum,
                        :szhCodDespacho,
                        :szhNomArchivo,
                        :lhNumClientes,
                        :dhTot_Factura,
                        :dhTot_Cuotas,
                        :dhTot_Pagar,
                        :dhTot_SaldoAnt,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0);

    if(sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog(szModulo, "\tError en INSERT de FAD_CTLIMPRES : %s ", LOG02,  sqlca.sqlerrm.sqlerrmc);
        return (FALSE);
    }

    EXEC SQL COMMIT;

    if(sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog(szModulo, "\tError en COMMIT al INSERT de FAD_CTLIMPRES : %s ", LOG02, sqlca.sqlerrm.sqlerrmc);
        return (FALSE);
    }

    memset(AcumMto,0,sizeof(ST_ACUMMTO));
    return (1);
}/********************* Final bfnInsertar_FadCTLImpres ***********************/

int bfnElimina_FadCTLImpres(LINEACOMANDO *ParEntrada)
{

    strcpy (szModulo, "bfnElimina_FadCTLImpres");

    EXEC SQL DELETE FROM FAD_CTLIMPRES
        WHERE
        NUM_SECUINFO = :ParEntrada->lNum_SecuInfo AND
        COD_TIPDOCUM = :ParEntrada->iCodTipDocum  AND
        COD_DESPACHO = :ParEntrada->szCodDespacho;

    if (sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND)
    {
        vDTrazasLog(szModulo, "\tError en DELETE de FAD_CTLIMPRES : %s ", LOG02,  sqlca.sqlerrm.sqlerrmc);
        return (FALSE);
    }

    EXEC SQL COMMIT;

    if(sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog(szModulo, "\tError en COMMIT al DELETE de FAD_CTLIMPRES : %s ", LOG02, sqlca.sqlerrm.sqlerrmc);
        return (FALSE);
    }

    return(1);
}/***************** Final bfnElimina_FadCTLImpres ********************/

BOOL bfnReg_Padre(LINEACOMANDO *ParEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION  ;
        long    lhCodProceso        ;
        long    lhCodCiclo          ;
        int     ihCodEstado         ;
        char    szhGlsProceso   [50];
        char    szhHostId[11]       ;
        int     ihOpcionRango       ;
    EXEC SQL END DECLARE SECTION    ;

    strcpy (szModulo, "bfnReg_Padre");

    strcpy(szhHostId,szgHostId);
    ihOpcionRango=igOpcionRango;

    lhCodProceso = COD_PROCESO;
    lhCodCiclo   = ParEntrada->lCodCiclFact;

    strcpy(szhGlsProceso, GLS_PROCINIT);

    if (!bfnElimina_FadCTLImpres(ParEntrada))
    {
        vDTrazasLog(szModulo,"Error en ejecucion de bfnElimina_FadCTLImpres ",LOG02);
        return(FALSE);
    }

    EXEC SQL
    SELECT COD_ESTAPROC
     INTO :ihCodEstado
    FROM FA_TRAZAPROC
    WHERE COD_PROCESO = :lhCodProceso
      AND COD_CICLFACT = :lhCodCiclo
      AND ((HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango));

    if (sqlca.sqlcode == SQLNOTFOUND)
    { 	
        ihCodEstado=iPROC_EST_RUN;
        EXEC SQL
        INSERT INTO FA_TRAZAPROC (
            COD_CICLFACT,
            COD_PROCESO,
            COD_ESTAPROC,
            FEC_INICIO,
            GLS_PROCESO,
            COD_CLIENTE,
            NUM_ABONADO,
            NUM_REGISTROS,
            HOST_ID)
        VALUES(
           :lhCodCiclo,
           :lhCodProceso,
           :ihCodEstado,
           SYSDATE,
           :szhGlsProceso,
           0,
           0,
           0,
           :szhHostId);

        if (sqlca.sqlcode != SQLOK)
        {
            vDTrazasLog (szModulo,"Error en ejecucion de INSERT de bfnReg_Padre ",LOG01);
            return(FALSE);
        }

        EXEC SQL COMMIT;
        if (sqlca.sqlcode != SQLOK)
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnReg_Padre ",LOG01);
            return(FALSE);
        }

        return (TRUE);
    }

    if (sqlca.sqlcode != SQLOK && sqlca.sqlcode != SQLNOTFOUND)
    {
        vDTrazasLog (szModulo,"Error en ejecucion de SELECT de bfnReg_Padre ",LOG01);
        return(FALSE);
    }

    if (ihCodEstado != iPROC_EST_RUN)
    {
        ihCodEstado=iPROC_EST_RUN;
        EXEC SQL
            UPDATE FA_TRAZAPROC
               SET COD_ESTAPROC = :ihCodEstado ,
                   GLS_PROCESO =  :szhGlsProceso,
                   FEC_INICIO =  SYSDATE,
                   FEC_TERMINO =  NULL
             WHERE COD_PROCESO = :lhCodProceso
               AND COD_CICLFACT = :lhCodCiclo
               AND ((HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango));

        if (sqlca.sqlcode != SQLOK && sqlca.sqlcode == SQLNOTFOUND)
        {
            vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de bfnReg_Padre ",LOG01);
            return(FALSE);
        }
        EXEC SQL COMMIT;

        if (sqlca.sqlcode != SQLOK)
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnReg_Padre ",LOG01);
            return(FALSE);
        }

    }
    else
    {
        if (!bfnChequeaEstado(ParEntrada))
        {
            vDTrazasLog(szModulo,"Falla en la ejecucion de  bfnChequeaEstado ",LOG01);
            return (FALSE);
        }
    }
    return(1);
}/********************* Final bfnReg_Padre ************************/

BOOL bfnActualiza_ProcImpresion(LINEACOMANDO ParEntrada, BOOL bLlave)
{
    EXEC SQL BEGIN DECLARE SECTION  ;
        int     ihCodTipDocum       ;
        long    lhCodCiclo          ;
        int     ihCodEstado         ;
        char    szhglosa    [51]    ;
        char    szhCodDespacho [6];
        char    szhHostId[11]       ;
        int     ihOpcionRango       ;
    EXEC SQL END DECLARE SECTION    ;

    strcpy (szModulo, "bfnActualiza_ProcImpresion");

    ihCodTipDocum   = ParEntrada.iCodTipDocum;
    lhCodCiclo      = ParEntrada.lCodCiclFact;
    strcpy(szhCodDespacho, ParEntrada.szCodDespacho);

    strcpy(szhHostId,szgHostId);
    ihOpcionRango=igOpcionRango;


    if (bLlave){
        ihCodEstado = iPROC_EST_OK;
        strcpy(szhglosa,szPROC_EST_OK);
    }
    else{
        ihCodEstado = iPROC_EST_ERR;
        strcpy(szhglosa,szPROC_EST_ERR);
    }
    EXEC SQL
        UPDATE FA_PROCIMPRESION_TD 
           SET COD_ESTAPROC = :ihCodEstado ,
               FEC_TERMINO  = SYSDATE,
               GLS_ESTAPROC = :szhglosa
         WHERE COD_CICLFACT = :lhCodCiclo
           AND COD_TIPDOCUM = :ihCodTipDocum
           AND COD_DESPACHO = :szhCodDespacho
           AND ((HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango));

    if (sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de bfnActualiza_ProcImpresion ",LOG01);
        return(FALSE);
    }
    else
    {
        EXEC SQL COMMIT;
        if (sqlca.sqlcode != SQLOK)
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnActualiza_ProcImpresion ",LOG01);
            return(FALSE);
        }

    }
    return(1);
}/******************** Final bfnActualiza_ProcImpresion ***********************/

BOOL bfnActualiza_TrazaProceso(LINEACOMANDO ParEntrada,BOOL bLlave)
{
    int     NroRegsProcImp;
    int     i;
    int     TotalEstados=5;

    EXEC SQL BEGIN DECLARE SECTION  ;
        int     ihCod_Estaproc  [MAX_TRAZAPROC]     ;
        int     ihCod_Estado  ;
        char    szhCodDespacho[6];
        long    lhCodCiclo;
        long    lhCodProceso;
        char    szhGlsProceso[50];
        char    szhHostId[11]       ;
        int     ihOpcionRango       ;
    EXEC SQL END DECLARE SECTION    ;

    int contador_estados[5];
    strcpy (szModulo, "bfnActualiza_TrazaProceso");

    vDTrazasLog(szModulo, "\tEntro a %s", LOG04,szModulo);

    strcpy(szhHostId,szgHostId);
    ihOpcionRango=igOpcionRango;

    lhCodCiclo      = ParEntrada.lCodCiclFact;
    lhCodProceso    = COD_PROCESO;
    strcpy(szhCodDespacho, ParEntrada.szCodDespacho);

    if(lhCodCiclo)
    {
        EXEC SQL
            SELECT COD_ESTAPROC
              INTO :ihCod_Estaproc
              FROM FA_PROCIMPRESION_TD
             WHERE COD_CICLFACT = :lhCodCiclo
               AND ((HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango));

        NroRegsProcImp = sqlca.sqlerrd[2];
        vDTrazasLog(szModulo, "query retorno registros sqlca.sqlcode(%d)NroRegsProcImp(%d)", LOG04,sqlca.sqlcode,NroRegsProcImp);

        if(sqlca.sqlcode < SQLOK && NroRegsProcImp<=0)
        {
           vDTrazasLog(szModulo, "Error en ejecucion del SELECT [%i]", LOG00, sqlca.sqlcode);
           return(FALSE);
        }

        for(i=0;i<TotalEstados;i++){
            contador_estados[i]=0;
        }

        for(i=0; i < NroRegsProcImp; i++)
        {
            contador_estados[ihCod_Estaproc[i]]++;
        }

  
        if(!(contador_estados[0]>0 || contador_estados[iPROC_EST_RUN]>0))
        {
            if(contador_estados[iPROC_EST_ERR]>0)
            {
                  ihCod_Estado=iPROC_EST_ERR;
                strcpy(szhGlsProceso, GLS_PROCFINNOOK);
                vDTrazasLog (szModulo,"Existen subproceso terminados con error\n",LOG04);
            }
            else
            {
                  ihCod_Estado=iPROC_EST_OK;
                strcpy(szhGlsProceso, GLS_PROCFINOK);
                vDTrazasLog (szModulo,"todos los subprocesos terminaron y bien\n",LOG04);
            }

            if (igOpcionRango)
            {
                EXEC SQL
                    UPDATE FA_TRAZAPROC
                       SET COD_ESTAPROC = :ihCod_Estado
                         , FEC_TERMINO  = SYSDATE
                         , GLS_PROCESO  = :szhGlsProceso
                     WHERE COD_CICLFACT = :lhCodCiclo
                       AND COD_PROCESO  = :lhCodProceso
                       AND ((HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango));
            }
            else
            {
                EXEC SQL
                    UPDATE FA_TRAZAPROC
                       SET COD_ESTAPROC = :ihCod_Estado
                         , FEC_TERMINO  = SYSDATE
                         , GLS_PROCESO  = :szhGlsProceso
                     WHERE COD_CICLFACT = :lhCodCiclo
                       AND COD_PROCESO  = :lhCodProceso;
            }
            if (sqlca.sqlcode != SQLOK)
            {
                vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de bfnActualiza_TrazaProceso ",LOG01);
                return(FALSE);
            }

            EXEC SQL COMMIT;

            if (sqlca.sqlcode != SQLOK)
            {
                vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnActualiza_TrazaProceso ",LOG01);
                return(FALSE);
            }
        }
        else
        {
            vDTrazasLog (szModulo,"Existe subproceso corriendo o por correr\n",LOG03);
        }
    }
    else
    {
        if (!bLlave)
        {
            ihCod_Estado=iPROC_EST_ERR;

            vDTrazasLog (szModulo,"ejecucion de UPDATE de FA_INTERFACT por num_proceso",LOG04);
            EXEC SQL UPDATE FA_INTERFACT SET COD_ESTADOC=:ParEntrada.iCodSalida, COD_ESTPROC = :ihCod_Estado
                     WHERE NUM_PROCESO = :ParEntrada.lProceso;

            if (sqlca.sqlcode != SQLOK)
            {
                vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de FA_INTERFACT ",LOG01);
                return(FALSE);
            }
        }
        else
        {
            ihCod_Estado=iPROC_EST_OK;
        }
        EXEC SQL COMMIT;

        if (sqlca.sqlcode != SQLOK)
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de FA_INTERFACT ",LOG01);
            return(FALSE);
        }
    }
    return(1);

}/********************* Final bfnActualiza_TrazaProceso ***********************/

BOOL bfnChequeaEstado (LINEACOMANDO *ParEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int     ihCod_Estaproc  ;
        char    szhCodDespacho[6];
        int     ihCodTipDocum   ;
        long    lhCodCiclo      ;
        char    szhHostId[11]   ;
        int     ihOpcionRango   ;
    EXEC SQL END DECLARE SECTION;

    strcpy (szModulo, "bfnChequeaEstado");

    lhCodCiclo      = ParEntrada->lCodCiclFact;
    strcpy(szhCodDespacho, ParEntrada->szCodDespacho);
    ihCodTipDocum   = ParEntrada->iCodTipDocum;

    strcpy(szhHostId,szgHostId);
    ihOpcionRango=igOpcionRango;

    EXEC SQL 
    	SELECT COD_ESTAPROC
          INTO :ihCod_Estaproc
          FROM FA_PROCIMPRESION_TD
         WHERE COD_CICLFACT  = :lhCodCiclo
           AND COD_DESPACHO  = :szhCodDespacho
           AND COD_TIPDOCUM  = :ihCodTipDocum
           AND ((HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango));

    if (sqlca.sqlcode != SQLOK && sqlca.sqlcode == SQLNOTFOUND)
    {
        vDTrazasLog(szModulo, "Error en SELECT de bfnChequeaEstado [%i]", LOG02, sqlca.sqlcode);
        return (FALSE);
    }
    if (ihCod_Estaproc == 1)
    {
        vDTrazasLog(szModulo, "Estado del proceso : En Proceso. El proceso actual se aborta", LOG01);
        return (FALSE);
    }

    return (1);

}
/********************* Final bfnChequeaProcesosPrevios ***************************/

BOOL bfnChequeaProcesosPrevios(LINEACOMANDO *ParEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION  ;
        long    lhCodCiclo          ;
        int     ihCodEstaPrec       ;
        int     ihTrazCodEstaProc   ;
        int     lhCod_Proceso       ;
        int     iValorCero=0        ;
        char    szhHostId[11]       ;
        int     ihOpcionRango       ;
    EXEC SQL END DECLARE SECTION    ;
    BOOL bFinCursor_cFaProcTraza=FALSE;

    strcpy (szModulo, "bfnChequeaProcesosPrevios");

    strcpy(szhHostId,szgHostId);
    ihOpcionRango=igOpcionRango;

    lhCodCiclo = ParEntrada->lCodCiclFact;
    lhCod_Proceso = COD_PROCESO;

    if (igOpcionRango)
    {	
        EXEC SQL DECLARE cFaProcTraza_Host CURSOR FOR
            SELECT
                    PROC.COD_ESTAPREC,
                    NVL(TRAZ.COD_ESTAPROC,:iValorCero)
            FROM    FA_TRAZAPROC  TRAZ,
                    (SELECT A.COD_PROCESO   COD_PROCESO,
                            B.DES_PROCESO   DES_PROCESO,
                            A.COD_PROCPREC  COD_PROCPREC,
                            C.DES_PROCESO   DES_PROCPREC,
                            A.COD_ESTAPREC  COD_ESTAPREC
                    FROM    FA_PROCFACTPREC A ,
                            FA_PROCFACT B ,
                            FA_PROCFACT C
                    WHERE   A.COD_PROCESO  = :lhCod_Proceso
                    AND     A.COD_PROCESO  = B.COD_PROCESO
                    AND     A.COD_PROCPREC = C.COD_PROCESO) PROC
            WHERE   TRAZ.COD_CICLFACT (+)  = :lhCodCiclo
            AND     TRAZ.COD_PROCESO  (+)  = PROC.COD_PROCPREC
            AND     ((TRAZ.HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango))
            ORDER BY PROC.COD_PROCESO;
    }
    else
    {	
        EXEC SQL DECLARE cFaProcTraza CURSOR FOR
            SELECT
                    PROC.COD_ESTAPREC,
                    NVL(TRAZ.COD_ESTAPROC,:iValorCero)
            FROM    FA_TRAZAPROC  TRAZ,
                    (SELECT A.COD_PROCESO   COD_PROCESO,
                            B.DES_PROCESO   DES_PROCESO,
                            A.COD_PROCPREC  COD_PROCPREC,
                            C.DES_PROCESO   DES_PROCPREC,
                            A.COD_ESTAPREC  COD_ESTAPREC
                    FROM    FA_PROCFACTPREC A ,
                            FA_PROCFACT B ,
                            FA_PROCFACT C
                    WHERE   A.COD_PROCESO  = :lhCod_Proceso
                    AND     A.COD_PROCESO  = B.COD_PROCESO
                    AND     A.COD_PROCPREC = C.COD_PROCESO) PROC
            WHERE   TRAZ.COD_CICLFACT (+)  = :lhCodCiclo
            AND     TRAZ.COD_PROCESO  (+)  = PROC.COD_PROCPREC
            ORDER BY PROC.COD_PROCESO;

    }

    if (igOpcionRango)
    {
        EXEC SQL OPEN cFaProcTraza_Host;
    }
    else
    {    	  	
        EXEC SQL OPEN cFaProcTraza;
    }


    if(SQLCODE != SQLOK)
    {    	    	
        vDTrazasLog  (szModulo, "\n\t**  Error : Al Crear Cursor de Procesos FA_PROCFACT - FA_TRAZAPROC **"
                                    "\n\t\t=> Para el Codigo de Proceso [%d]"
                                    "\n\t\t=> Para el Codigo de Ciclo   [%ld]"
                                    "\n\t\t=> (No Existe Traza Para el Proceso)\n%s\n"
                                    ,LOG01,lhCod_Proceso,lhCodCiclo,SQLERRM);
        vDTrazasError(szModulo, "\n\t**  Error : Al Crear Cursor de Procesos FA_PROCFACT - FA_TRAZAPROC **"
                                    "\n\t\t=> Para el Codigo de Proceso [%d]"
                                    "\n\t\t=> Para el Codigo de Ciclo   [%ld]"
                                    "\n\t\t=> (No Existe Traza Para el Proceso)\n%s\n"
                                    ,LOG01,lhCod_Proceso,lhCodCiclo,SQLERRM);
        return (FALSE);
    }

    bFinCursor_cFaProcTraza = FALSE ;
    do
    {
        if (igOpcionRango)        
            EXEC SQL FETCH cFaProcTraza_Host INTO
                        :ihCodEstaPrec          ,
                        :ihTrazCodEstaProc      ;
        else  
            EXEC SQL FETCH cFaProcTraza INTO
                        :ihCodEstaPrec          ,
                        :ihTrazCodEstaProc      ;

        if(SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
        {
            vDTrazasLog  (szModulo, "Error en Fetch de Cursor de cFaProcTraza Error-Ora[%ld]: %s"
                                        ,LOG01, SQLCODE, SQLERRM);
            vDTrazasError(szModulo, "Error en Fetch de Cursor de cFaProcTraza Error-Ora[%ld]: %s"
                                        ,LOG01, SQLCODE, SQLERRM);
            return (FALSE);
        }
        if(SQLCODE == SQLNOTFOUND)
        {
            bFinCursor_cFaProcTraza = TRUE;
        }
        else
        {
            if(ihCodEstaPrec != ihTrazCodEstaProc)
            {
                vDTrazasLog  (szModulo, "\n\t* Error: No ha Terminado Proceso Precedente **\n",LOG01);
                vDTrazasError(szModulo, "\n\t* Error: No ha Terminado Proceso Precedente **\n",LOG01);
                return(FALSE);
            }
        }
    } while(!bFinCursor_cFaProcTraza);

    if (igOpcionRango)
    {
        EXEC SQL CLOSE cFaProcTraza_Host;
    }
    else
    {
        EXEC SQL CLOSE cFaProcTraza;
    }

    return (1);

}
/********************* Final bfnChequeaProcesosPrevios ************************/

BOOL bfnActualizaRegprocImpres (LINEACOMANDO ParEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION      ;
        int     ihCod_Estaproc      ;
        char    szhCodDespacho  [6] ;
        char    szhglosa    [51]    ;
        int     ihCodTipDocum       ;
        long    lhCodCiclo          ;
        char    szhHostId[11]   ;
        int     ihOpcionRango   ;
    EXEC SQL END DECLARE SECTION        ;

    strcpy (szModulo, "bfnActualizaRegprocImpres");

    lhCodCiclo = ParEntrada.lCodCiclFact;
    strcpy(szhCodDespacho, ParEntrada.szCodDespacho);
    ihCodTipDocum   = ParEntrada.iCodTipDocum;

    strcpy(szhHostId,szgHostId);
    ihOpcionRango=igOpcionRango;

    EXEC SQL 
    	SELECT COD_ESTAPROC
          INTO :ihCod_Estaproc
          FROM FA_PROCIMPRESION_TD
         WHERE COD_CICLFACT = :lhCodCiclo
           AND COD_TIPDOCUM = :ihCodTipDocum
           AND COD_DESPACHO = :szhCodDespacho
           AND ((HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango));

    if (sqlca.sqlcode != SQLOK && sqlca.sqlcode == SQLNOTFOUND)
    {
        vDTrazasLog(szModulo, "Error en SELECT de bfnActualizaRegprocImpres [%d]", LOG02, sqlca.sqlcode);
        return (FALSE);
    }

    if (ihCod_Estaproc == 1)
    {
        vDTrazasLog (szModulo, "Estado del proceso : En Proceso. Proceso nuevo se aborta", LOG01);
        return(FALSE);
    }

    ihCod_Estaproc=iPROC_EST_RUN;
    strcpy(szhglosa,szPROC_EST_RUN);

    EXEC SQL 
    	UPDATE FA_PROCIMPRESION_TD
           SET COD_ESTAPROC = :ihCod_Estaproc ,
        	   GLS_ESTAPROC = :szhglosa ,
        	   FEC_INICIO   = SYSDATE
         WHERE COD_CICLFACT = :lhCodCiclo
           AND COD_TIPDOCUM = :ihCodTipDocum
           AND COD_DESPACHO = :szhCodDespacho
           AND ((HOST_ID =:szhHostId) OR (1 <> :ihOpcionRango));

    if (sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de bfnActualizaRegprocImpres ",LOG01);
        return(FALSE);
    }
    else
    {
        EXEC SQL COMMIT;
        if (sqlca.sqlcode != SQLOK)
        {
            vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de bfnActualizaRegprocImpres ",LOG01);
            return(FALSE);
        }
    }

    return (1);
}
/********************Final bfnActualizaRegprocImpres ************************/

/****************************************************************************/
/*  Funcion: int ObtieneIdiomaOperadora                                     */
/*  Funcion que Obtiene el Idioma de la Operadora                           */
/****************************************************************************/

int ObtieneIdiomaOperadora(ST_INFGENERAL *sthFa_InfGeneral)
{
    sprintf(sthFa_InfGeneral->szIdiomaOper ,"%-1.1s\0",szhIdiomaOper);

    return(1);
}
/****************Final de ObtieneIdiomaOperadora *******************/

/****************************************************************************/
/*  Funcion: int iGetMensajesNoCiclo                                        */
/*  Funcion que Obtiene los mensajes para documentos no ciclicos            */
/****************************************************************************/

int iGetMensajesNoCiclo(ST_MENSAJES_NOCICLO * stFaMensajes_NoCiclo,long lNumProceso)
{
    int  iSqlMensNoCiclo ;

    strcpy (szModulo, "iGetMensajesNoCiclo");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    iSqlMensNoCiclo = Open_MensNoCiclo(lNumProceso);

    if(iSqlMensNoCiclo == SQLOK)
    {
        iSqlMensNoCiclo = Fetch_MensNoCiclo( stFaMensajes_NoCiclo );

        if(iSqlMensNoCiclo == SQLOK && stFaMensajes_NoCiclo->iCantLineas >= MAX_LINEAS_MENSAJES)
        {
            vDTrazasLog  (szModulo,"\t\tMensajes No Ciclo Sobrepaso Maximo Posible" ,LOG01);
            vDTrazasError(szModulo,"\t\tMensajes No Ciclo Sobrepaso Maximo Posible" ,LOG01);
            return (FALSE);
        }
    }
    if((iSqlMensNoCiclo != SQLOK) && (iSqlMensNoCiclo != SQLNOTFOUND))
    {
        vDTrazasError(szModulo, "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        vDTrazasLog(szModulo,   "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        return (FALSE);
    }
    if (!Close_MensNoCiclo()) return (FALSE);

    vDTrazasLog(szModulo,"\t====> Cantidad de Mensajes no ciclo [%d]",LOG04,stFaMensajes_NoCiclo->iCantLineas);

    return (1);
}
/************************* Fin GetMensajesNoCiclo *************************/

int Open_MensNoCiclo ( long lNumeroProc )
{
    strcpy (szModulo, "Open_MensNoCiclo");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    lhNumAbonado= lNumeroProc;

    EXEC SQL OPEN curMensNoCiclo;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curMensNoCiclo **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curMensNoCiclo **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }
    return (SQLCODE);
}/*********************** Final de Open_MensNoCiclo ***********************/

/****************************************************************************/
/* Funcion: int Fetch_MensNoCiclo                      */
/* Funcion que realiza Fetch en el cursor de curMensNoCiclo                 */
/****************************************************************************/

int Fetch_MensNoCiclo (ST_MENSAJES_NOCICLO * pstFaMensajes_NoCiclo)
{
    strcpy (szModulo, "Fetch_MensNoCiclo");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL
    FETCH curMensNoCiclo
    INTO :pstFaMensajes_NoCiclo->szMensajes ;

    if((SQLCODE == SQLOK) && (SQLCODE != SQLNOTFOUND))
        vDTrazasError(szModulo,"\t\tError en Fetch %s : %s", LOG01, szModulo, SQLERRM);
    else
        pstFaMensajes_NoCiclo->iCantLineas = sqlca.sqlerrd[2];

    return(SQLCODE);
}
/*************************** Final de Fetch_MensNoCiclo ***************************/

/****************************************************************************/
/*  Funcion: int Close_MensNoCiclo(void)                                    */
/*  Funcion que cierra el cursor de curMensNoCiclo                          */
/****************************************************************************/

int Close_MensNoCiclo(void)
{
     strcpy (szModulo, "Close_MensNoCiclo");
        vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

     EXEC SQL CLOSE curMensNoCiclo;
     if(SQLCODE != SQLOK)
     {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor curMensNoCiclo: %s",LOG01, SQLERRM);
        return FALSE;
     }
     return 1;
}
/****************Final de Close_MensNoCiclo *******************/

int BuscaMascara(DETALLEOPER *pst_MascaraOper,char *szCod_Registro,int derecha,int tipdocum)
{
   int izquierda;

    strcpy (szModulo, "BuscaMascara");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    vDTrazasLog(szModulo,"=> CODIGO[%s] Num_Registros [%d] Tipo Documento [%d] Tipo Ciclo [%d]", LOG06,szCod_Registro,derecha,tipdocum,igTipoCiclo);
    izquierda = 0;

    while( izquierda <= derecha )
    {
        if (!igTipoCiclo)
        {
            if ((tipdocum == pst_MascaraOper->iCod_tipdocum[izquierda]) &&
               ( strcmp(szCod_Registro,pst_MascaraOper->szCodRegistro[izquierda]) == 0))
            {
                vDTrazasLog(szModulo,"=> CODIGO ENCONTRADO Posicion [%d] ", LOG06,izquierda);
                return(izquierda);
            }
            izquierda++;
        }
        else
        {
            if (strcmp(szCod_Registro,pst_MascaraOper->szCodRegistro[izquierda]) == 0)
            {
                vDTrazasLog(szModulo,"=> CODIGO ENCONTRADO Posicion [%d] ", LOG06,izquierda);
                return(izquierda);
            }
            izquierda++;
        }
   }
   vDTrazasLog(szModulo,"NO ENCONTRADO ", LOG06);
   return(-1);
}
/****************Final de BuscaMascara *******************/

int BuscaCodInterfact(long lNumProceso,long lNumSecuencia,LINEACOMANDO *pst_ParamEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
        varchar szCodAplic[4];
        varchar szCodModGener[4];
    EXEC SQL END DECLARE SECTION;

    int  iCodEstadoSal;
    int  iCodEstadoEnt;
    int  iCodInterfact;

    strcpy (szModulo, "BuscaCodInterfact");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    iCodInterfact = COD_INTERFACT;
    if(lNumProceso)
    {
       EXEC SQL SELECT COD_MODGENER,COD_APLIC
            INTO :szCodModGener,:szCodAplic
            FROM FA_INTERFACT
            WHERE NUM_PROCESO =:lNumProceso;

       if (sqlca.sqlcode != SQLOK && sqlca.sqlcode == SQLNOTFOUND)
       {
           vDTrazasLog(szModulo, "Error en SELECT de FA_INTERFACT [%d]", LOG02, sqlca.sqlcode);
           return (FALSE);
       }
    }
    else
    {
       EXEC SQL SELECT DISTINCT COD_MODGENER,COD_APLIC
            INTO :szCodModGener,:szCodAplic
            FROM FA_INTERFACT
            WHERE NUM_PROCESO IN (
                SELECT NUM_PROCESO
                FROM FA_PROCIMPRESLOTE_TD
                WHERE NUM_SECUENCIAL = :lNumSecuencia
            );
       if (sqlca.sqlcode != SQLOK && sqlca.sqlcode == SQLNOTFOUND)
       {
           vDTrazasLog(szModulo, "Error en SELECT de FA_PROCIMPRESLOTE_TD [%d", LOG02, sqlca.sqlcode);
           return (FALSE);
       }
    }


    EXEC SQL SELECT COD_ESTADOC_ENT,COD_ESTADOC_SAL
         INTO :iCodEstadoEnt,:iCodEstadoSal
         FROM FA_INTQUEUEPROC
         WHERE COD_MODGENER=:szCodModGener
         AND COD_PROCESO = :iCodInterfact
         AND COD_APLIC = :szCodAplic;

    if (sqlca.sqlcode != SQLOK && sqlca.sqlcode == SQLNOTFOUND)
    {
       vDTrazasLog(szModulo, "Error en SELECT de FA_INTQUEUEPROC [%d]", LOG02, sqlca.sqlcode);
       return (FALSE);
    }

    pst_ParamEntrada->iCodEntrada = iCodEstadoEnt;
    pst_ParamEntrada->iCodSalida  = iCodEstadoSal;

    return(1);
}
/****************Final de BuscaCodInterfact *******************/

int ChequeaInterfact(LINEACOMANDO pst_ParamEntrada)
{
    int  iCodEstaRun;
    int  iCodEstaOk;
    int  iCantProc;

    iCodEstaRun = iPROC_EST_RUN;
    iCodEstaOk  = iPROC_EST_OK;

    strcpy (szModulo, "ChequeaInterfact");
    vDTrazasLog(szModulo, "** Entrando a %s \n"
                          "\t\tNum. Proceso => [%ld]\n"
                          "\t\tCod. Estado  => [%d]\n"
                          "\t\tCod. OK      => [%d]\n"                          
                        , LOG04
                        , szModulo
                        , pst_ParamEntrada.lProceso
                        , pst_ParamEntrada.iCodEntrada
                        , iCodEstaOk);


    
    EXEC SQL SELECT COUNT(1)
               INTO :iCantProc
               FROM FA_INTERFACT
              WHERE NUM_PROCESO = :pst_ParamEntrada.lProceso
                AND COD_ESTADOC =:pst_ParamEntrada.iCodEntrada
                AND COD_ESTPROC = :iCodEstaOk;

    if (!iCantProc)
    {
        vDTrazasLog (szModulo,"\n\tnumero de proceso [%d] No esta en el estado correcto de ejecucion\n",LOG04,pst_ParamEntrada.lProceso);
        return(FALSE);
    }

    vDTrazasLog (szModulo,"\n\tEntro por numero de proceso [%d]\n",LOG04,pst_ParamEntrada.lProceso);
    
    EXEC SQL UPDATE FA_INTERFACT SET COD_ESTADOC=:pst_ParamEntrada.iCodSalida, COD_ESTPROC = :iCodEstaRun
              WHERE NUM_PROCESO = :pst_ParamEntrada.lProceso;

    if (sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog (szModulo,"Error en ejecucion de UPDATE de FA_INTERFACT [%d][%s]",LOG01,sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }
    EXEC SQL COMMIT;
    if (sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog (szModulo,"Error en ejecucion de COMMIT de FA_INTERFACT [%d][%s]",LOG01,sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }
    return(1);
}

int OpenDetArrastre ( long lCodCiclFact )
{
    strcpy (szModulo, "OpenDetArrastre");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    lhCodCilclFact= lCodCiclFact;
    strcpy (szhStrCodCliente, "09999999");

    EXEC SQL OPEN curArrastre;
    if(SQLCODE != SQLOK)
    {
      vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curArrastre **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
      vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curArrastre **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }
    return (SQLCODE);
}
/*********************** Final de OpenDetArrastre ***********************/

/****************************************************************************/
/* FUNCION : FetchDetArrastre                                               */
/****************************************************************************/

int FetchDetArrastre ( void )
{
    strcpy (szModulo, "FetchDetArrastre");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL
    FETCH curArrastre
    INTO :sthCurArrastre.lCodCliente,
         :sthCurArrastre.lNumAbonado,
         :sthCurArrastre.szCodBolsa,
         :sthCurArrastre.dValBolsa,
         :sthCurArrastre.szIndUnidad,
         :sthCurArrastre.dValArrastre,
         :sthCurArrastre.dValExpirado,
         :sthCurArrastre.dValDisponible,
         :sthCurArrastre.dValConsumo,
         :sthCurArrastre.dValResto,
         :sthCurArrastre.szLlaveArrastre;

    if((SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND))
    {
        vDTrazasError(szModulo,"\t\tError en Fetch FetchDetArrastre : %s", LOG01, SQLERRM);
        return(SQLCODE);
    }
    sthCurArrastre.iCantidadArrastre = sqlca.sqlerrd[2];
    return(SQLCODE);
}
/*************************** Final de FetchDetArrastre ***************************/

/****************************************************************************/

int CloseDetArrastre(void)
{
    strcpy (szModulo, "CloseDetArrastre");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curArrastre;
    if(SQLCODE != SQLOK)
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor Arrastre: %s",LOG01, SQLERRM);
        return FALSE;
    }
    return 1;
}
/****************Final de CloseDetArrastre *******************/

/****************************************************************************/

int CargaArrastre( long lhCodCiclFact )
{
    int  iSqlDetArrastre;
    register int i,j;
    int   rows_to_fetch  = MAX_ARRASTRE_CURSOR;
    int   rows_before    =  0;  
    int   rows_this_time = MAX_ARRASTRE_CURSOR;

    strcpy (szModulo, "CargaArrastre");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    iSqlDetArrastre = OpenDetArrastre(lhCodCiclFact);

    if(iSqlDetArrastre == SQLOK)
    {
        while(rows_this_time == rows_to_fetch)
        {
            iSqlDetArrastre = FetchDetArrastre();
            if((iSqlDetArrastre != SQLOK)&&(iSqlDetArrastre != SQLNOTFOUND))
            {
                vDTrazasError(szModulo,"\t\tError en Fetch FetchDetArrastre : %s", LOG01, SQLERRM);
                return(SQLCODE);
            }

            j=0;
            for(i=rows_before;i<sthCurArrastre.iCantidadArrastre ;i++)
            {
                sthDetArrastre.lCodCliente[i]           = sthCurArrastre.lCodCliente[j];
                sthDetArrastre.lNumAbonado[i]           = sthCurArrastre.lNumAbonado[j];
                strcpy(sthDetArrastre.szCodBolsa[i]     , sthCurArrastre.szCodBolsa[j]);
                sthDetArrastre.dValBolsa[i]             = sthCurArrastre.dValBolsa[j];
                strcpy(sthDetArrastre.szIndUnidad[i]    , sthCurArrastre.szIndUnidad[j]);
                sthDetArrastre.dValArrastre[i]          = sthCurArrastre.dValArrastre[j];
                sthDetArrastre.dValExpirado[i]          = sthCurArrastre.dValExpirado[j];
                sthDetArrastre.dValDisponible[i]        = sthCurArrastre.dValDisponible[j];
                sthDetArrastre.dValConsumo[i]           = sthCurArrastre.dValConsumo[j];
                sthDetArrastre.dValResto[i]             = sthCurArrastre.dValResto[j];
                strcpy(sthDetArrastre.szLlaveArrastre[i], sthCurArrastre.szLlaveArrastre[j]);
                j++;
            }
            sthDetArrastre.iCantidadArrastre = i;
            if(sthDetArrastre.iCantidadArrastre > MAX_ARRASTRE_ESTRUCTURA)
            {
               vDTrazasLog  (szModulo,"\t\tDetArrastre Sobrepaso Maximo Posible" ,LOG01);
               vDTrazasError(szModulo,"\t\tDetArrastre Sobrepaso Maximo Posible" ,LOG01);
               return (FALSE);
            }
            rows_this_time = sthCurArrastre.iCantidadArrastre - rows_before;
            rows_before = sthCurArrastre.iCantidadArrastre;
            vDTrazasLog(szModulo,"\t[%d]-[%d]-[%d]",LOG05,rows_this_time,rows_before,rows_to_fetch);
        }
    }
    if((iSqlDetArrastre != SQLOK) && (iSqlDetArrastre != SQLNOTFOUND))
    {
        vDTrazasError(szModulo, "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        vDTrazasLog(szModulo,   "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
      return (FALSE);
    }
    if (!CloseDetArrastre()) return (FALSE);
    return (TRUE);
}
/************************* Fin CargaArrastre *************************/

int Busca_RangoCliente(int iPosicion,int *iInicio,int *iTermino,int iFin)
{
    int iIndice;
    char szllave[17];

    iIndice = iPosicion;
    sprintf(szllave,"%s",sthDetArrastre.szLlaveArrastre[iPosicion]);
    vDTrazasLog("","Busca_RangoCliente ENTRADA \t iIndice(%d) >= 0 && *iInicio(%d) == 0  Termino=%d Fin=%d llave=[%s]\n",LOG06,iIndice, *iInicio, *iTermino,iFin,szllave);
    while(iIndice >= 0 && *iInicio == 0)
    {
        if(strcmp(szllave,sthDetArrastre.szLlaveArrastre[iIndice])==0)
        {
            sprintf(szllave,"%s",sthDetArrastre.szLlaveArrastre[iIndice]);
            iIndice --;
        }
        else   { *iInicio = iIndice+1; break; }
    }
    if(iIndice < 0) *iInicio = 0;

    iIndice = iPosicion;
    sprintf(szllave,"%s",sthDetArrastre.szLlaveArrastre[iPosicion]);
    vDTrazasLog("","Busca_RangoCliente 2\tindice=%d Inicio=%d Termino=%d Fin=%d llave=[%s]\n",LOG06,iIndice,*iInicio,*iTermino,iFin,szllave);
    while(iIndice < iFin && *iTermino == 0)
    {
        if(strcmp(szllave,sthDetArrastre.szLlaveArrastre[iIndice])==0)
        {
            sprintf(szllave,"%s",sthDetArrastre.szLlaveArrastre[iIndice]);
            iIndice ++;
        }
        else { *iTermino = iIndice-1; break; } 
    }
    if(iIndice >= iFin) *iTermino = iFin-1;

    vDTrazasLog("","Busca_RangoCliente SALIDA \tindice=%d Inicio=%d Termino=%d\n",LOG06,iIndice,iInicio,iTermino);

    return(TRUE);
}
/****************Final de Busca_RangoCliente ******************************************/

int BuscaCliente(char *szllave,int derecha)
{  int centro;
   int izquierda;

   izquierda = 0;
   while(izquierda <= derecha)
   {
        centro = (izquierda + derecha) / 2;
        if(strcmp(szllave,sthDetArrastre.szLlaveArrastre[centro])<0) {derecha = centro - 1;}
        else {
           if(strcmp(szllave,sthDetArrastre.szLlaveArrastre[centro])>0) {izquierda = centro + 1;}
           else { return(centro); }
        }
   }
   return(-1);
}
/****************Final de BuscaCliente *******************/

int busca_arrastre(char *szllave,int *iInicio,int *iTermino)
{
    int iPosicionCliente;
    int iderecha;

    iderecha = sthDetArrastre.iCantidadArrastre;
    vDTrazasLog("","busca_arrastre ENTRADA \tLlave [%s] derecha=%ld",LOG06,szllave,iderecha);
    iPosicionCliente = BuscaCliente(szllave,iderecha);

    if(iPosicionCliente != -1)
    {
        vDTrazasLog("","busca_arrastre 1\tPosicion de llave [%s] es [%d]",LOG06,szllave,iPosicionCliente);
        *iInicio=0;
        *iTermino=0;
        if(!Busca_RangoCliente(iPosicionCliente,iInicio,iTermino,iderecha))
        {
            vDTrazasLog("","busca_arrastre\tCliente [%s] sin Arrastre ",LOG03,szllave);
            return(FALSE);
        }
        vDTrazasLog("","busca_arrastre 2\tPosicion del Cliente [%s] es [%d]  Inicio=%d Termino=%d"
                      ,LOG06,szllave,iPosicionCliente, *iInicio, *iTermino);
    }
    else
    {
        vDTrazasLog("","busca_arrastre\tLlave [%s] sin Arrastre ",LOG06,szllave);
        return(FALSE);
    }
    vDTrazasLog("","busca_arrastre SALIDA \tInicio=%d Termino=%d\n",LOG06,*iInicio, *iTermino);
    return(TRUE);
}
/****************Final de busca_arrastre *******************/

int CargaFadParametros( void )
{
    register int i,j;

    strcpy (szModulo, "CargaFadParametros");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL
        SELECT COD_PARAMETRO,
               DES_PARAMETRO,
               NVL(TIP_PARAMETRO,'NUMBER'),
               NVL(VAL_NUMERICO,0),
               NVL(VAL_CARACTER,'0'),
               NVL(VAL_FECHA,SYSDATE),
               vsize(NVL(VAL_CARACTER,'0'))
         INTO :sthFadParametros
         FROM FAD_PARAMETROS
        WHERE COD_MODULO='FA'
        ORDER BY COD_MODULO,COD_PARAMETRO;

    if(((sqlca.sqlcode != SQLOK) && (sqlca.sqlcode != SQLNOTFOUND)) || (sqlca.sqlerrd[2]==0))
    {
       vDTrazasLog(szModulo, "Error en SELECT de FAD_PARAMETROS [%d]", LOG02, sqlca.sqlcode);
       return (FALSE);
    }

    for( i = 1;i <= sqlca.sqlerrd[2];i++)
    {
      j = sthFadParametros.cod_parametro[sqlca.sqlerrd[2]-i];
      sthFadParametros.cod_parametro[j] = sthFadParametros.cod_parametro[sqlca.sqlerrd[2]-i];
      strcpy(sthFadParametros.des_parametro[j], sthFadParametros.des_parametro[sqlca.sqlerrd[2]-i]);
      strcpy(sthFadParametros.tip_parametro[j], sthFadParametros.tip_parametro[sqlca.sqlerrd[2]-i]);
      sthFadParametros.val_numerico[j] = sthFadParametros.val_numerico[sqlca.sqlerrd[2]-i];
      strcpy(sthFadParametros.val_caracter[j], sthFadParametros.val_caracter[sqlca.sqlerrd[2]-i]);
      strcpy(sthFadParametros.val_fecha[j], sthFadParametros.val_fecha[sqlca.sqlerrd[2]-i]);
      sthFadParametros.val_cantidad[j] = sthFadParametros.val_cantidad[sqlca.sqlerrd[2]-i];

      sthFadParametros.cod_parametro[sqlca.sqlerrd[2]-i] = 0;
      memset(sthFadParametros.des_parametro[sqlca.sqlerrd[2]-i],0,sizeof(sthFadParametros.des_parametro[sqlca.sqlerrd[2]-i]));
      memset(sthFadParametros.tip_parametro[sqlca.sqlerrd[2]-i],0,sizeof(sthFadParametros.tip_parametro[sqlca.sqlerrd[2]-i]));
      sthFadParametros.val_numerico[sqlca.sqlerrd[2]-i] = 0;
      memset(sthFadParametros.val_caracter[sqlca.sqlerrd[2]-i],0,sizeof(sthFadParametros.val_caracter[sqlca.sqlerrd[2]-i]));
      memset(sthFadParametros.val_fecha[sqlca.sqlerrd[2]-i],0,sizeof(sthFadParametros.val_fecha[sqlca.sqlerrd[2]-i]));
      sthFadParametros.val_cantidad[sqlca.sqlerrd[2]-i] = 0;
    }
    return(TRUE);
}

int GargaGedParametros( void )
{
 
    strcpy (szModulo, "GargaGedParametros");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL
    SELECT NVL(A.VAL_PARAMETRO,'HH24MISS'),
           NVL(B.VAL_PARAMETRO,'DDMMYYYY'),
           SUBSTR(C.VAL_PARAMETRO,1,5) ,
           D.VAL_PARAMETRO,
           E.COD_ABONOCEL,
           F.VAL_PARAMETRO
      INTO :szformato_hora,:szformato_fecha,:szhIdiomaOper,:szNumDecimal,:iCodAbonoCel,
           :szAplica_Cod_Autorizacion
      FROM GED_PARAMETROS A,GED_PARAMETROS B,GED_PARAMETROS C,GED_PARAMETROS D, FA_DATOSGENER E,
           GED_PARAMETROS F
     WHERE A.COD_MODULO = 'GE'   AND A.COD_PRODUCTO=1
       AND A.NOM_PARAMETRO ='FORMATO_SEL20'
       AND B.COD_MODULO= 'GE'   AND B.COD_PRODUCTO=1
       AND B.NOM_PARAMETRO ='FORMATO_SEL6'
       AND C.COD_MODULO= 'GE'   AND C.COD_PRODUCTO=1
       AND C.NOM_PARAMETRO ='IDIOMA_LOCAL'
       AND D.COD_MODULO= 'GE'   AND D.COD_PRODUCTO=1
       AND D.NOM_PARAMETRO ='NUM_DECIMAL'
       AND F.NOM_PARAMETRO = 'APLICA_CODAUTORIZA'
       AND F.COD_MODULO = 'FA'
       AND F.COD_PRODUCTO = 1;


    if (sqlca.sqlcode != SQLOK )
    {
        vDTrazasLog(szModulo, "Error en SELECT de GED_PARAMETROS [%d]", LOG02, sqlca.sqlcode);
        return (FALSE);
    }
    return (TRUE);
}

/*Modificacisn Proyecto Ecu-05002 Codigo de Autorizacisn.
  Se crea funcion szfnObtieneCod_autorizacion que es llamada cuando aplica Codigo Autorizaicon. Esta funcion
  rescata el valor del codigo de autorizacion y dejarlo disponible para imprimirlo en el documento.
  Se debe diferenciar entre los documentos ciclicos y los no ciclicos
*/

int szfnObtieneCod_autorizacion (LINEACOMANDO * ParametrosEntrada)
{
    EXEC SQL BEGIN DECLARE SECTION;
        long    lhCodCiclFact;
        char    szhCodAutorizacion[11];EXEC SQL VAR szhCodAutorizacion IS STRING(11);
        char    szhFecVencimiento [10];EXEC SQL VAR szhFecVencimiento  IS STRING(10);
    EXEC SQL END DECLARE SECTION;


    strcpy (szModulo, "ObtieneCod_autorizacion");
    vDTrazasLog(szModulo,"\tEntrando a [%s] ",LOG04,szModulo);

    if (ParametrosEntrada->lCodCiclFact)
    {
        lhCodCiclFact = ParametrosEntrada->lCodCiclFact;

        EXEC SQL
            SELECT
                A.COD_AUTORIZACION,
                NVL((TO_CHAR(A.FEC_TERMINO,'YYYYMMDD')),' ')
            INTO
                :szhCodAutorizacion,
                :szhFecVencimiento
            FROM
                AL_AUTORIZACION_FOLIO_TD A,
                FA_CICLFACT B,
                GED_CODIGOS C
            WHERE
                B.COD_CICLFACT = :lhCodCiclFact
                AND B.FEC_EMISION BETWEEN A.FEC_DESDE AND A.FEC_TERMINO
                AND C.COD_MODULO= 'AL'
                AND C.NOM_TABLA = 'AL_AUTORIZACION_FOLIO_TD'
                AND A.COD_SISTEMA = C.COD_VALOR;

        if (sqlca.sqlcode != SQLOK )
        {
            vDTrazasLog(szModulo, "Error en SELECT de ObtieneCod_autorizacion [%d]", LOG02, sqlca.sqlcode);
            return (FALSE);
        }

        strcpy(stAutorizFolio.szCodAutorizacion,szhCodAutorizacion);
        strcpy(stAutorizFolio.szFechaVencimiento,szhFecVencimiento);

        return (TRUE);
    }
    else
    {
        EXEC SQL
            SELECT
                A.COD_AUTORIZACION,
                NVL((TO_CHAR(A.FEC_TERMINO,'YYYYMMDD')),' ')
            INTO
                :szhCodAutorizacion,
                :szhFecVencimiento
            FROM
                AL_AUTORIZACION_FOLIO_TD A
            WHERE
                SYSDATE BETWEEN A.FEC_DESDE AND A.FEC_TERMINO;

        if (sqlca.sqlcode != SQLOK )
        {
            vDTrazasLog(szModulo, "Else: Error en SELECT de ObtieneCod_autorizacion [%d]", LOG02, sqlca.sqlcode);
            return (FALSE);
        }

        strcpy(stAutorizFolio.szCodAutorizacion,szhCodAutorizacion);
        strcpy(stAutorizFolio.szFechaVencimiento,szhFecVencimiento);

        return (TRUE);

    }
}

/****************************************************************************************/
/* FUNCION : OpenFactDocuClie                                                           */
/* DESCRIPCION : Prepara consulta sobre Tabla FA_FACTDOCU con los documentos a Imprimir */
/****************************************************************************************/
int OpenFactDocuClie (LINEACOMANDO *ParEnt)
{
    char  szTabla1    [50]    ="";
    char  szTabla2    [50]    ="";
    char  szTabla3    [350]   ="";  
    char  szCadenaSQL [2500]  ="";  

    EXEC SQL BEGIN DECLARE SECTION;
        int   ihCodTipDocum;
        char  *szhCodDespacho;  
        int   ihCodSalida;
        long  lhProceso;        
        int   ihCodEstProc;
        int   ihOpcionRango;
        long  lhCodClienteIni;
        long  lhCodClienteFin;
    EXEC SQL END DECLARE SECTION;

    ihCodTipDocum=ParEnt->iCodTipDocum ;    
    szhCodDespacho=ParEnt->szCodDespacho;   
    ihCodSalida = ParEnt->iCodSalida;       
    lhProceso = ParEnt->lProceso;           

    strcpy (szModulo, "OpenFactDocuClie");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    if (!ParEnt->iTipoCiclo)
    {
        sprintf(szTabla1,"FA_FACTDOCU_%ld",ParEnt->lCodCiclFact);
        sprintf(szTabla2,"FA_FACTCLIE_%ld",ParEnt->lCodCiclFact);

        sprintf(szCadenaSQL,"SELECT A.ROWID,"
                        "\n A.IND_ORDENTOTAL,"
                        "\n A.COD_CLIENTE,"
                        "\n NVL(A.NUM_CTC,0),"
                        "\n TO_CHAR(A.FEC_EMISION,'YYYYMMDD'),"
                        "\n TO_CHAR(NVL(A.FEC_VENCIMIE,SYSDATE),'YYYYMMDDHH24MISS'),"
                        "\n NVL(A.COD_DESPACHO,'DESNO'),"
                        "\n NVL(D.NOM_HEADER,' '),"
                        "\n A.COD_TIPDOCUM,"
                        "\n A.NUM_FOLIO,"
                        "\n C.COD_GENARCH,"
                        "\n C.COD_PRIORIDAD,"
                        "\n A.TOT_FACTURA,"
                        "\n NVL(B.NUM_IDENTTRIB,''),"
                        "\n B.NOM_CLIENTE||' '||B.NOM_APECLIEN1||' '||B.NOM_APECLIEN2,"
                        "\n A.TOT_CARGOSME,"
                        "\n NVL(A.IMP_SALDOANT,0),"
                        "\n A.TOT_PAGAR,"
                        "\n DECODE(B.IND_DEBITO,'A','1','0'),"
                        "\n A.TOT_CUOTAS,"
                        "\n NVL(TRIM(B.COD_IDIOMA),'1'),"  
                        "\n A.NUM_PROCESO,"
                        "\n A.PREF_PLAZA," 
                        "\n A.COD_OPERADORA,"
                        "\n A.COD_PLAZA,"
                        "\n A.COD_OFICINA,"
                        "\n A.COD_VENDEDOR,"
                        "\n A.NOM_USUARORA,"
                        "\n E.COD_OPERPLAZA,"
                        "\n A.PREF_PLAZA, "  
                        "\n A.COD_MONEDAIMP, "  
                        "\n NVL(A.IMP_CONVERSION,1), " 
                        "\n NVL(A.NUM_SECUREL,0), "   
                        "\n NVL(A.LETRAREL,' '), "              
                        "\n NVL(A.COD_TIPDOCUMREL,0), "
                        "\n NVL(A.COD_VENDEDOR_AGENTEREL,0), "
                        "\n NVL(A.COD_CENTRREL,0), "          
                        "\n NVL(A.NUM_VENTA,0), "             
                        "\n NVL(A.COD_SEGMENTACION,' '), "    
                        "\n A.NOM_EMAIL, "                    
                        "\n NVL(B.COD_TIPIDTRIB,'00'), "      
                        "\n TO_CHAR(FEC_EMISION,'DD-MM-YYYY HH24:MI:SS'), " 
                        "\n TO_CHAR(A.FEC_ULTMOD,'DD-MM-YYYY HH24:MI:SS'), "
                        "\n A.CONT_TECNICO, "                               
                        "\n A.RESOLUCION, "                          
                        "\n A.FEC_RESOLUCION, "                      
                        "\n A.SERIE, "                               
                        "\n NVL(A.ETIQUETA,' '), "                            
                        "\n NVL(A.RAN_DESDE,0), "                           
                        "\n NVL(A.RAN_HASTA,0), "
                        "\n NVL(A.COD_TIPOLOGIA,' '), "       /* P-MIX-09003 141767 */
                        "\n NVL(A.COD_AREAIMPUTABLE,' '), "   /* P-MIX-09003 141767 */
                        "\n NVL(A.COD_AREASOLICITANTE,' ') "  /* P-MIX-09003 141767 */                        
                    "\nFROM %s A,"
                        "\n %s B,"
                        "\n FA_CODESPACHO C,"
                        "\n FA_PARGENARCH D,"
                        "\n GE_OPERPLAZA_TD E " 
                   "\nWHERE A.TOT_FACTURA         >= 0"
                    "\n AND A.COD_CLIENTE   >= 0"
                    "\n AND A.NUM_FOLIO     >= 0"
                    "\n AND A.IND_SUPERTEL   = 0"
                    "\n AND A.IND_ANULADA    = 0"
                    "\n AND A.IND_FACTUR     = 1"
                    "\n AND A.IND_IMPRESA    = 0"
                    "\n AND A.COD_TIPDOCUM   = :ihCodTipDocum"
                    "\n AND A.COD_DESPACHO   = :szhCodDespacho"
                    "\n AND B.IND_ORDENTOTAL = A.IND_ORDENTOTAL"
                    "\n AND C.COD_DESPACHO   = NVL(A.COD_DESPACHO,'DESNO')"
                    "\n AND D.COD_GENARCH(+) = C.COD_GENARCH"
                    "\n AND A.COD_OPERADORA  = E.COD_OPERADORA_SCL" 
                    "\n AND A.COD_PLAZA      = E.COD_PLAZA"
                    "\n AND ((A.COD_CLIENTE BETWEEN :lhCodClienteIni AND :lhCodClienteFin) OR (1 <> :ihOpcionRango))"
                "\nORDER BY"
                        "\n A.COD_TIPDOCUM,"
                        "\n C.COD_GENARCH,"
                        "\n A.COD_DESPACHO,"
                        "\n A.COD_CLIENTE,"
                        "\n A.IND_ORDENTOTAL"
            ,szTabla1
            ,szTabla2);
    }
    else
    {
        sprintf(szTabla1,"FA_FACTDOCU_NOCICLO");
        sprintf(szTabla2,"FA_FACTCLIE_NOCICLO");
        sprintf(szTabla3,"(SELECT NUM_PROCESO FROM FA_INTERFACT "
                            "\n WHERE COD_ESTADOC=:ihCodSalida AND COD_ESTPROC=:ihCodEstProd "
                            "\n AND NUM_PROCESO = :lhProceso )"
                            ); 

        sprintf(szCadenaSQL,"SELECT"
                         "\n A.ROWID,"
                         "\n A.IND_ORDENTOTAL,"
                         "\n A.COD_CLIENTE,"
                         "\n NVL(A.NUM_CTC,0),"
                         "\n TO_CHAR(A.FEC_EMISION,'YYYYMMDD'),"
                         "\n TO_CHAR(NVL(A.FEC_VENCIMIE,SYSDATE),'YYYYMMDDHH24MISS'),"
                         "\n NVL(A.COD_DESPACHO,'DESNO'),"
                         "\n NVL(D.NOM_HEADER,' '),"
                         "\n A.COD_TIPDOCUM,"
                         "\n A.NUM_FOLIO,"
                         "\n C.COD_GENARCH,"
                         "\n C.COD_PRIORIDAD,"
                         "\n A.TOT_FACTURA,"                         
                         "\n NVL(B.NUM_IDENTTRIB,''),"
                         "\n B.NOM_CLIENTE||' '||B.NOM_APECLIEN1||' '||B.NOM_APECLIEN2,"
                         "\n A.TOT_CARGOSME,"
                         "\n NVL(A.IMP_SALDOANT,0),"
                         "\n A.TOT_PAGAR,"
                         "\n DECODE(B.IND_DEBITO,'A','1','0'),"
                         "\n A.TOT_CUOTAS,"
                         "\n NVL(B.COD_IDIOMA,'1'),"
                         "\n A.NUM_PROCESO,"
                         "\n A.PREF_PLAZA, " 
                         "\n A.COD_OPERADORA,"
                         "\n A.COD_PLAZA,"
                         "\n A.COD_OFICINA,"
                         "\n A.COD_VENDEDOR,"
                         "\n A.NOM_USUARORA,"
                         "\n F.COD_OPERPLAZA,"
                         "\n A.PREF_PLAZA, "                           
                         "\n A.COD_MONEDAIMP, "
                         "\n NVL(A.IMP_CONVERSION,1), " 
                         "\n NVL(A.NUM_SECUREL,0), "    
                         "\n NVL(A.LETRAREL,' '), "      
                         "\n NVL(A.COD_TIPDOCUMREL,0), " 
                         "\n NVL(A.COD_VENDEDOR_AGENTEREL,0), "
                         "\n NVL(A.COD_CENTRREL,0), "          
                         "\n NVL(A.NUM_VENTA,0), "             
                         "\n NVL(A.COD_SEGMENTACION,' '), "    
                         "\n A.NOM_EMAIL, "                    
                         "\n NVL(B.COD_TIPIDTRIB,'00'), "      
                         "\n TO_CHAR(FEC_EMISION,'DD-MM-YYYY HH24:MI:SS'), "
                         "\n TO_CHAR(A.FEC_ULTMOD,'DD-MM-YYYY HH24:MI:SS'), "
                         "\n A.CONT_TECNICO, "                               
                         "\n A.RESOLUCION, "                            
                         "\n A.FEC_RESOLUCION, "                        
                         "\n A.SERIE, "                                 
                         "\n NVL(A.ETIQUETA,' '), "
                         "\n NVL(A.RAN_DESDE,0), "                             
                         "\n NVL(A.RAN_HASTA,0), "
                         "\n NVL(A.COD_TIPOLOGIA,' '), "       /* P-MIX-09003 141767 */
                         "\n NVL(A.COD_AREAIMPUTABLE,' '), "   /* P-MIX-09003 141767 */
                         "\n NVL(A.COD_AREASOLICITANTE,' ') "  /* P-MIX-09003 141767 */
                 "\nFROM"
                         "\n %s A,"
                         "\n %s B,"
                         "\n FA_CODESPACHO C,"
                         "\n FA_PARGENARCH D,"
                         "\n %s E,"
                         "\n GE_OPERPLAZA_TD F "
                "\nWHERE"
                         "\n A.NUM_PROCESO = E.NUM_PROCESO"
                         "\n AND   B.IND_ORDENTOTAL = A.IND_ORDENTOTAL"
                         "\n AND   C.COD_DESPACHO   = NVL(A.COD_DESPACHO,'DESNO')"
                         "\n AND   D.COD_GENARCH(+) = C.COD_GENARCH"
                         "\n AND   A.COD_OPERADORA  = F.COD_OPERADORA_SCL"
                         "\n AND   A.COD_PLAZA      = F.COD_PLAZA"
                 "\nORDER BY"
                         "\n A.COD_TIPDOCUM,"
                         "\n C.COD_GENARCH,"
                         "\n A.COD_DESPACHO,"
                         "\n A.COD_CLIENTE,"
                         "\n A.IND_ORDENTOTAL"
             ,szTabla1
             ,szTabla2
             ,szTabla3);

    }
    vDTrazasLog( szModulo,"=> query curFactDocu2 (\n%s\n)",LOG05,szCadenaSQL);

    EXEC SQL PREPARE sql_Facturas_DetLlam FROM :szCadenaSQL;
    if (sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog (szModulo, "Error en PREPARE sql_Facturas_DetLlam. Error [%d][%s]"
                             ,LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }

    EXEC SQL DECLARE curFactDocu2 CURSOR FOR sql_Facturas_DetLlam;
    if (sqlca.sqlcode < SQLOK)
    {
        vDTrazasLog (szModulo, "Error en DECLARE. curFactDocu2. Error [%d][%s]"
                             , LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }

    if (!ParEnt->iTipoCiclo)
    {
        ihOpcionRango=igOpcionRango;
        lhCodClienteIni=lgCodClienteIni;
        lhCodClienteFin=lgCodClienteFin;

        vDTrazasLog (szModulo, "** ihCodTipDocum   [%d]"
                               "** szhCodDespacho  [%s]"
                               "** lhCodClienteIni [%ld]"
                               "** lhCodClienteFin [%ld]"
                               "** ihOpcionRango   [%d]"
                               ,LOG03,ihCodTipDocum,szhCodDespacho
                               ,lhCodClienteIni,lhCodClienteFin,ihOpcionRango);

        EXEC SQL OPEN curFactDocu2 USING :ihCodTipDocum, :szhCodDespacho, :lhCodClienteIni, :lhCodClienteFin, :ihOpcionRango ;
    }
    else
    {
        ihCodEstProc=iPROC_EST_RUN;
        
        vDTrazasLog( szModulo,"\n\n\t CodSalida : [%d] "
                              "\n\t   EstProd   : [%d] "
                              "\n\t   Proceso   : [%ld] "
                             ,LOG05,ihCodSalida,ihCodEstProc,lhProceso);        
        
        EXEC SQL OPEN curFactDocu2 USING :ihCodSalida, :ihCodEstProc, :lhProceso;
    }
    if(sqlca.sqlcode < SQLOK)
    {
        vDTrazasLog (szModulo, "Error en OPEN curFactDocu2. Error [%i][%s]",LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return(FALSE);
    }
    return (TRUE);

}
/**************************** Final iOpenFactDocuClie ****************************/

int FetchFactDocuClie( int * iPaso, int * iLeidos)
{
    register int i;

    EXEC SQL BEGIN DECLARE SECTION;
         static char    szhRowid              [BUFF_CLIENTE] [19];
         static long    lhIndOrdenTotal       [BUFF_CLIENTE]     ;
         static long    lhCodCliente          [BUFF_CLIENTE]     ;
         static char    szhNumCtc             [BUFF_CLIENTE] [13];
         static char    szhFecEmision         [BUFF_CLIENTE] [9] ;
         static char    szhFecVencimie        [BUFF_CLIENTE] [15];
         static char    szhCodDespacho        [BUFF_CLIENTE] [6] ;
         static char    szhNomHeader          [BUFF_CLIENTE] [6] ;
         static int     ihCodTipDocum         [BUFF_CLIENTE]     ;
         static long    lhNum_Folio           [BUFF_CLIENTE]     ;
         static char    szhCodGenArch         [BUFF_CLIENTE] [3] ;
         static int     ihCodPrioridad        [BUFF_CLIENTE]     ;
         static double  dhTotFactura          [BUFF_CLIENTE]     ;
         static char    szhRut_Cliente        [BUFF_CLIENTE] [21];
         static char    szhNom_Cliente        [BUFF_CLIENTE] [93];
         static double  dhTotCargosMes        [BUFF_CLIENTE]     ;
         static double  dhImpSaldoAnt         [BUFF_CLIENTE]     ;
         static double  dhTotPagar            [BUFF_CLIENTE]     ;
         static char    szhIndDebito          [BUFF_CLIENTE] [20];
         static double  dhTotCuotas           [BUFF_CLIENTE]     ;
         static char    szhCodIdioma          [BUFF_CLIENTE] [6] ;
         static long    lhNumProceso          [BUFF_CLIENTE]     ;
         static char    szhPrefPlaza          [BUFF_CLIENTE][25+1];
         static char    szhCodOperadora       [BUFF_CLIENTE] [6] ;
         static char    szhCodPlaza           [BUFF_CLIENTE] [6] ;
         static char    szhCodOficina         [BUFF_CLIENTE] [3] ;
         static long    lhCodVendedor         [BUFF_CLIENTE]     ;
         static char    szhNomUsuarora        [BUFF_CLIENTE] [31];
         static int     ihCodOperPlaza        [BUFF_CLIENTE]     ;
         static char    szhPrefPlaza_l10      [BUFF_CLIENTE][25+1];
         static char    szhCodMonedaImp       [BUFF_CLIENTE] [4] ; 
         static double  dhImpConversion       [BUFF_CLIENTE]     ; 
         static long    lhNumSecuRel          [BUFF_CLIENTE]     ;    
         static char    szhLetraRel           [BUFF_CLIENTE] [2] ; 
         static int     ihCodTipDocumRel      [BUFF_CLIENTE]     ;    
         static long    lhCodVendedorAgRel    [BUFF_CLIENTE]     ;    
         static long    lhCodCentrRel         [BUFF_CLIENTE]     ;    
         static long    lhNumVenta            [BUFF_CLIENTE]     ;    
         static char    szhCodSegmentacion    [BUFF_CLIENTE] [6] ; 
         static char    szhNomEmail           [BUFF_CLIENTE] [71]; 
         static char    szhCodIdent           [BUFF_CLIENTE] [3] ;  
         static char    szhFecEmi             [BUFF_CLIENTE] [20]; 
         static char    szhFecUltMod          [BUFF_CLIENTE] [20]; 
         static char    szhContTecnico        [BUFF_CLIENTE] [41];    
         static char    szhResolucion         [BUFF_CLIENTE] [25+1];
         static char    szhFecResolucion      [BUFF_CLIENTE] [10+1];
         static char    szhSerie              [BUFF_CLIENTE] [10+1];
         static char    szhEtiqueta           [BUFF_CLIENTE] [10+1];
         static char    szhCodTipologia       [BUFF_CLIENTE]  [5+1]; /* P-MIX-09003 141767 */
         static char    szhCodAreaImputable   [BUFF_CLIENTE]  [5+1]; /* P-MIX-09003 141767 */
         static char    szhCodAreaSolicitante [BUFF_CLIENTE]  [5+1]; /* P-MIX-09003 141767 */
         static long    lhRanDesde            [BUFF_CLIENTE]       ;
         static long    lhRanHasta            [BUFF_CLIENTE]       ;
         short          i_hIndLetraRel        [BUFF_CLIENTE]       ;
    EXEC SQL END DECLARE SECTION;

    memset(szhRowid             ,0,sizeof( szhRowid             ));
    memset(lhIndOrdenTotal      ,0,sizeof( lhIndOrdenTotal      ));
    memset(lhCodCliente         ,0,sizeof( lhCodCliente         ));
    memset(szhNumCtc            ,0,sizeof( szhNumCtc            ));
    memset(szhFecEmision        ,0,sizeof( szhFecEmision        ));
    memset(szhFecVencimie       ,0,sizeof( szhFecVencimie       ));
    memset(szhCodDespacho       ,0,sizeof( szhCodDespacho       ));
    memset(szhNomHeader         ,0,sizeof( szhNomHeader         ));
    memset(ihCodTipDocum        ,0,sizeof( ihCodTipDocum        ));
    memset(lhNum_Folio          ,0,sizeof( lhNum_Folio          ));
    memset(szhCodGenArch        ,0,sizeof( szhCodGenArch        ));
    memset(ihCodPrioridad       ,0,sizeof( ihCodPrioridad       ));
    memset(dhTotFactura         ,0,sizeof( dhTotFactura         ));
    memset(szhRut_Cliente       ,0,sizeof( szhRut_Cliente       ));
    memset(szhNom_Cliente       ,0,sizeof( szhNom_Cliente       ));
    memset(dhTotCargosMes       ,0,sizeof( dhTotCargosMes       ));
    memset(dhImpSaldoAnt        ,0,sizeof( dhImpSaldoAnt        ));
    memset(dhTotPagar           ,0,sizeof( dhTotPagar           ));
    memset(szhIndDebito         ,0,sizeof( szhIndDebito         ));
    memset(dhTotCuotas          ,0,sizeof( dhTotCuotas          ));
    memset(szhCodIdioma         ,0,sizeof( szhCodIdioma         ));
    memset(lhNumProceso         ,0,sizeof( lhNumProceso         ));
    memset(szhPrefPlaza         ,0,sizeof( szhPrefPlaza         ));
    memset(szhCodOperadora      ,0,sizeof( szhCodOperadora      ));
    memset(szhCodPlaza          ,0,sizeof( szhCodPlaza          ));
    memset(szhCodOficina        ,0,sizeof( szhCodOficina        ));
    memset(lhCodVendedor        ,0,sizeof( lhCodVendedor        ));
    memset(szhNomUsuarora       ,0,sizeof( szhNomUsuarora       ));
    memset(ihCodOperPlaza       ,0,sizeof( ihCodOperPlaza       ));
    memset(szhPrefPlaza_l10     ,0,sizeof( szhPrefPlaza_l10     ));
    memset(szhCodMonedaImp      ,0,sizeof( szhCodMonedaImp      ));
    memset(dhImpConversion      ,0,sizeof( dhImpConversion      ));
    memset(lhNumSecuRel         ,0,sizeof( lhNumSecuRel       ));
    memset(szhLetraRel          ,0,sizeof( szhLetraRel        ));
    memset(ihCodTipDocumRel     ,0,sizeof( ihCodTipDocumRel   ));
    memset(lhCodVendedorAgRel   ,0,sizeof( lhCodVendedorAgRel ));
    memset(lhCodCentrRel        ,0,sizeof( lhCodCentrRel      ));
    memset(lhNumVenta           ,0,sizeof( lhNumVenta         ));
    memset(szhCodSegmentacion   ,0,sizeof( szhCodSegmentacion ));
    memset(szhNomEmail          ,0,sizeof( szhNomEmail        ));
    memset(szhCodIdent          ,0,sizeof( szhCodIdent        ));
    memset(szhFecEmi            ,0,sizeof( szhFecEmi          ));
    memset(szhFecUltMod         ,0,sizeof( szhFecUltMod       ));
    memset(szhContTecnico       ,0,sizeof( szhContTecnico     ));
    memset(szhResolucion        ,0,sizeof( szhResolucion      )); 
    memset(szhFecResolucion     ,0,sizeof( szhFecResolucion   )); 
    memset(szhSerie             ,0,sizeof( szhSerie           )); 
    memset(szhEtiqueta          ,0,sizeof( szhEtiqueta        )); 
    memset(szhCodTipologia      ,0,sizeof( szhCodTipologia      )); /* P-MIX-09003 141767 */
    memset(szhCodAreaImputable  ,0,sizeof( szhCodAreaImputable  )); /* P-MIX-09003 141767 */
    memset(szhCodAreaSolicitante,0,sizeof( szhCodAreaSolicitante)); /* P-MIX-09003 141767 */    
    memset(lhRanDesde           ,0,sizeof( lhRanDesde         )); 
    memset(lhRanHasta           ,0,sizeof( lhRanHasta         )); 

    strcpy (szModulo, "FetchFactDocuClie");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);
    vDTrazasLog (szModulo, "[JQH] A lanzar el FETCH...",LOG05);

    EXEC SQL FETCH curFactDocu2
    INTO    :szhRowid        ,
            :lhIndOrdenTotal ,
            :lhCodCliente    ,
            :szhNumCtc       ,            
            :szhFecEmision   ,
            :szhFecVencimie  ,
            :szhCodDespacho  ,
            :szhNomHeader    ,
            :ihCodTipDocum   ,
            :lhNum_Folio     ,
            :szhCodGenArch   ,
            :ihCodPrioridad  ,
            :dhTotFactura    ,
            :szhRut_Cliente  ,
            :szhNom_Cliente  ,
            :dhTotCargosMes  ,
            :dhImpSaldoAnt   ,
            :dhTotPagar      ,
            :szhIndDebito    ,
            :dhTotCuotas     ,
            :szhCodIdioma    ,
            :lhNumProceso    ,            
            :szhPrefPlaza    ,              
            :szhCodOperadora ,
            :szhCodPlaza     ,            
            :szhCodOficina   ,
            :lhCodVendedor   ,            
            :szhNomUsuarora  ,
            :ihCodOperPlaza  , 
            :szhPrefPlaza_l10, 
            :szhCodMonedaImp , 
            :dhImpConversion ,            
            :lhNumSecuRel    ,            
            :szhLetraRel :i_hIndLetraRel ,
            :ihCodTipDocumRel,    
            :lhCodVendedorAgRel,  
            :lhCodCentrRel   ,            
            :lhNumVenta      ,          
            :szhCodSegmentacion,  
            :szhNomEmail     ,         
            :szhCodIdent     ,     
            :szhFecEmi       ,                       
            :szhFecUltMod    ,            
            :szhContTecnico,  
            :szhResolucion,       
            :szhFecResolucion,            
            :szhSerie,          
            :szhEtiqueta,                   
            :lhRanDesde,        
            :lhRanHasta,
            :szhCodTipologia,        /* P-MIX-09003 141767 */
            :szhCodAreaImputable,    /* P-MIX-09003 141767 */
            :szhCodAreaSolicitante;  /* P-MIX-09003 141767 */
            
    if((SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND))
    {
        vDTrazasError(szModulo,"\t\tError en Fetch FetchFactDocuClie : %s", LOG01, SQLERRM);
        vDTrazasLog  (szModulo,"\t\tError en Fetch FetchFactDocuClie : %s", LOG01, SQLERRM);
        return(SQLCODE);
    }

    vDTrazasLog (szModulo, "Datos traidos: [%d]",LOG05,sqlca.sqlerrd[2]);

    if (*iLeidos == 0)
        *iLeidos = sqlca.sqlerrd[2];
    else
        *iLeidos = sqlca.sqlerrd[2] - *iPaso;

    *iPaso = sqlca.sqlerrd[2];

    for (i =0 ; i < *iLeidos; i++)
    {
        FacturaCliente[i].lIndOrdenTotal     = lhIndOrdenTotal[i];
        FacturaCliente[i].lCodCliente        = lhCodCliente[i];
        FacturaCliente[i].iCodTipDocum       = ihCodTipDocum[i];
        FacturaCliente[i].lNum_Folio         = lhNum_Folio[i];
        FacturaCliente[i].iCodPrioridad      = ihCodPrioridad[i];
        FacturaCliente[i].dTotFactura        = dhTotFactura[i];
        FacturaCliente[i].dTotCargosMes      = dhTotCargosMes[i];
        FacturaCliente[i].dImpSaldoAnt       = dhImpSaldoAnt[i];
        FacturaCliente[i].dTotPagar          = dhTotPagar[i];
        FacturaCliente[i].dTotCuotas         = dhTotCuotas[i];
        FacturaCliente[i].lNumProceso        = lhNumProceso[i];
        FacturaCliente[i].lCodVendedor       = lhCodVendedor[i];
        FacturaCliente[i].iCodOperPlaza      = ihCodOperPlaza[i];
        FacturaCliente[i].lNumSecuRel        = lhNumSecuRel[i];       
        FacturaCliente[i].iCodTipDocumRel    = ihCodTipDocumRel[i];   
        FacturaCliente[i].lCodVendedorAgRel  = lhCodVendedorAgRel[i]; 
        FacturaCliente[i].lCodCentrRel       = lhCodCentrRel[i];      
        FacturaCliente[i].lNumVenta          = lhNumVenta[i];         
        FacturaCliente[i].dImpConversion  = ((dhImpConversion[i] == 0)? 1:dhImpConversion[i]);        
        FacturaCliente[i].lRanDesde          = lhRanDesde[i];         
        FacturaCliente[i].lRanHasta          = lhRanHasta[i];                 

        strcpy(FacturaCliente[i].szIndDebito      , alltrim(szhIndDebito[i]));
        strcpy(FacturaCliente[i].szRowid          , alltrim(szhRowid[i]));
        strcpy(FacturaCliente[i].szRut_Cliente    , alltrim(szhRut_Cliente[i]));
        strcpy(FacturaCliente[i].szNombre_Clie    , alltrim(szhNom_Cliente[i]));
        strcpy(FacturaCliente[i].szNumCtc         , alltrim(szhNumCtc[i]));
        strcpy(FacturaCliente[i].szCodDespacho    , alltrim(szhCodDespacho[i]));
        strcpy(FacturaCliente[i].szNomHeader      , alltrim(szhNomHeader[i]));
        strcpy(FacturaCliente[i].szCodGenArch     , alltrim(szhCodGenArch[i]));
        strcpy(FacturaCliente[i].szCod_Idioma     , alltrim(szhCodIdioma[i]));
        strcpy(FacturaCliente[i].szFecEmision     , alltrim(szhFecEmision[i]));
        strcpy(FacturaCliente[i].szFecVencimie    , alltrim(szhFecVencimie[i]));
        strcpy(FacturaCliente[i].szPrefPlaza      , alltrim(szhPrefPlaza[i]));
        strcpy(FacturaCliente[i].szCodOperadora   , alltrim(szhCodOperadora[i]));
        strcpy(FacturaCliente[i].szCodPlaza       , alltrim(szhCodPlaza[i]));
        strcpy(FacturaCliente[i].szCod_Oficina    , alltrim(szhCodOficina[i]));
        strcpy(FacturaCliente[i].szNomUsuarora    , alltrim(szhNomUsuarora[i]));
        strcpy(FacturaCliente[i].szCodMonedaImp   , alltrim(szhCodMonedaImp[i]));
        strcpy(FacturaCliente[i].szCodSegmentacion, alltrim(szhCodSegmentacion[i]));
        strcpy(FacturaCliente[i].szNomEmail       , alltrim(szhNomEmail[i]));       
        strcpy(FacturaCliente[i].szCodIdent       , alltrim(szhCodIdent[i])); 
        strcpy(FacturaCliente[i].szFecEmi         , alltrim(szhFecEmi[i]));   
        strcpy(FacturaCliente[i].szFecUltMod      , alltrim(szhFecUltMod[i]));
        strcpy(FacturaCliente[i].szContTecnico    , alltrim(szhContTecnico[i]));
        strcpy(FacturaCliente[i].szResolucion     , alltrim(szhResolucion[i]));     
        strcpy(FacturaCliente[i].szFecResolucion  , alltrim(szhFecResolucion[i]));  
        strcpy(FacturaCliente[i].szSerie          , alltrim(szhSerie[i]));          
        strcpy(FacturaCliente[i].szEtiqueta       , alltrim(szhEtiqueta[i]));       
        strcpy(FacturaCliente[i].szCodTipologia   , alltrim(szhCodTipologia[i]));         /* P-MIX-09003 141767 */
        strcpy(FacturaCliente[i].szCodAreaImputable  , alltrim(szhCodAreaImputable[i]));  /* P-MIX-09003 141767 */
        strcpy(FacturaCliente[i].szCodAreaSolicitante, alltrim(szhCodAreaSolicitante[i]));/* P-MIX-09003 141767 */              

        if(i_hIndLetraRel[i]!=ORA_NULL)
            strcpy(FacturaCliente[i].szLetraRel   , alltrim(szhLetraRel[i]));   
    }
    return(TRUE);
}
/**************************** Final FetchFactDocuClie ****************************/

int CloseFactDocuClie (void)
{
    vDTrazasLog("", "Entro a iCloseFactDocuClie ", LOG05);
    EXEC SQL CLOSE curFactDocu2;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog ("CloseFactDocuClie", "Error en CLOSE curFactDocu2. Error [%i][%s]"
                                        , LOG00,  sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        return FALSE;
    }
    return (1);
}
/************************ Final iCloseFactDocuClie ******************************/

int OpenMinutoAdicional( void )
{
    strcpy (szModulo, "OpenMinutoAdicional");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL DECLARE curMinAdicional CURSOR FOR
                SELECT  A.COD_PLAN,
                        B.CON_CLIENTE||B.COD_THOR||B.COD_TDIR,
                        A.MTO_ADIC
                  FROM  TOL_ESTCOBRO A, TOL_AGRULLAM B
                 WHERE  A.COD_OPERADOR > ' '
                   AND  A.COD_PLAN > ' '
                   AND  A.COD_AGRULLAM = B.COD_AGRULLAM
                   AND  B.COD_LLAM = 'LOC'
                   AND  B.COD_SENTIDO= 'S'
                   AND  A.COD_TDIA = '1'
                   AND  B.CON_CLIENTE in ('HM','VI')
                   AND  B.COD_THOR in ('O','N')
                   AND  B.COD_TDIR in ('PP','PPR')
              ORDER BY  A.COD_PLAN,B.CON_CLIENTE,B.COD_THOR,B.COD_TDIR;

    EXEC SQL OPEN curMinAdicional;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curMinAdicional **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curMinAdicional **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }
    return (SQLCODE);
}
/*********************** Final de OpenMinutoAdicional***********************/
/****************************************************************************/

int FetchMinutoAdicional ( void )
{
    int i;
    EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR szhCodPlan              [MAX_MINUTOADICIONAL][6] ;
        VARCHAR szhLlaveMinutoAdicional [MAX_MINUTOADICIONAL][7] ;
        double  dhMtoAdicional          [MAX_MINUTOADICIONAL]    ;
    EXEC SQL END DECLARE SECTION;

    strcpy (szModulo, "FetchMinutoAdicional");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL
    FETCH curMinAdicional
    INTO :szhCodPlan,
         :szhLlaveMinutoAdicional,
         :dhMtoAdicional;

    if((SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND))
    {
        vDTrazasError(szModulo,"\t\tError en Fetch FetchMinutoAdicional : %s", LOG01, SQLERRM);
        return(SQLCODE);
    }

    sthMinutoAdicional.iCantidadMinutoAdicional = sqlca.sqlerrd[2];

    for (i =0 ; i < sthMinutoAdicional.iCantidadMinutoAdicional; i++)
    {
         sthMinutoAdicional.dMtoAdicional[i] = dhMtoAdicional[i];

         sprintf(sthMinutoAdicional.szCodPlan[i]             ,"%.*s\0",
                 szhCodPlan[i].len,szhCodPlan[i].arr);
         sprintf(sthMinutoAdicional.szLlaveMinutoAdicional[i],"%.*s\0",
                 szhLlaveMinutoAdicional[i].len,szhLlaveMinutoAdicional[i].arr);
    }
    return(SQLCODE);
}

/*************************** Final de FetchMinutoAdicional ***************************/
/****************************************************************************/

int CloseMinutoAdicional(void)
{
    strcpy (szModulo, "CloseMinutoAdicional");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curMinAdicional;
    if(SQLCODE != SQLOK)
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor Minuto Adicional: %s",LOG01, SQLERRM);
        return FALSE;
    }
    return TRUE;
}
/****************Final de CloseMinutoAdicional *******************/

int CargaMinutoAdicional( void )
{
     int  iSqlDetMinutoAdicional;
     int  rows_to_fetch  = MAX_MINUTOADICIONAL;
     int  rows_before    =  0;
    int  rows_this_time = MAX_MINUTOADICIONAL;

    strcpy (szModulo, "CargaMinutoAdicional");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    iSqlDetMinutoAdicional = OpenMinutoAdicional();

    if(iSqlDetMinutoAdicional == SQLOK)
    {
      while(rows_this_time == rows_to_fetch)
      {
            iSqlDetMinutoAdicional = FetchMinutoAdicional();
            if((iSqlDetMinutoAdicional != SQLOK)&&(iSqlDetMinutoAdicional != SQLNOTFOUND))
            {
                vDTrazasError(szModulo,"\t\tError en Fetch FetchMinutoAdicional : %s", LOG01, SQLERRM);
                return(SQLCODE);
            }

            sthMinutoAdicional.iCantidadMinutoAdicional = sqlca.sqlerrd[2];
            if(sthMinutoAdicional.iCantidadMinutoAdicional > MAX_MINUTOADICIONAL)
            {
               vDTrazasLog  (szModulo,"\tsthMinutoAdicional Sobrepaso Maximo Posible" ,LOG01);
               vDTrazasError(szModulo,"\tsthMinutoAdicional Sobrepaso Maximo Posible" ,LOG01);
               return (FALSE);
            }
            rows_this_time = sthMinutoAdicional.iCantidadMinutoAdicional - rows_before;
            rows_before = sthMinutoAdicional.iCantidadMinutoAdicional;
            vDTrazasLog(szModulo,"\t[%d]-[%d]-[%d]",LOG05,rows_this_time,rows_before,rows_to_fetch);
      }
    }
    if((iSqlDetMinutoAdicional != SQLOK) && (iSqlDetMinutoAdicional != SQLNOTFOUND))
    {
        vDTrazasError(szModulo,  "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        vDTrazasLog(szModulo,    "\t\t Error Oracle   [%s]",LOG01, SQLERRM);
        return (FALSE);
    }
    if (!CloseMinutoAdicional()) return (FALSE);
    return (TRUE);
}
/************************* Fin CargaMinutoAdicional *************************/

int Busca_RangoPlanes(int iPosicion,int *ihInicio,int *ihTermino,int iFin)
{
   int iIndice;
   int iInicio;
   int iTermino;
   char szllave[6];

   iIndice = iPosicion;
   iInicio = *ihInicio;
   iTermino = *ihTermino;

   sprintf(szllave,"%s",sthMinutoAdicional.szCodPlan[iPosicion]);
   while(iIndice >= 0 && iInicio == 0)
   {
        if(strcmp(szllave,sthMinutoAdicional.szCodPlan[iIndice])==0)
        {
            sprintf(szllave,"%s",sthMinutoAdicional.szCodPlan[iIndice]);
            iIndice--;
        }
        else
        {
            iInicio = iIndice+1;
        }
   }
   if(iIndice < 0) iInicio = 0;

   iIndice = iPosicion;
   sprintf(szllave,"%s",sthMinutoAdicional.szCodPlan[iPosicion]);
   while(iIndice < iFin && iTermino == 0 && iIndice > 0)
   {
       if(strcmp(szllave,sthMinutoAdicional.szCodPlan[iIndice])==0)
       {
           sprintf(szllave,"%s",sthMinutoAdicional.szCodPlan[iIndice]);
           iIndice ++;
       }
       else
       {
           iTermino = iIndice-1;
       }
   }
   if(iIndice >= iFin) iTermino = iFin-1;

   *ihInicio = iInicio;
   *ihTermino = iTermino;

   return(TRUE);
}
/****************Final de Busca_RangoPlanes ******************************************/

int BuscaEstrucPlanes(char *szllave,int iderecha)
{  int centro;
   int izquierda;

   izquierda = 0;
   while(izquierda <= iderecha)
   {
        centro = (izquierda + iderecha) / 2;
        vDTrazasLog("","\tPlan [%s]-[%s]",LOG06,szllave,sthMinutoAdicional.szCodPlan[centro]);
        if(strcmp(szllave,sthMinutoAdicional.szCodPlan[centro])<0) {iderecha = centro - 1;}
        else {
           if(strcmp(szllave,sthMinutoAdicional.szCodPlan[centro])>0) {izquierda = centro + 1;}
           else { return(centro); }
        }
   }
   return(-1);
}
/****************Final de BuscaEstrucPlanes *******************/

int BuscaValorMinuto(char *szllave,int izquierda, int derecha)
{  int centro;

   while(izquierda <= derecha)
   {
        centro = (izquierda + derecha) / 2;
        vDTrazasLog("","\tPlan [%s]-[%s]",LOG06,szllave,sthMinutoAdicional.szLlaveMinutoAdicional[centro]);
        if(strcmp(szllave,sthMinutoAdicional.szLlaveMinutoAdicional[centro])<0) {derecha = centro - 1;}
        else {
           if(strcmp(szllave,sthMinutoAdicional.szLlaveMinutoAdicional[centro])>0) {izquierda = centro + 1;}
           else { return(centro); }
        }
   }
   return(-1);
}/****************Final de BuscaValorMinuto *******************/

int buscaMinutoAdicional(char *szCodPlan,char *szllave)
{
    int iPosicionEstrucPlanes;
    int iPosicionValorMinutos;
    int derecha;
    int iInicio;
    int iTermino;

    strcpy (szModulo, "buscaMinutoAdicional");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    derecha = sthMinutoAdicional.iCantidadMinutoAdicional;
    vDTrazasLog(szModulo,"\tPlan [%s] es [%s]",LOG05,szCodPlan,szllave);
    iPosicionEstrucPlanes = BuscaEstrucPlanes(szCodPlan,derecha);
    if(iPosicionEstrucPlanes != -1)
    {
       vDTrazasLog(szModulo,"\tPlan [%s] es [%d]",LOG06,szCodPlan,iPosicionEstrucPlanes);
       iInicio=0;
       iTermino=0;
       if(!Busca_RangoPlanes(iPosicionEstrucPlanes,&iInicio,&iTermino,derecha))
       {
          return(FALSE);
       }
       vDTrazasLog(szModulo,"\tPlan [%s] Inicio [%d] Termino [%d] ", LOG06,szCodPlan,iInicio,iTermino);
       iPosicionValorMinutos = BuscaValorMinuto(szllave,iInicio,iTermino);
       if(iPosicionValorMinutos != -1)
       {
          return(iPosicionValorMinutos);
       }
    }
    return(TRUE);
}
/****************Final de busca_arrastre *******************/

int ifnCmpCodCliente(const void *cad1,const void *cad2)
{
    int rc = 0;

    return
        ( (rc = ((CODCLI *)cad1)->lCodCliente-
                ((CODCLI *)cad2)->lCodCliente) != 0)?rc:0;

}

int ifnCmpNumAbonado(const void *cad1,const void *cad2)
{
    int rc = 0;

    return
        ( (rc = ((STDETCONSUMO *)cad1)->lNumAbonado -((STDETCONSUMO *)cad2)->lNumAbonado) != 0)?rc:0;

}

/**********************************************************************************/
/*                            FUNCION : bfnCargaCodClientes                       */
/**********************************************************************************/

BOOL bfnCargaCodClientes (CODCLI **pstCodClie, int *iNumCodCientes, long lCicloFact)
{
    int          rc =0          ;
    int          iNumFilas      ;
    CODCLI_HOSTS stCodClieHost  ;
    CODCLI       *pstCodClieTemp;
    register int iCont          ;

    vDTrazasLog (szExeName,"\n\t* Carga Codigos de Clientes y sus Descripciones ", LOG06);

    *iNumCodCientes = 0;
    *pstCodClie = NULL;

    if (ifnOpenCodClientes(lCicloFact))
        return FALSE;

    while (rc != SQLNOTFOUND)
    {
        rc = bfnFetchCodClientes(&stCodClieHost,&iNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
        return FALSE;

        if (!iNumFilas)
            break;

        *pstCodClie =(CODCLI*) realloc(*pstCodClie,(int)(((*iNumCodCientes)+iNumFilas)*sizeof(CODCLI)));

        if (!*pstCodClie)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error bfnCargaCodClientes", "no se pudo reservar memoria");
            return FALSE;
        }

        pstCodClieTemp = &(*pstCodClie)[(*iNumCodCientes)];
        memset(pstCodClieTemp, 0, (int)(sizeof(CODCLI)*iNumFilas));
        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            strcpy( pstCodClieTemp[iCont].szNomApoderado    ,stCodClieHost.szNomApoderado[iCont]);
            pstCodClieTemp[iCont].lCodCliente               = stCodClieHost.lCodCliente[iCont];
            strcpy( pstCodClieTemp[iCont].szCodServicio     ,stCodClieHost.szCodServicio[iCont]);
            pstCodClieTemp[iCont].iCodSisPago               = stCodClieHost.iCodSisPago[iCont];
            strcpy( pstCodClieTemp[iCont].szCodCourrier     ,stCodClieHost.szCodCourrier[iCont]);    /* P-MIX-09003 */
            strcpy( pstCodClieTemp[iCont].szCodZonaCourrier ,stCodClieHost.szCodZonaCourrier[iCont]);/* P-MIX-09003 */
        }
        (*iNumCodCientes) += iNumFilas;

    }

    vDTrazasLog (szExeName,"\n\t\t* Codigos de Clientes cargados [%ld]", LOG06, *iNumCodCientes);

    rc = ifnCloseCodClientes();
    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error bfnCargaCodClientes", szfnORAerror ());
        return FALSE;
    }

    qsort((void*)*pstCodClie, *iNumCodCientes, sizeof(CODCLI),ifnCmpCodCliente);

    return (TRUE);
}
/***************************** Final bfnCargaCodClientes *********************/

int ifnOpenCodClientes(long lCicloFact)
{
    EXEC SQL BEGIN DECLARE SECTION;
        long    lhCicloFact;
    EXEC SQL END DECLARE SECTION;


    lhCicloFact = lCicloFact;

    vDTrazasLog (szExeName,"\n\t\t* Open=> GE_CLIENTES", LOG06);

    EXEC SQL DECLARE Cur_CodCliente CURSOR for
        SELECT DISTINCT A.COD_CLIENTE,
                NVL(A.NOM_APODERADO ,'.'),
                NVL(D.COD_SERVICIO  ,'1'),
                NVL(A.COD_SISPAGO, 1),
                NVL(B.COD_COURRIER,' '),
                NVL(B.COD_ZONACOURRIER,' ')
        /*FROM  GE_CLIENTES A, FA_CICLOCLI B, FA_CICLFACT C, FAD_IMPSERVCLIE D*/ /* P-MIX-09003 */
        FROM  GE_CLIENTES A, 
              (SELECT DISTINCT COD_CLIENTE,COD_CICLO,COD_COURRIER,COD_ZONACOURRIER
               FROM   FA_CICLOCLI
               WHERE  COD_COURRIER IS NOT NULL
               OR     COD_ZONACOURRIER IS NOT NULL) B, /* P-MIX-09003 */ 
              FA_CICLFACT C, 
              FAD_IMPSERVCLIE D        
        WHERE C.COD_CICLFACT = :lhCicloFact
        AND C.COD_CICLO = B.COD_CICLO
        AND B.COD_CLIENTE = A.COD_CLIENTE
        AND A.COD_CLIENTE = D.COD_CLIENTE(+);

    EXEC SQL OPEN Cur_CodCliente;


    if (SQLCODE != SQLOK)
        iDError (szExeName,ERR000,vInsertarIncidencia,"Open=> GE_CLIENTES",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnOpenCodClientes **********************/

BOOL bfnFetchCodClientes (CODCLI_HOSTS *pstHost,int *piNumFilas)
{ 
    EXEC SQL FETCH Cur_CodCliente
              INTO  :pstHost->lCodCliente   ,
                    :pstHost->szNomApoderado,
                    :pstHost->szCodServicio ,
                    :pstHost->iCodSisPago,
                    :pstHost->szCodCourrier,                    
                    :pstHost->szCodZonaCourrier;

    if (SQLCODE==SQLOK)
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if (SQLCODE==SQLNOTFOUND)
            *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
        else
            iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=> GE_CLIENTES", szfnORAerror ());
    return SQLCODE;
}
/***************************** Final bfnFetchCodClientes ****************/


int ifnCloseCodClientes(void)
{
    vDTrazasLog (szExeName,"\n\t\t* Open=> GE_CLIENTES", LOG06);

    EXEC SQL CLOSE Cur_CodCliente;

    if (SQLCODE != SQLOK)
       iDError (szExeName,ERR000,vInsertarIncidencia,"Close=> Cursor=> GE_CLIENTES",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnCloseCodClientes **********************/

void vfnPrintCodClientes (CODCLI *pstCodClie, int iNumCodCientes)
{
    int i = 0;

    if (stStatus.LogNivel >= LOG06)
    {
        vDTrazasLog (szExeName,"\n\t\t* Carga Tabla Codigos de Clientes [%d]", LOG06, iNumCodCientes);

        for (i=0;i<iNumCodCientes;i++)
        {
             vDTrazasLog (szExeName,"\n\t\t=> [%d]: Nombre de Apoderado  [%s]"
                                    "\n\t\t=> [%d]: Codigo de Cliente    [%ld]"
                                    "\n\t\t=> [%d]: Codigo de Servicio   [%s]"
                                    "\n\t\t=> [%d]: Codigo Pago          [%s]"
                                    ,LOG06
                                    ,i, pstCodClie[i].szNomApoderado
                                    ,i, pstCodClie[i].lCodCliente
                                    ,i, pstCodClie[i].szCodServicio
                                    ,i, pstCodClie[i].iCodSisPago);
        }

    }
}
/*************************** vfnPrintCodClientes *****************************/

/*****************************************************************************************************/
/* FUNCION : bfnFindCodCliente                                                                       */
/*****************************************************************************************************/
BOOL bfnFindCodCliente (long lCodigoCliente, CODCLI *pstCodClie, long lCodCiclFact, char *szFecEmision)
{
    EXEC SQL BEGIN DECLARE SECTION;
        long    lhCodCliente;
        char    szhNomApoderado      [40];
        char    szhCodServicio        [4];
        char    szhFecEmi            [15];
        int     ihCodSisPago             ; 
        char    szhNumIdent2       [20+1]; EXEC SQL VAR szhNumIdent2       IS STRING(20+1);
        char    szhCodCourrier     [10+1]; EXEC SQL VAR szhCodCourrier     IS STRING(10+1);
        char    szhCodZonaCourrier [10+1]; EXEC SQL VAR szhCodZonaCourrier IS STRING(10+1);                
    EXEC SQL END DECLARE SECTION;

    CODCLI  stkey;
    CODCLI  *pstAux = (CODCLI *)NULL;
    
    memset(szhNumIdent2,'\0',sizeof(szhNumIdent2));
    memset(szhCodCourrier,'\0',sizeof(szhCodCourrier));
    memset(szhCodZonaCourrier,'\0',sizeof(szhCodZonaCourrier));    

    vDTrazasLog (szExeName, "\n\t\t* Busca Codigo de Cliente "
                    "\n\t\t=> Cod.Cliente   [%ld]"
                    "\n\t\t=> Cod.CiclFact  [%ld]"
                    "\n\t\t=> Fec.Emision   [%s]"
                    , LOG05,lCodigoCliente, lCodCiclFact, szFecEmision );

    stkey.lCodCliente   = lCodigoCliente;

    if (lCodCiclFact)
    {
        if (pstCodCliente.iNumCodClientes > 0)
        { 	        	            
            if ( (pstAux = (CODCLI *)bsearch (&stkey, pstCodCliente.stTipDocum , pstCodCliente.iNumCodClientes,
                sizeof (CODCLI),ifnCmpCodCliente ))== (CODCLI *)NULL)
            {

                vDTrazasLog(szExeName, "Codigo de Cliente [%ld] no encontrado ...", LOG01, lCodigoCliente);
                return  (FALSE);
            }
            memcpy (pstCodClie, pstAux, sizeof(CODCLI));                        
        }
        else
        {
            vDTrazasLog(szExeName, "No existen datos para buscar en estructura de Clientes ...", LOG03);
        }
    }
    else
    {
        strcpy(szhFecEmi, szFecEmision);

        EXEC SQL 
             SELECT DISTINCT A.COD_CLIENTE,
                    NVL(A.NOM_APODERADO ,'.'),
                    NVL(D.COD_SERVICIO  ,'1'),
                    NVL(A.COD_SISPAGO, 1),
                    NVL(A.NUM_IDENT2,' '),      /* P-MIX-09003 */
                    NVL(E.COD_COURRIER,' '),    /* P-MIX-09003 */
                    NVL(E.COD_ZONACOURRIER,' ') /* P-MIX-09003 */
             INTO  :lhCodCliente, :szhNomApoderado, :szhCodServicio, :ihCodSisPago,
                   :szhNumIdent2, :szhCodCourrier,  :szhCodZonaCourrier 
             FROM  GE_CLIENTES A, FAD_IMPSERVCLIE D,
                   (SELECT COD_CLIENTE,COD_COURRIER,COD_ZONACOURRIER 
                    FROM FA_CICLOCLI
                    WHERE  COD_COURRIER IS NOT NULL
                    OR     COD_ZONACOURRIER IS NOT NULL) E /* P-MIX-09003 140556 */
             WHERE A.COD_CLIENTE = :lCodigoCliente
             AND   A.COD_CLIENTE = D.COD_CLIENTE(+)
             AND   TO_DATE(:szhFecEmi ,'YYYYMMDD') BETWEEN FECHA_DESDE(+) AND FECHA_HASTA(+)
             AND   A.COD_CLIENTE = E.COD_CLIENTE(+); /* P-MIX-09003 */       

        if (SQLCODE != SQLOK)
        {
            vDTrazasLog(szExeName, "\n\tSelect => Clientes (bfnFindCodCliente) Cliente [%ld] no encontrado ...", LOG01, lCodigoCliente);
            iDError (szExeName,ERR000,vInsertarIncidencia,"Select => Clientes (bfnFindCodCliente)",szfnORAerror ());
            return FALSE;
        }
        else
        {                                    
            pstCodClie->lCodCliente = lhCodCliente;
            strcpy (pstCodClie->szNomApoderado, szhNomApoderado);
            strcpy (pstCodClie->szCodServicio, szhCodServicio);
            pstCodClie->iCodSisPago = ihCodSisPago;
            strcpy (pstCodClie->szNumIdent2, szhNumIdent2);
            strcpy (pstCodClie->szCodCourrier, szhCodCourrier);
            strcpy (pstCodClie->szCodZonaCourrier, szhCodZonaCourrier);                                
                
        }
    }    
    
    return (TRUE);
}
/***************************** Final bfnFindCodCliente **********************/

/* P-MIX-09003 */
/***********************************************************************************************/
/* FUNCION : bfnFindMotivo                                                                     */
/***********************************************************************************************/
BOOL bfnFindMotivo (char *szCodTipologia, char *szCodAreaImputable, char *szCodAreaSolicitante,                    
                    char *szTipologia   , char *szAreaImputable   , char *szAreaSolicitante)
{
    EXEC SQL BEGIN DECLARE SECTION;
         char    szhCodTipologia        [5+1]; EXEC SQL VAR szhCodTipologia       IS STRING(5+1);
         char    szhCodAreaImputable    [5+1]; EXEC SQL VAR szhCodAreaImputable   IS STRING(5+1);
         char    szhCodAreaSolicitante  [5+1]; EXEC SQL VAR szhCodAreaSolicitante IS STRING(5+1);
         char    szhTipologia          [30+1]; EXEC SQL VAR szhTipologia          IS STRING(30+1);
         char    szhAreaImputable      [30+1]; EXEC SQL VAR szhAreaImputable      IS STRING(30+1);
         char    szhAreaSolicitante    [30+1]; EXEC SQL VAR szhAreaSolicitante    IS STRING(30+1);
    EXEC SQL END DECLARE SECTION;
    
    vDTrazasLog (szExeName, "\n\t\t* Parámetros entrada Motivo Documento"
                            "\n\t\t=> Cod.Tipologia        [%s]"
                            "\n\t\t=> Cod.Area Solicitante [%s]"
                            "\n\t\t=> Cod.Area Imputable   [%s]"                            
                          , LOG05
                          , szCodTipologia
                          , szCodAreaImputable
                          , szCodAreaSolicitante);    

    memset(szhCodTipologia,'\0',sizeof(szhCodTipologia));
    strcpy(szhCodTipologia,szCodTipologia);
    
    memset(szhCodAreaImputable,'\0',sizeof(szhCodAreaImputable));
    strcpy(szhCodAreaImputable,szCodAreaImputable);
    
    memset(szhCodAreaSolicitante,'\0',sizeof(szhCodAreaSolicitante));
    strcpy(szhCodAreaSolicitante,szCodAreaSolicitante);    

    vDTrazasLog (szExeName, "\n\t\t* Busca Motivo Documento"
                            "\n\t\t=> Cod.Tipologia        [%s]"
                            "\n\t\t=> Cod.Area Solicitante [%s]"
                            "\n\t\t=> Cod.Area Imputable   [%s]"                            
                          , LOG05
                          , szhCodTipologia
                          , szhCodAreaImputable
                          , szhCodAreaImputable);

    EXEC SQL            
           SELECT NVL(DES_VALOR,' ')
           INTO  :szhTipologia
           FROM   CO_CODIGOS 
           WHERE  NOM_TABLA   = 'CO_AJUSTES' 
           AND    NOM_COLUMNA = 'COD_TIPOLOGIA'
           AND    COD_VALOR   = :szhCodTipologia;

    if ( SQLCODE != SQLOK)
    {
         vDTrazasLog(szExeName, "\n\tSelect => CO_CODIGOS (bfnFindMotivo) Cod.Tipologia [%s] no encontrado ..."
                              , LOG03, szhCodTipologia);
         strcpy(szTipologia," ");
    }
    else
    {    
         vDTrazasLog (szExeName, "\n\t\t* Busca Motivo Tipologia "
                                 "\n\t\t=> Tipologia [%s]"
                               , LOG05, szhTipologia );                        	                                
         strcpy (szTipologia, szhTipologia);         
    }
    
    EXEC SQL            
           SELECT NVL(DES_VALOR,' ')
           INTO  :szhAreaImputable
           FROM   CO_CODIGOS 
           WHERE  NOM_TABLA   = 'CO_AJUSTES' 
           AND    NOM_COLUMNA = 'COD_AREAIMPUTABLE'
           AND    COD_VALOR   = :szhCodAreaImputable;

    if ( SQLCODE != SQLOK)
    {
         vDTrazasLog(szExeName, "\n\tSelect => CO_CODIGOS (bfnFindMotivo) Cod.Area Imputable [%s] no encontrado ..."
                              , LOG03, szhCodAreaImputable);
         strcpy(szAreaImputable," ");
    }
    else
    {    
         vDTrazasLog (szExeName, "\n\t\t* Busca Motivo Area Imputable "
                                 "\n\t\t=> Area Imputable [%s]"
                               , LOG05, szhAreaImputable );                        	                                
         strcpy (szAreaImputable, szhAreaImputable);         
    }    
    
    EXEC SQL            
           SELECT NVL(DES_VALOR,' ')
           INTO  :szhAreaSolicitante
           FROM   CO_CODIGOS 
           WHERE  NOM_TABLA   = 'CO_AJUSTES' 
           AND    NOM_COLUMNA = 'COD_AREASOLICITANTE'
           AND    COD_VALOR   = :szhCodAreaSolicitante;

    if ( SQLCODE != SQLOK)
    {
         vDTrazasLog(szExeName, "\n\tSelect => CO_CODIGOS (bfnFindMotivo) Cod.Area Solicitante [%s] no encontrado ..."
                              , LOG03, szhCodAreaSolicitante);
         strcpy(szAreaSolicitante," ");
    }
    else
    {    
         vDTrazasLog (szExeName, "\n\t\t* Busca Motivo Area Solicitante "
                                 "\n\t\t=> Area Solicitante [%s]"
                               , LOG05, szhAreaSolicitante );                        	                                
         strcpy (szAreaSolicitante, szhAreaSolicitante);         
    }    
    
    return (TRUE);
}
/******************************** Final bfnFindMotivo *************************/

/*****************************************************************************************************/
/* FUNCION : bfnFindCodPrestacionAbon                                                                */
/*****************************************************************************************************/
BOOL bfnFindCodPrestacionAbon (long lNumAbonado, char *szCodPrestacionAbon)
{
    EXEC SQL BEGIN DECLARE SECTION;
         long    lhNumAbonado;
         char    szhCodPrestacionAbon [5+1]; EXEC SQL VAR szhCodPrestacionAbon IS STRING(5+1);
    EXEC SQL END DECLARE SECTION;
    
    memset(szhCodPrestacionAbon,'\0',sizeof(szhCodPrestacionAbon));    

    vDTrazasLog (szExeName, "\n\t\t* Busca Codigo Prestacion Abonado "
                    "\n\t\t=> Num. Abonado   [%ld]"
                    , LOG05,lNumAbonado );

    lhNumAbonado = lNumAbonado;

    EXEC SQL 
           SELECT NVL(A.COD_PRESTACION ,' ')
           INTO   :szhCodPrestacionAbon
           FROM   GA_ABOCEL A
           WHERE  A.NUM_ABONADO = :lhNumAbonado;

    if ( SQLCODE != SQLOK)
    {
         vDTrazasLog(szExeName, "\n\tSelect => Abonados (bfnFindCodPrestacionAbon) Abonado [%ld] no encontrado ..."
                              , LOG01
                              , lNumAbonado);
         iDError (szExeName,ERR000,vInsertarIncidencia,"Select => Abonados (bfnFindCodPrestacionAbon)",szfnORAerror ());
         return FALSE;
    }
    else
    {    
         vDTrazasLog (szExeName, "\n\t\t* Busca Codigo Prestacion Abonado : [%ld]"
                                 "\n\t\t=> Cod. Prestacion [%s]"
                               , LOG05, lhNumAbonado, szhCodPrestacionAbon );
                        	                                
         strcpy (szCodPrestacionAbon, szhCodPrestacionAbon);
         
    }
    
    return (TRUE);
}
/******************************** Final bfnFindCodPrestacionAbon *************************/

/**********************************************************************************/
/* FUNCION : bfnFindFactura                                                       */
/**********************************************************************************/
BOOL bfnFindFactura ( long lCodigoCliente, 
                      char *szNombreCliente, 
                      long lCodCiclFact, 
                      char *szFecEmision,
                      char *szNumIdent,
                      long lNumVenta)
{
	
    char szAnd [40]    ="";
    char szQry [1000]  ="";	
	
    EXEC SQL BEGIN DECLARE SECTION;
         char szhTipoFactura     [1+1]; EXEC SQL VAR szhTipoFactura   IS STRING(1+1);
         char szhNombreCliente [110+1]; EXEC SQL VAR szhNombreCliente IS STRING(110+1);
         char szhNumIdent       [20+1]; EXEC SQL VAR szhNumIdent      IS STRING(20+1);         
         long lhCodCliente;
         long lhCodCicloFact;
         long lhNumVenta;       /* P-MIX-09003 */
         char szhFecEmision     [10+1]; EXEC SQL VAR szhFecEmision IS STRING(10+1);
    EXEC SQL END DECLARE SECTION;

    memset(szNombreCliente,'\0',sizeof(szNombreCliente));
    memset(szhNombreCliente,'\0',sizeof(szhNombreCliente));
    memset(szhNumIdent,'\0',sizeof(szhNumIdent));    
    memset(szhTipoFactura,'\0',sizeof(szhTipoFactura));
    memset(szhFecEmision,'\0',sizeof(szhFecEmision));    
    
    lhCodCliente   = lCodigoCliente;
    lhCodCicloFact = lCodCiclFact;
    lhNumVenta     = lNumVenta;           /* P-MIX-09003 */
    strcpy(szhFecEmision,szFecEmision);    
    
/* P-MIX-09003 */    
    if (lhCodCicloFact)
    {
        strcpy(szhTipoFactura,"C"); /* Factura Ciclica */
        sprintf(szAnd,"");
    }
    else
    {
        strcpy(szhTipoFactura,"I"); /* Factura Inmediata */
        sprintf(szAnd,"\n AND NUM_VENTA = :lhNumVenta ");        
    } 
    
    vDTrazasLog (szExeName, "\n\t\t* Busca Factura "
                            "\n\t\t=> Cod.Cliente   [%ld]"
                            "\n\t\t=> Cod.CiclFact  [%ld]"
                            "\n\t\t=> Tipo Factura   [%s]"                                        
                            "\n\t\t=> Fec.Emision    [%s]"
                            "\n\t\t=> Num.Venta     [%ld]"                    
                          , LOG05,lhCodCliente, lhCodCicloFact
                          , szhTipoFactura, szhFecEmision,lhNumVenta );

    sprintf(szQry,
          "\n SELECT NVL(NOMBRE || ' ' || NOM_APELLIDO1 || ' ' || NOM_APELLIDO2,' ') , "
          "\n        NVL(NUM_IDENT,' ') "
          "\n FROM   GE_DATCLIFACTURA_TO "
          "\n WHERE  TIPO_FACTURA = :szhTipoFactura "
          "\n AND    COD_CLIENTE = :lhCodCliente "
          "\n AND    TO_DATE(:szhFecEmision ,'YYYYMMDD') BETWEEN TRUNC(FEC_DESDE) AND TRUNC(FEC_HASTA) "
          "%s" , szAnd);

    vDTrazasLog(szModulo,"\t\tQRY:[ %s ]",LOG06,szQry);
    
    EXEC SQL PREPARE sql_Cur_Factura FROM :szQry;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-PREPARE sql_Cur_Factura **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-PREPARE sql_Cur_Factura **"
                                      "\t\tError : [%s] [%d]  [%s] ",LOG01,szQry,SQLCODE,SQLERRM);
        return (SQLCODE);
    }   
    
    EXEC SQL DECLARE curFactura CURSOR FOR sql_Cur_Factura;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-DECLARE curFactura **"
                        "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-DECLARE curFactura **"
                        "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return (SQLCODE);
    }
    
    if (lhCodCicloFact)
    {
        EXEC SQL OPEN curFactura USING :szhTipoFactura, :lhCodCliente, :szhFecEmision;    	
    }
    else
    {
        EXEC SQL OPEN curFactura USING :szhTipoFactura, :lhCodCliente, :szhFecEmision, :lhNumVenta;    	
    }         
    

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\n\t\tError en SQL-OPEN CURSOR curFactura **"
                               "\n\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\n\t\tError en SQL-OPEN CURSOR curFactura **"
                               "\n\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }    
    
    EXEC SQL
         FETCH curFactura INTO :szhNombreCliente, :szhNumIdent;

    if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Select=> GE_DATCLIFACTURA_TO", szfnORAerror ());
        return FALSE;
    }
    else
    {
    	if (SQLCODE == SQLNOTFOUND)
    	{
            vDTrazasLog(szModulo, "\n\tNo encontre Nombre Cliente.. ", LOG05);
    	    strcpy (szNombreCliente, " ");
    	    strcpy (szNumIdent, " ");    	    
    	}
    	else
    	{
            vDTrazasLog(szModulo, "\n\tEncontre Nombre Cliente.. ", LOG05);    		
    	    strcpy(szNombreCliente, szhNombreCliente);
    	    strcpy(szNumIdent, szhNumIdent);    	    
        }
    }    
/* P-MIX-09003 */    
    return TRUE;
}
/***************************** Final bfnFindFacturaCiclo **********************/

/* P-MIX-09003 */
/**********************************************************************************/
/* FUNCION : bfnFindPrefoliados                                                       */
/**********************************************************************************/
BOOL bfnFindPrefoliados ( long lIndOrdenTotal, 
                          char *szPrefoliados,
                          char *szResolucionPre,
                          char *szSeriePre,
                          int  *iCodTipDocumPre,
                          char *szEtiquetaPre,
                          long *lNumFolioPre )
{
    EXEC SQL BEGIN DECLARE SECTION;
         long lhIndOrdenTotal;    
         char szhPrefoliados  [100+1]; EXEC SQL VAR szhPrefoliados    IS STRING(100+1);
         char szhResolucionPre [25+1]; EXEC SQL VAR szhResolucionPre  IS STRING(25+1);
         char szhSeriePre      [10+1]; EXEC SQL VAR szhSeriePre       IS STRING(10+1);
         int  ihCodTipDocumPre       ; 
         char szhEtiquetaPre   [10+1]; EXEC SQL VAR szhEtiquetaPre    IS STRING(10+1);
         long lhNumFolioPre          ; 
    EXEC SQL END DECLARE SECTION;

    memset(szhPrefoliados    ,'\0',sizeof(szhPrefoliados));
    memset(szhResolucionPre  ,'\0',sizeof(szhResolucionPre));
    memset(szhSeriePre       ,'\0',sizeof(szhSeriePre));
    
    lhIndOrdenTotal = lIndOrdenTotal;
    
    vDTrazasLog (szExeName, "\n\t\t* Busca PreFoliados *"
                    "\n\t\t=> Ind. Orden Total   [%ld]"
                    , LOG05,lhIndOrdenTotal);

    EXEC SQL 
             SELECT RESOLUCION|| ' ' ||SERIE|| ' ' ||TO_CHAR(COD_TIPDOCUM)|| ' ' ||ETIQUETA|| ' ' ||TO_CHAR(NUM_FOLIO),
                    RESOLUCION, SERIE, COD_TIPDOCUM, NVL(ETIQUETA,' '), NUM_FOLIO
             INTO   :szhPrefoliados,
                    :szhResolucionPre, :szhSeriePre, :ihCodTipDocumPre, :szhEtiquetaPre, :lhNumFolioPre
             FROM   FA_PREFOLIADOS
             WHERE  IND_ORDENTOTAL = :lhIndOrdenTotal;

    if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Select=> FA_PREFOLIADOS", szfnORAerror ());
        vDTrazasLog(szModulo, "\n\tNo hay Prefoliados ", LOG01);        
        return FALSE;
        
    }
    else
    {
    	if (SQLCODE == SQLNOTFOUND)
    	{
            vDTrazasLog(szModulo, "\n\tNo hay Prefoliados ", LOG06);                      
            return FALSE;
    	}
    	else
    	{
            vDTrazasLog(szModulo, "\n\tEncontre Prefoliados ", LOG06);    		
    	    strcpy(szPrefoliados, szhPrefoliados);
    	    
            strcpy(szResolucionPre,szhResolucionPre);
            strcpy(szSeriePre,szhSeriePre);
            *iCodTipDocumPre = ihCodTipDocumPre;
            strcpy(szEtiquetaPre,szhEtiquetaPre);
            *lNumFolioPre   = lhNumFolioPre;
        }
    }    
    
    return TRUE;
}
/***************************** Final bfnFindPrefoliados **********************/

/* P-MIX-09003 */
BOOL bfnCargaRegistrosTipoD (REGTIP_D **stRegTipD, int *iNumRegD)
{
    int      rc = 0;
    int      iNumFilas;
    static   REGTIP_D_HOST stRegTipDHost;
    REGTIP_D *stRegTipDTemp;
    int      iCont;
    char     *szModulo="bfnCargaRegistrosTipoD";

    vDTrazasLog (szModulo,"\n\t* Carga Configuracion Registro D ", LOG03);

    *iNumRegD  = 0;
    *stRegTipD = NULL;

    if ( ifnOpenRegistrosTipoD() )
    {
        return (FALSE);
    }

    while ( rc != SQLNOTFOUND )
    {
        rc = bfnFetchRegistrosTipoD(&stRegTipDHost,&iNumFilas);
        
        if ( rc != SQLOK  && rc != SQLNOTFOUND )
        {
            return (FALSE);
        }

        if ( !iNumFilas )
        {
            break;
        }

        *stRegTipD =(REGTIP_D*) realloc(*stRegTipD,(int)(((*iNumRegD)+iNumFilas)*sizeof(REGTIP_D)));

        if ( !*stRegTipD )
        {
            iDError (szModulo,ERR000,vInsertarIncidencia,
                     "Error bfnCargaRegistrosTipoD", "no se pudo reservar memoria");
            return (FALSE);
        }

        stRegTipDTemp = &(*stRegTipD)[(*iNumRegD)];
        memset(stRegTipDTemp, 0, (int)(sizeof(REGTIP_D)*iNumFilas));
        
        for ( iCont = 0 ; iCont < iNumFilas ; iCont++ )
        {
              stRegTipDTemp[iCont].iPosicion              = stRegTipDHost.iPosicion[iCont];
              strcpy( stRegTipDTemp[iCont].szCodRegistro  , alltrim(stRegTipDHost.szCodRegistro[iCont]));
              strcpy( stRegTipDTemp[iCont].szCodTipLlam   , alltrim(stRegTipDHost.szCodTipLlam[iCont]));
              strcpy( stRegTipDTemp[iCont].szCodValor     , alltrim(stRegTipDHost.szCodValor[iCont]));
        }
        
        (*iNumRegD) += iNumFilas;

    }/* fin while */

    vDTrazasLog (szModulo,"\n\t\t* Configuracion de Registros D cargados :[%d]", LOG03, *iNumRegD);

    rc = ifnCloseRegistrosTipoD();
    
    if ( rc != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Error bfnCargaRegistrosTipoD", szfnORAerror ());
        return (FALSE);
    }

    vDTrazasLog (szModulo,"\n\t\t* (bfnCargaRegistrosTipoD) Saliendo de la funcion...", LOG06);

    return(TRUE);
}/***************************** Final bfnCargaRegistrosTipoD *********************/

/*********************************************************************************/
/* FUNCION : ifnOpenRegistrosTipoD                                               */
/*********************************************************************************/
static int ifnOpenRegistrosTipoD(void)
{
    char *szModulo="ifnOpenRegistrosTipoD";
    
    vDTrazasLog (szModulo,"\n\t\t* En la funcion ifnOpenRegistrosTipoD", LOG03);
	
    EXEC SQL DECLARE Cur_ConfRegTipD CURSOR FOR
         SELECT POSICION, COD_REGISTRO, TIP_REGISTRO, VALOR
         FROM   FA_REGDETLLAM_TD
         ORDER  BY POSICION ASC;

    EXEC SQL OPEN Cur_ConfRegTipD;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Open=> Cur_ConfRegTipD",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Fin ifnOpenRegistrosTipoD  **********************/

/*********************************************************************************/
/* FUNCION : bfnFetchRegistrosTipoD                                              */
/*********************************************************************************/
static BOOL bfnFetchRegistrosTipoD (REGTIP_D_HOST *pstHost,int *piNumFilas)
{
    char *szModulo="bfnFetchRegistrosTipoD";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion bfnFetchRegistrosTipoD", LOG06);

    EXEC SQL FETCH Cur_ConfRegTipD
             INTO :pstHost->iPosicion ,
    	          :pstHost->szCodRegistro,
    	          :pstHost->szCodTipLlam,
    	          :pstHost->szCodValor;

    if ( SQLCODE==SQLOK )
    {
        *piNumFilas = TAM_HOSTS_PEQ;
    }
    else
    {
        if ( SQLCODE==SQLNOTFOUND )
        {
             *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
        }
        else
        {
             iDError (szModulo,ERR000,vInsertarIncidencia,"Fetch=> Cur_ConfRegTipD", szfnORAerror ());
        }
    }
    
    return (SQLCODE);
}/***************************** Final bfnFetchRegistrosTipoD ****************/

/*********************************************************************************/
/* FUNCION : ifnCloseRegistrosTipoD                                              */
/*********************************************************************************/
static int ifnCloseRegistrosTipoD(void)
{
    char *szModulo="ifnCloseRegistrosTipoD";

    vDTrazasLog (szModulo,"\n\t\t* En la funcion ifnCloseRegistrosTipoD", LOG06);

    EXEC SQL CLOSE Cur_ConfRegTipD;

    if ( SQLCODE != SQLOK )
    {
        iDError (szModulo,ERR000,vInsertarIncidencia,"Close=> Cur_ConfRegTipD",szfnORAerror ());
    }

    return (SQLCODE);
}/***************************** Final ifnCloseRegistrosTipoD **********************/

/* P-MIX-09003 */

int ifnOpenCod_Plantarif()
{
    vDTrazasLog (szExeName,"\n\t\t* Open=> TA_PLANTARIF, TA_CARGOSBASICO", LOG06);

    EXEC SQL DECLARE Cur_Cod_Plantarif CURSOR for
            SELECT COD_PLANTARIF   ,
                   DES_PLANTARIF   ,
                   NUM_UNIDADES    ,
                   IMP_CARGOBASICO ,
                   IND_ARRASTRE    ,
                   COD_PRESTACION    /* P-MIX-09003 130964 */
              FROM TA_PLANTARIF    A,
                   TA_CARGOSBASICO B
             WHERE A.COD_PRODUCTO      = 1
               AND A.COD_CARGOBASICO   = B.COD_CARGOBASICO
               AND A.COD_PRODUCTO      = B.COD_PRODUCTO
               AND (B.FEC_HASTA IS NULL OR B.FEC_HASTA > TRUNC(SYSDATE)) ;

    EXEC SQL OPEN Cur_Cod_Plantarif;

    if (SQLCODE != SQLOK)
        iDError (szExeName,ERR000,vInsertarIncidencia,"Open=> TA_PLANTARIF, TA_CARGOSBASICO",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnOpenCod_Plantarif **********************/

BOOL bfnFetchCod_Plantarif(PLAN_TARIFARIO_HOSTS * pst_PlanTarifario, int *iCantPlanes)
{
    EXEC SQL FETCH Cur_Cod_Plantarif
        INTO :pst_PlanTarifario->szCod_Plantarif    ,
             :pst_PlanTarifario->szDes_Plantarif    ,
             :pst_PlanTarifario->lMinutosPlan       ,
             :pst_PlanTarifario->dValorPlan         ,
             :pst_PlanTarifario->iInd_Arrastre      ,
             :pst_PlanTarifario->szCod_Prestacion   ; /* P-MIX-09003 130964 */

    if((SQLCODE == SQLOK) && (SQLCODE != SQLNOTFOUND))
        vDTrazasError(szModulo,"\t\tError en Fetch %s : %s", LOG01, szModulo, SQLERRM);
    else
    {
        *iCantPlanes = sqlca.sqlerrd[2];
    }
    return SQLCODE;
}
/***************************** Final bfnFetchCod_Plantarif ****************/

int ifnCloseCod_Plantarif(void)
{
    vDTrazasLog (szExeName,"\n\t\t* Open=> TA_PLANTARIF, TA_CARGOSBASICO", LOG06);

    EXEC SQL CLOSE Cur_Cod_Plantarif;

    if (SQLCODE != SQLOK)
       iDError (szExeName,ERR000,vInsertarIncidencia,"Close=> Cursor=> TA_PLANTARIF, TA_CARGOSBASICO",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnCloseFetchCod_Plantarif **********************/


BOOL bfnCargaCod_Plantarif (PLAN_TARIFARIO **pstCodPlanTarif, int *iNumCodPlanes)
{
    int     rc = 0;
    int    iNumFilas;
    PLAN_TARIFARIO_HOSTS stCodPlanTarifHost;
    PLAN_TARIFARIO  *pstCodPlanTarifTemp;
    int iCont;

    vDTrazasLog (szExeName,"\n\t* Carga Planes tarifarios ", LOG06);

    *iNumCodPlanes = 0;
    *pstCodPlanTarif = NULL;

    if (ifnOpenCod_Plantarif())
        return FALSE;

    while (rc != SQLNOTFOUND)
    {
        rc = bfnFetchCod_Plantarif(&stCodPlanTarifHost,&iNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
        return FALSE;

        if (!iNumFilas)
            break;

        *pstCodPlanTarif =(PLAN_TARIFARIO*) realloc(*pstCodPlanTarif,(int)(((*iNumCodPlanes)+iNumFilas)*sizeof(PLAN_TARIFARIO)));

        if (!*pstCodPlanTarif)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error bfnCargaCod_Plantarif", "No se pudo reservar memoria");
            return FALSE;
        }

        pstCodPlanTarifTemp = &(*pstCodPlanTarif)[(*iNumCodPlanes)];
        memset(pstCodPlanTarifTemp, 0, (int)(sizeof(PLAN_TARIFARIO)*iNumFilas));
        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            strcpy( pstCodPlanTarifTemp[iCont].szCod_Plantarif,alltrim(stCodPlanTarifHost.szCod_Plantarif[iCont]));
            strcpy( pstCodPlanTarifTemp[iCont].szDes_Plantarif,stCodPlanTarifHost.szDes_Plantarif[iCont]);
            pstCodPlanTarifTemp[iCont].lMinutosPlan   = stCodPlanTarifHost.lMinutosPlan   [iCont];
            pstCodPlanTarifTemp[iCont].dValorPlan     = stCodPlanTarifHost.dValorPlan     [iCont];
            pstCodPlanTarifTemp[iCont].iInd_Arrastre  = stCodPlanTarifHost.iInd_Arrastre  [iCont];
            strcpy( pstCodPlanTarifTemp[iCont].szCod_Prestacion,stCodPlanTarifHost.szCod_Prestacion[iCont]); /* P-MIX-09003 130964 */

        }
        (*iNumCodPlanes) += iNumFilas;

    }

    vDTrazasLog (szExeName,"\n\t\t* Codigos de Planes Tarifarios cargados [%ld]", LOG06, *iNumCodPlanes);

    rc = ifnCloseCod_Plantarif();
    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error bfnCargaCod_Plantarif", szfnORAerror ());
        return FALSE;
    }

    qsort((void*)*pstCodPlanTarif, *iNumCodPlanes, sizeof(PLAN_TARIFARIO),ifnCmpCod_PlanTarif);

    vfnPrintCod_PlanTarif (*pstCodPlanTarif, *iNumCodPlanes);

    return (TRUE);
}
/***************************** Final bfnCargaCod_Plantarif *********************/

void vfnPrintCod_PlanTarif (PLAN_TARIFARIO *pstCodPlanTarif, int iNumCodPlanes)
{
    int i = 0;

    if (stStatus.LogNivel >= LOG06)
    {
        vDTrazasLog (szExeName,"\n\t\t* Carga Planes Tarifarios [%d]", LOG06, iNumCodPlanes);

        for (i=0;i<iNumCodPlanes;i++)
        {
             vDTrazasLog (szExeName,"\n\t\t=> [%d]: Codigo de Plan   [%s]"
                                    "\n\t\t=> [%d]: Desc. del Plan   [%s]"
                                    "\n\t\t=> [%d]: Minutos del Plan [%ld]  Valor Plan [%f]  Ind. de Arrastre [%ld]"
                                    ,LOG06
                                    ,i, pstCodPlanTarif[i].szCod_Plantarif
                                    ,i, pstCodPlanTarif[i].szDes_Plantarif
                                    ,i, pstCodPlanTarif[i].lMinutosPlan , pstCodPlanTarif[i].dValorPlan , pstCodPlanTarif[i].iInd_Arrastre);
        }

    }
}
/*************************** vfnPrintCod_PlanTarif *****************************/


int ifnCmpCod_PlanTarif(const void *cad1,const void *cad2)
{
    return ( strcmp (((PLAN_TARIFARIO  *)cad1)->szCod_Plantarif,((PLAN_TARIFARIO  *)cad2)->szCod_Plantarif) );

}
/*************************** ifnCmpCod_PlanTarif *****************************/


BOOL bfnFindCod_PlanTarif (char *szCodPlanTarif, PLAN_TARIFARIO *pstCodPlanTarif)
{
    PLAN_TARIFARIO  stkey;
    PLAN_TARIFARIO  *pstAux = (PLAN_TARIFARIO *)NULL;

    strcpy (szModulo, "bfnFindCod_PlanTarif");


    vDTrazasLog (szModulo, "\n\t\t* Busca Codigo de Plan Tarifario "
                            "\n\t\t=> Cod. Plan Tarifario   [%s]"
                            , LOG05,szCodPlanTarif );

    strcpy(stkey.szCod_Plantarif, szCodPlanTarif);

    if (pstPlanes.iNumRegPlanTarif > 0)
    {
        if ( (pstAux = (PLAN_TARIFARIO *)bsearch (&stkey, pstPlanes.stPlanesTarifarios , pstPlanes.iNumRegPlanTarif,
            sizeof (PLAN_TARIFARIO),ifnCmpCod_PlanTarif ))== (PLAN_TARIFARIO *)NULL)
        {

            vDTrazasLog(szModulo, "Codigo de Plan Tarifario [%s] no encontrado ...", LOG01, szCodPlanTarif);
            return  (FALSE);
        }
        memcpy (pstCodPlanTarif, pstAux, sizeof(PLAN_TARIFARIO));
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Planes tarifarios ...", LOG01);
    }
    return (TRUE);
}



#ifndef isnull
    #define isnull(name) (name==(char )NULL )
#endif
#ifndef strnull
    #define strnull(name) (name==(char *)NULL || name[0]==(char)NULL)
#endif


char *ltrim(char *s)
{
    char *p=s;
    if( strnull(s) )
        return(s); 
    while( *p<=32 && *p>1 ) p++;
    strcpy(s,p);
    return(s);
}

char *rtrim(char *s)
{
    char *p=NULL;
    if( strnull(s) )
        return(s); 
    p=(s+strlen(s)-1);
    while( *p<=32 && *p>1 )  p--;
    *(++p)=0;
    return(s);
}

char *alltrim(char *s)
{
    return(ltrim(rtrim(s)));
}

/****************************************************************************/
/*                             funcion : CargaMultiIdiomas                  */
/****************************************************************************/

BOOL CargaMultiIdiomas (GRPMULTIIDIOMA **pstGrpMulti, int *iNumGrpMulti)
{
    int     rc = 0;
    int    iNumFilas;
    GRPMULTIIDIOMAS_HOSTS stGrpMultiHost;
    GRPMULTIIDIOMA *pstGrpMultiTemp;
    int  iCont;

    strcpy (szModulo, "CargaMultiIdiomas");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG06,szModulo);

    *iNumGrpMulti = 0;
    *pstGrpMulti = NULL;

    if (OpenMultiIdiomas())
        return (FALSE);

    while (rc != SQLNOTFOUND)
    {
        rc = FetchMultiIdiomas (&stGrpMultiHost,&iNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
            return (FALSE);

        if (!iNumFilas)
        break;

        *pstGrpMulti =(GRPMULTIIDIOMA*) realloc(*pstGrpMulti,(int)(((*iNumGrpMulti)+iNumFilas)*sizeof(GRPMULTIIDIOMA)));

        if (!*pstGrpMulti)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error CargaMultiIdiomas", "no se pudo reservar memoria");
            return (FALSE);
        }

        pstGrpMultiTemp = &(*pstGrpMulti)[(*iNumGrpMulti)];
        memset(pstGrpMultiTemp, 0, (int)(sizeof(GRPMULTIIDIOMA)*iNumFilas));

        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            strcpy(pstGrpMultiTemp[iCont].szCod_Idioma_Grupos   ,alltrim(stGrpMultiHost.szCod_Idioma_Grupos [iCont]));
            strcpy(pstGrpMultiTemp[iCont].szGlosa_Grupo         ,stGrpMultiHost.szGlosa_Grupo   [iCont]);
            strcpy(pstGrpMultiTemp[iCont].szGlosa_Subgrp        ,alltrim(stGrpMultiHost.szGlosa_Subgrp  [iCont]));
        }
        (*iNumGrpMulti) += iNumFilas;

    }

    rc = CloseMultiIdiomas();
    if (rc == SQLNOTFOUND)
        return TRUE;

    if (rc != SQLOK )
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error CargaMultiIdiomas", szfnORAerror ());
        return (FALSE);
    }
    if (*iNumGrpMulti > 0)
    {
        qsort((void*)*pstGrpMulti, *iNumGrpMulti, sizeof(GRPMULTIIDIOMA),ifnCmpGrpMulti);
        vfnPrintGrpMulti (*pstGrpMulti, *iNumGrpMulti);
    }
    return (TRUE);
}
/***************************** Final CargaMultiIdiomas *********************/

/****************************************************************************/
/*                             funcion : OpenMultiIdiomas                   */
/****************************************************************************/

int OpenMultiIdiomas ( void )
{
    strcpy (szModulo, "OpenMultiIdiomas");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL DECLARE curMultiIdiomas CURSOR FOR
            SELECT substr(TO_CHAR(TO_NUMBER(substr(C.COD_CONCEPTO,1,4)),'0009'),2) || C.COD_IDIOMA CONCEPTO,
                   substr(B.DES_CONCEPTO,1,50),
                   substr(C.DES_CONCEPTO,1,50)
              FROM FAD_IMPSUBGRUPOS A,
                   GE_MULTIIDIOMA B,
                   GE_MULTIIDIOMA C
             WHERE TO_CHAR(A.COD_GRUPO)=B.COD_CONCEPTO
               AND B.NOM_TABLA='FAD_IMPGRUPOS' AND B.NOM_CAMPO='COD_GRUPOS'
               AND TO_CHAR(A.COD_SUBGRUPO)=C.COD_CONCEPTO
               AND C.NOM_TABLA='FAD_IMPSUBGRUPOS' AND C.NOM_CAMPO='COD_SUBGRUPO'
               AND B.COD_IDIOMA=C.COD_IDIOMA
          ORDER BY CONCEPTO;

    EXEC SQL OPEN curMultiIdiomas;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curMultiIdiomas **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curMultiIdiomas **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (SQLCODE);
    }
    return (SQLCODE);
}
/*********************** Final de OpenMultiIdiomas ***********************/

/****************************************************************************/
/* Funcion: int FetchMultiIdiomas                                           */
/* Funcion que realiza Fetch en el cursor de curMultiIdiomas                     */
/****************************************************************************/

BOOL FetchMultiIdiomas (GRPMULTIIDIOMAS_HOSTS *pstHost,int  *piNumFilas)
{
    EXEC SQL FETCH curMultiIdiomas
            INTO    :pstHost->szCod_Idioma_Grupos,
                    :pstHost->szGlosa_Grupo ,
                    :pstHost->szGlosa_Subgrp;

    if (SQLCODE==SQLOK)
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if (SQLCODE==SQLNOTFOUND)
            *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
        else
            iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=> Oficinas",
               szfnORAerror ());

  return SQLCODE;
}
/***************************** Final FetchMultiIdiomas ****************/


/****************************************************************************/
/*  Funcion: int CloseMultiIdiomas(void)                                   */
/*  Funcion que cierra el cursor de curMultiIdiomas                           */
/****************************************************************************/

int CloseMultiIdiomas(void)
{
    strcpy (szModulo, "CloseMultiIdiomas");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curMultiIdiomas;
    if(SQLCODE != SQLOK)
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor curMultiIdiomas: %s",LOG01, SQLERRM);
    }
    return (SQLCODE);
}
/****************Final de CloseMultiIdiomas *******************/


/****************************************************************************/
/*                           funcion : vfnPrintFaCiclFact                   */
/****************************************************************************/

void vfnPrintGrpMulti (GRPMULTIIDIOMA *pstEstruc, int iNumRegs)
{
  int i = 0;

    if (stStatus.LogNivel >= LOG06)
    {
        vDTrazasLog (szExeName,"\n\t\t* Carga Grupos Multiidiomas [%d]", LOG06, iNumRegs);

        for (i=0;i<iNumRegs;i++)
        {
             vDTrazasLog (szExeName,"\n\t\t=> [%d]: Codigo Idioma   [%s]"
                                    "\n\t\t=> [%d]: Glosa Grupo     [%s]"
                                    "\n\t\t=> [%d]: Glosa SubGrupo  [%s]"
                                    ,LOG06
                                    ,i, pstEstruc[i].szCod_Idioma_Grupos
                                    ,i, pstEstruc[i].szGlosa_Grupo
                                    ,i, pstEstruc[i].szGlosa_Subgrp);
        }
    }
}
/*************************** vfnPrintOperadoras *****************************/

/****************************************************************************/
/*                             funcion : ifnCmpGrpMulti                     */
/****************************************************************************/

int ifnCmpGrpMulti (const void *cad1,const void *cad2)
{
    return ( strcmp (((GRPMULTIIDIOMA *)cad1)->szCod_Idioma_Grupos
                    ,((GRPMULTIIDIOMA *)cad2)->szCod_Idioma_Grupos) );

}
/*********************** Final de ifnCmpGrpMulti ***************************/

/****************************************************************************/
/*  Funcion: int BuscaMultiIdiomas                                          */
/*  Funcion que busca un Concepto                                           */
/****************************************************************************/

BOOL BuscaMultiIdiomas (char *szCod_Multiidioma, GRPMULTIIDIOMA *pstGrpMulti )
{
    GRPMULTIIDIOMA  stkey;
    GRPMULTIIDIOMA  *pstAux = (GRPMULTIIDIOMA *)NULL;

    vDTrazasLog (szExeName, "\n\t\t* Busca Grupo Multiidioma "
                            "\n\t\t=> Codigo      [%s]"
                            "\n\t\t=> Num.Grupos  [%d]"
                            , LOG05,szCod_Multiidioma, stGrpMultiidiomas.iNumRegs);

    strcpy (stkey.szCod_Idioma_Grupos,szCod_Multiidioma);

    if (stGrpMultiidiomas.iNumRegs > 0)
    {
        if ( (pstAux = (GRPMULTIIDIOMA *)bsearch (&stkey, stGrpMultiidiomas.stGrpIdiomas, stGrpMultiidiomas.iNumRegs,
                                   sizeof (GRPMULTIIDIOMA),ifnCmpGrpMulti ))== (GRPMULTIIDIOMA *)NULL)
        {
            vDTrazasLog(szExeName, "Codigo [%s] no encontrado ", LOG01, szCod_Multiidioma);
            return  (FALSE);
        }
        memcpy (pstGrpMulti, pstAux, sizeof(GRPMULTIIDIOMA));
    }
    else
    {
        vDTrazasLog(szExeName, "No existen datos para buscar en estructura de Multiidiomas ...", LOG01);
    }


    return TRUE;
}
/**************************** Final BuscaMultiIdiomas *********************/

/****************************************************************************/
/*                     funcion : CargaNumOrden                              */
/*  recupera los Numero de Orden de los Grupos, SubGrupos y Conceptos       */
/****************************************************************************/

BOOL CargaNumOrden (NUMORDEN **pstNumOrden, int *iNumRegs, int iCodFormulario )
{
    int     rc = 0;
    int    iNumFilas;
    NUMORDENES_HOSTS stNumOrdenHost;
    NUMORDEN *pstNumOrdenTemp;
    int  iCont;

    strcpy (szModulo, "CargaNumOrden");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG06,szModulo);

    *iNumRegs = 0;
    *pstNumOrden = NULL;

    if (OpenNumOrden(iCodFormulario))
        return (FALSE);

    while (rc != SQLNOTFOUND)
    {
        rc = FetchNumOrden (&stNumOrdenHost,&iNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
            return (FALSE);

        if (!iNumFilas)
        break;

        *pstNumOrden =(NUMORDEN*) realloc(*pstNumOrden,(int)(((*iNumRegs)+iNumFilas)*sizeof(NUMORDEN)));

        if (!*pstNumOrden)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error CargaNumOrden", "no se pudo reservar memoria");
            return (FALSE);
        }

        pstNumOrdenTemp = &(*pstNumOrden)[(*iNumRegs)];
        memset(pstNumOrdenTemp, 0, (int)(sizeof(NUMORDEN)*iNumFilas));
        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            pstNumOrdenTemp[iCont].iNum_OrdenGr     = stNumOrdenHost.iNum_OrdenGr[iCont];
            pstNumOrdenTemp[iCont].iNum_OrdenSubGr  = stNumOrdenHost.iNum_OrdenSubGr[iCont];
            pstNumOrdenTemp[iCont].iNum_OrdenConc   = stNumOrdenHost.iNum_OrdenConc[iCont];
            pstNumOrdenTemp[iCont].iCodGrupo        = stNumOrdenHost.iCodGrupo[iCont];
            pstNumOrdenTemp[iCont].iCodSubGrupo     = stNumOrdenHost.iCodSubGrupo[iCont];
            pstNumOrdenTemp[iCont].iCodConcepto     = stNumOrdenHost.iCodConcepto[iCont];
            strcpy(pstNumOrdenTemp[iCont].szCodRegistro ,alltrim(stNumOrdenHost.szCodRegistro[iCont]));
            pstNumOrdenTemp[iCont].iCodCriterio = stNumOrdenHost.iCodCriterio[iCont];
            pstNumOrdenTemp[iCont].iTipo_Llamada    = stNumOrdenHost.iTipo_Llamada[iCont];
            pstNumOrdenTemp[iCont].iTipo_SubGrupo   = stNumOrdenHost.iTipo_SubGrupo[iCont];
        }
        (*iNumRegs) += iNumFilas;

    }

    vDTrazasLog (szExeName,"\n\t\t* Numeros de Orden cargados [%ld]", LOG06, *iNumRegs);

    rc = CloseNumOrden();

    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error CargaNumOrden", szfnORAerror ());
        return (FALSE);
    }

    qsort((void*)*pstNumOrden, *iNumRegs, sizeof(NUMORDEN),ifnCmpNumOrden);

    vfnPrintNumOrden (*pstNumOrden, *iNumRegs);

    return (TRUE);
}
/***************************** Final CargaNumOrden *************************/

/****************************************************************************/
/*                             funcion : OpenNumOrden                   */
/****************************************************************************/

int OpenNumOrden ( int iCodFormulario )
{
    strcpy (szModulo, "OpenNumOrden");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL DECLARE curNumOrden CURSOR FOR
            SELECT  C.NUM_ORDEN GRP     ,
                B.NUM_ORDEN SGRP    ,
                A.NUM_ORDEN CONC    ,
                C.COD_GRUPO     ,
                B.COD_SUBGRUPO      ,
                A.COD_CONCEPTO      ,
                NVL(B.COD_REGISTRO,'D3001') ,
                NVL(B.CRIT_ORDEN,0) ,
                NVL(B.COD_TIPLLAMADA,0) ,
                B.COD_TIPSUBGRUPO
        FROM    FAD_IMPCONCEPTOS A  ,
            FAD_IMPSUBGRUPOS B  ,
            FAD_IMPGRUPOS C
        WHERE   A.COD_CONCEPTO  > 0
        AND     A.COD_SUBGRUPO  = B.COD_SUBGRUPO
        AND     B.COD_GRUPO     = C.COD_GRUPO
        AND     C.COD_FORMULARIO= :iCodFormulario
        ORDER BY A.COD_CONCEPTO;

    EXEC SQL OPEN curNumOrden;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-OPEN CURSOR curNumOrden **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-OPEN CURSOR curNumOrden **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (SQLCODE);
    }
    return (SQLCODE);
}
/*********************** Final de OpenNumOrden ***********************/

/****************************************************************************/
/* Funcion: int FetchNumOrden                                               */
/* Funcion que realiza Fetch en el cursor de curNumOrden                    */
/****************************************************************************/

BOOL FetchNumOrden (NUMORDENES_HOSTS *pstHost,int *piNumFilas)
{
    EXEC SQL FETCH curNumOrden
            INTO    :pstHost->iNum_OrdenGr      ,
                    :pstHost->iNum_OrdenSubGr   ,
                    :pstHost->iNum_OrdenConc    ,
                    :pstHost->iCodGrupo     ,
                    :pstHost->iCodSubGrupo      ,
                    :pstHost->iCodConcepto      ,
                    :pstHost->szCodRegistro     ,
                    :pstHost->iCodCriterio      ,
                    :pstHost->iTipo_Llamada     ,
                    :pstHost->iTipo_SubGrupo    ;


    if (SQLCODE==SQLOK)
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if (SQLCODE==SQLNOTFOUND)
            *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
        else
            iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=> Num.Orden", szfnORAerror ());

    return SQLCODE;
}
/***************************** Final FetchNumOrden *********************/


/****************************************************************************/
/*  Funcion: int CloseNumOrden(void)                                        */
/*  Funcion que cierra el cursor de CloseNumOrden                           */
/****************************************************************************/

int CloseNumOrden(void)
{
    strcpy (szModulo, "CloseNumOrden");
    vDTrazasLog(szModulo,"\tEntrando a %s ",LOG04,szModulo);

    EXEC SQL CLOSE curNumOrden;
    if(SQLCODE != SQLOK)
    {
        vDTrazasError(szModulo,"\tError al cerrar el Cursor curNumOrden: %s",LOG01, SQLERRM);
    }
    return (SQLCODE);
}
/****************Final de CloseNumOrden *******************/


/****************************************************************************/
/*                             funcion : ifnCmpNumOrden                     */
/****************************************************************************/

int ifnCmpNumOrden (const void *cad1,const void *cad2)
{
    return ( ((NUMORDEN *)cad1)->iCodConcepto -((NUMORDEN *)cad2)->iCodConcepto) ;

}
/*********************** Final de ifnCmpNumOrden ***************************/

/****************************************************************************/
/*  Funcion: int BuscaNumOrden                                              */
/*  Funcion que busca para un Concepto el orden de impresion                */
/****************************************************************************/

BOOL BuscaNumOrden (int iCodConcepto, NUMORDEN *pstNumOrden )
{
    NUMORDEN  stkey;
    NUMORDEN  *pstAux = (NUMORDEN *)NULL;

    vDTrazasLog (szExeName, "\n\t\t* Busca Num. Orden "
                            "\n\t\t=> Concepto  [%d]"
                            "\n\t\t=> Registros     [%d]"
                            , LOG05,iCodConcepto, stNumOrdenes.iNumRegs);

    stkey.iCodConcepto=iCodConcepto;
    if (stNumOrdenes.iNumRegs)
    {
        if ( (pstAux = (NUMORDEN *)bsearch (&stkey, stNumOrdenes.stNumOrden, stNumOrdenes.iNumRegs,
                                   sizeof (NUMORDEN),ifnCmpNumOrden ))== (NUMORDEN *)NULL)
        {
            vDTrazasLog(szExeName, "Codigo [%d] no encontrado ", LOG01, iCodConcepto);
            return  (FALSE);
        }
        memcpy (pstNumOrden, pstAux, sizeof(NUMORDEN));
    }
    else
    {
        vDTrazasLog(szExeName, "No existen datos para buscar en estructura de Orden ...", LOG01);
    }


    return TRUE;
}
/**************************** Final BuscaNumOrden  *************************/


/****************************************************************************/
/*                           funcion : vfnPrintNumOrden                     */
/****************************************************************************/

void vfnPrintNumOrden (NUMORDEN *pstEstruc, int iNumRegs)
{
  int i = 0;

    if (stStatus.LogNivel >= LOG06)
    {
        vDTrazasLog (szExeName,"\n\t\t* Carga Tabla Numeros de Orden [%d]", LOG06, iNumRegs);

        for (i=0;i<iNumRegs;i++)
        {
             vDTrazasLog (szExeName,
                         "\n\t\t=> [%d]: Ord. Grupo    [%d] Ord. subGrupo [%d] Ord. Concepto [%d]"
                         "\n\t\t=> [%d]: Cod. Grupo    [%d] Cod. SubGrupo [%d] Cod. Concepto [%d]"
                         "\n\t\t=> [%d]: Cod. Registro [%s] Cod. Criterio [%d]"
                         ,LOG06
                         ,i, pstEstruc[i].iNum_OrdenGr, pstEstruc[i].iNum_OrdenSubGr, pstEstruc[i].iNum_OrdenConc
                         ,i, pstEstruc[i].iCodGrupo   , pstEstruc[i].iCodSubGrupo , pstEstruc[i].iCodConcepto
                         ,i, pstEstruc[i].szCodRegistro , pstEstruc[i].iCodCriterio);
        }
    }
}
/*************************** vfnPrintNumOrden *****************************/


extern BOOL CargaEstructuraInicial(NUMORDEN *pstNumOrden, int iCantOrdenes)
{
    int i;
    DETCELULAR_AGRUP  *stDetCelularTemp;

    for (i=0; i < iCantOrdenes; i++)
    {
        if (pstNumOrden[i].iTipo_SubGrupo == 3)
        {
            stDetCelular.stAgrupacion = (DETCELULAR_AGRUP*) realloc(stDetCelular.stAgrupacion, (int) (sizeof(DETCELULAR_AGRUP) * (stDetCelular.iCantEstructuras + 1)) );
            stDetCelularTemp = &(stDetCelular.stAgrupacion)[(stDetCelular.iCantEstructuras)];
            memset(stDetCelularTemp, 0, sizeof(DETCELULAR_AGRUP));

            stDetCelularTemp->iNum_OrdenGr      =  pstNumOrden[i].iNum_OrdenGr;
            stDetCelularTemp->iNum_OrdenSubGr   =  pstNumOrden[i].iNum_OrdenSubGr;
            stDetCelularTemp->iCodGrupo         =  pstNumOrden[i].iCodGrupo;
            stDetCelularTemp->iCodSubGrupo      =  pstNumOrden[i].iCodSubGrupo;
            stDetCelularTemp->iCriterio         =  pstNumOrden[i].iCodCriterio;
            stDetCelularTemp->iTipo_Llamada     =  pstNumOrden[i].iTipo_Llamada;
            strcpy(stDetCelularTemp->szCodRegistro,pstNumOrden[i].szCodRegistro);

            stDetCelular.iCantEstructuras++;
        }
    }
    return (TRUE);
}

/****************************************************************************/
/* Funcion     : int OpenAbonado (long lCiclFact, long lIndOrden)           */
/* Descripcion : Realiza open del cursor sql_Cur_Abonado                    */
/****************************************************************************/

int OpenAbonado (long lCiclFact, long lIndOrden)
{
    char szTablaAbon [40]    ="";
    char szQry       [1000]  ="";

    strcpy (szModulo, "OpenAbonado");
    vDTrazasLog(szModulo,"\t**Entrando a %s "
                         "\n\t=> Ind.Ordentotal [%ld]"
                        , LOG04, szModulo,lIndOrden);

    if ( !lCiclFact ) {
        sprintf(szTablaAbon,"FA_FACTABON_NOCICLO");  }
    else {
        sprintf(szTablaAbon,"FA_FACTABON_%ld",lCiclFact); }

    sprintf(szQry,
        "\n SELECT NUM_ABONADO ,"
               "\n NUM_CELULAR ,"
               "\n COD_DETFACT ,"
               "\n COD_PRODUCTO,"
               "\n NVL(replace(NOM_USUARIO,'%%','N'),' '),"
               "\n NVL(NOM_APELLIDO1,' '),"
               "\n NVL(NOM_APELLIDO2,' '),"
               "\n NVL(IND_COBRODETLLAM,0)"
          "\n FROM %s"
         "\n WHERE IND_ORDENTOTAL = :lhIndOrdentotal"
           "\n AND NUM_ABONADO    >= 0"
           "\n AND NUM_CELULAR  IS NOT NULL"
         "\n ORDER BY NUM_CELULAR" , szTablaAbon);

    vDTrazasLog(szModulo,"\t\tQRY:[ %s ]",LOG06,szQry);

    EXEC SQL PREPARE sql_Cur_Abonado FROM :szQry;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-PREPARE sql_Abonados_DetLlam **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-PREPARE sql_Abonados_DetLlam **"
                                      "\t\tError : [%s] [%d]  [%s] ",LOG01,szQry,SQLCODE,SQLERRM);
        return (SQLCODE);
    }

    EXEC SQL DECLARE curAbonadoFact CURSOR FOR sql_Cur_Abonado;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-DECLARE curAbonadoFact **"
                        "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-DECLARE curAbonadoFact **"
                        "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return (SQLCODE);
    }


    lhIndOrdentotal=lIndOrden;

    EXEC SQL OPEN curAbonadoFact USING :lhIndOrdentotal;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\n\t\tError en SQL-OPEN CURSOR curAbonadoFact **"
                               "\n\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\n\t\tError en SQL-OPEN CURSOR curAbonadoFact **"
                               "\n\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }

    return (SQLCODE);
}
/*********************** Final de OpenAbonado ***********************/

/****************************************************************************/
/* Funcion: int FetchAbonado(ST_ABONADO *)                              */
/* Funcion que realiza Fetch en el cursor de curFactDoc                     */
/****************************************************************************/

int FetchAbonado (ST_ABONADO *pstAbonadoFact)
{
    strcpy (szModulo, "FetchAbonado");
    vDTrazasLog(szModulo,"\t** Entrando en %s", LOG04,szModulo);
    EXEC SQL
    FETCH curAbonadoFact
    INTO :pstAbonadoFact->lNumAbonado    ,
         :pstAbonadoFact->lNumCelular    ,
         :pstAbonadoFact->iIndDetFact    ,
         :pstAbonadoFact->iCodProducto   ,
         :pstAbonadoFact->sznom_usuario  ,
         :pstAbonadoFact->sznom_apellido1,
         :pstAbonadoFact->sznom_apellido2,
         :pstAbonadoFact->iIndCobroDetLlam;         

    if((SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND))
    {
      vDTrazasError(szModulo,"\t\tError en Fetch FetchAbonado : %s", LOG01, SQLERRM);
    }
    else
        pstAbonadoFact->CantidadAbonados = sqlca.sqlerrd[2];

    return(SQLCODE);
}
/*************************** Final de FetchAbonado ***************************/

/****************************************************************************/
/*  Funcion: int CloseAbonado(void)                                      */
/*  Funcion que cierra el cursor de AbonadoFact                             */
/****************************************************************************/
int CloseAbonado(void)
{
    strcpy (szModulo, "CloseAbonado");
    vDTrazasLog(szModulo,"\t** Entrando en %s", LOG04,szModulo);
    EXEC SQL CLOSE curAbonadoFact;
    if(SQLCODE != SQLOK)
    {
      vDTrazasError(szModulo,"\tError al cerrar el Cursor FA_FACTABON_CICLO: %s",LOG01, SQLERRM);
      return (FALSE);
    }
    return (TRUE);
}
/****************Final de bfnCloseFactTrafico *******************/

/*
Se agrega funcion iCargaFechaSuspension para rescatar la fecha de suspension de un cliente; este dato sera
imprimido en registro A1000.
*/

int iCargaFechaSuspension(long lCodCliente, char *sFVencim, char *sFecSuspen)
{
    EXEC SQL BEGIN DECLARE SECTION;
    long lCod_Cli;
    char sF_Venci[12];
    char sFSuspension[12];
    EXEC SQL END DECLARE SECTION;

    lCod_Cli=lCodCliente;
    strncpy(sF_Venci,sFVencim,8);
    sF_Venci[8] = '\0';

    EXEC SQL EXECUTE
        BEGIN
          :sFSuspension := TO_CHAR (TO_DATE (CO_FECSUSP_FN (:lCod_Cli, TO_DATE(:sF_Venci,'YYYYMMDD')), 'DD-MON-YYYY'), 'DDMMYYYY');
        END;
    END-EXEC;

    if (SQLCODE != SQLOK)
    {
       vDTrazasLog("iCargaFechaSuspension", "Error en SELECT iCargaFechaSuspension:(%s)", LOG05,SQLERRM);
       return(FALSE);
    }

    strcpy(sFecSuspen,sFSuspension);
    return(TRUE);
}

/* Se agrega funcion bfnCargaCodImptoFact para rescatar rescatar y poner estructura los datos 
   de codigos de concepto */

BOOL bfnCargaCodImptoFact(CODIMPTOSFACT *stImp_Fact)
{
    COD_IMPTOFACT *stImp_FactTemp;

    EXEC SQL BEGIN DECLARE SECTION;
    long lCod_Imp_fact;
    int  ihCodParametro = 207;
    EXEC SQL END DECLARE SECTION;

    strcpy(szModulo,"bfnCargaCodImptoFact");
    EXEC SQL DECLARE cImpFactura CURSOR FOR
      SELECT val_numerico
        FROM FAD_PARAMETROS
       WHERE COD_PARAMETRO = :ihCodParametro;

    EXEC SQL OPEN cImpFactura;
    if(SQLCODE != SQLOK)
    {
       vDTrazasLog  (szModulo, "\n\t**  Error : En Open Cursor cImpFactura \n%s\n",LOG01,SQLERRM);
       return (FALSE);
    }
    memset(stImp_Fact,0,sizeof(stImp_Fact));
    while (SQLCODE != SQLNOTFOUND)
    {
        EXEC SQL FETCH cImpFactura INTO :lCod_Imp_fact;

        if(SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
        {
            vDTrazasLog  (szModulo, "Error en Fetch de Cursor cImpFactura[%d]: %s",LOG01, SQLCODE, SQLERRM);
            return (FALSE);
        }
        if (SQLCODE == SQLOK)
        {
            stImp_Fact->stCodImptosFact =(COD_IMPTOFACT *) realloc(stImp_Fact->stCodImptosFact,(int)((stImp_Fact->iNumReg + 1) * sizeof(COD_IMPTOFACT)));
            if (stImp_Fact->stCodImptosFact == NULL)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,
                              "Error bfnCargaCodImptoFact", "no se pudo reservar memoria");
                return FALSE;
            }

            stImp_FactTemp = &(stImp_Fact->stCodImptosFact)[(stImp_Fact->iNumReg )];
            memset(stImp_FactTemp, 0, (int)(sizeof(COD_IMPTOFACT)));
            stImp_FactTemp->lCodImptoFact = lCod_Imp_fact;
            stImp_Fact->iNumReg ++ ;
        }
    }

    stImp_Fact->iNumReg= sqlca.sqlerrd[2];

    return(TRUE);
}

BOOL bfnCargaGedPar()
{
    char szNomParam [21];
    char szValParam [21];
    char szCodModulo[3];

    strcpy(szModulo,"bfnCargaGedPar");

    memset(&stGedParametros,'\0',sizeof(stGedParametros));

    strcpy(szCodModulo, "FA");

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_TDIA");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolCodTDia,szValParam);


    sprintf(szNomParam, "%20.20s\0", "TOL_COD_LLAM");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolCodLlam    ,szValParam    );


    sprintf(szNomParam, "%20.20s\0", "TOL_COD_TDIR");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolCodTDir    ,szValParam    );

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_THOR");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolCodTHor    ,szValParam);

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_THOR_ALTA");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolCodTHorAlta,szValParam);

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_THOR_BAJA");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolCodTHorBaja,szValParam);

    sprintf(szNomParam, "%20.20s\0", "TOL_CON_CLIENTE");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolConCliente ,szValParam );

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_OPERADOR");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolCodOperador,szValParam);

    sprintf(szNomParam, "%20.20s\0", "TOL_COD_SFRAN");
    if (!bfnGetGedParam(szNomParam, szCodModulo, szValParam))
    {
         return (FALSE);
    }
    strcpy (stGedParametros.szTolCodSFran   ,szValParam   );

    return(TRUE);
}

BOOL bfnGetGedParam(char * pszNomParam, char *pszCodModulo, char *pszValParam)
{

    EXEC SQL BEGIN DECLARE SECTION;
      char szhNomParametro[21];
      char szhValParametro[21];
      char szhCodModulo[3];
      int  ihCodProducto;
    EXEC SQL END DECLARE SECTION;

    strcpy(szhNomParametro, alltrim(pszNomParam));
    strcpy(szhCodModulo, alltrim(pszCodModulo));
    ihCodProducto = 1;

    EXEC SQL
        SELECT VAL_PARAMETRO
          INTO :szhValParametro
          FROM GED_PARAMETROS
         WHERE NOM_PARAMETRO = :szhNomParametro
           AND COD_MODULO    = :szhCodModulo
           AND COD_PRODUCTO  = :ihCodProducto;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo, "\n\t**Error : En consulta parametro %s \n%s\n",LOG01,pszNomParam,SQLERRM);
        return (FALSE);
    }

    strcpy (pszValParam, szhValParametro);
    return (TRUE);

}

/***************************************************************************/
/* FUNCION : bfnCargaCodImptoCateg                                         */
/***************************************************************************/
BOOL bfnCargaCodImptoCateg(CATIMPUESTOS *st_catImpuestos)
{
    register int j;
    CATIMPUES *stCatImpuestosTemp;
    EXEC SQL BEGIN DECLARE SECTION;
        int  icod_conc;
        int  icod_cat;
        int  iCodTipImpto;
        double dprc_imp;
    EXEC SQL END DECLARE SECTION;

    strcpy(szModulo,"bfnCargaCodImptoCateg");
    EXEC SQL DECLARE cCodImpCateg CURSOR FOR
         SELECT  distinct (A.COD_CONCGENE), 
                 B.COD_CATEIMP, 
                 A.PRC_IMPUESTO, 
                 A.COD_TIPIMPUES
         FROM    GE_IMPUESTOS A, GE_TIPIMPUES B
         WHERE   A.COD_TIPIMPUES = B.COD_TIPIMPUE 
         ORDER   BY A.COD_CONCGENE ASC;

    EXEC SQL OPEN cCodImpCateg;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo, "\n\t**  Error : En Open Cursor cCodImpCateg \n%s\n",LOG01,SQLERRM);
        return (FALSE);
    }
    memset(st_catImpuestos,0,sizeof(st_catImpuestos));
    st_catImpuestos->iNumRegs= sqlca.sqlerrd[2];
    while (SQLCODE != SQLNOTFOUND)
    {
        EXEC SQL FETCH cCodImpCateg INTO
                :icod_conc,:icod_cat,:dprc_imp,:iCodTipImpto;

        if(SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
        {
            vDTrazasLog  (szModulo, "Error en Fetch de Cursor cCodImpCateg[%ld]: %s",LOG01, SQLCODE, SQLERRM);
            return (FALSE);
        }

        st_catImpuestos->stCatImpuesto =(CATIMPUES *) realloc(st_catImpuestos->stCatImpuesto,((st_catImpuestos->iNumRegs + 1 ) * sizeof(CATIMPUES) ));

        if (st_catImpuestos->stCatImpuesto == NULL)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                      "Error bfnCargaCodImptoCateg", "no se pudo reservar memoria");
            return FALSE;
        }
        stCatImpuestosTemp = &(st_catImpuestos->stCatImpuesto)[(st_catImpuestos->iNumRegs )];
        memset(stCatImpuestosTemp, 0, (int)(sizeof(CATIMPUES)));
        stCatImpuestosTemp->iCodConcepto    =icod_conc;
        stCatImpuestosTemp->iCodCategoria   =icod_cat;
        stCatImpuestosTemp->dPrcImpuesto    =dprc_imp;
        stCatImpuestosTemp->iCodTipImpto    =iCodTipImpto;
        strcpy(stCatImpuestosTemp->szFlagImpto,"");
        st_catImpuestos->iNumRegs++;
    }

    vDTrazasLog(szModulo,"\n\tConjunto de Categorias Impositivas"
                         "\t\tCONCEPTO|CATEGORIA|PORCENTAJE|TIPO IMPUESTO|FLAG",LOG05);
    for (j=0;j<st_catImpuestos->iNumRegs;j++)
    {
        vDTrazasLog(szModulo,"\t\t[%d] %ld|%d|%f|%d|%s|",LOG05,j
                            ,st_catImpuestos->stCatImpuesto[j].iCodConcepto
                            ,st_catImpuestos->stCatImpuesto[j].iCodCategoria
                            ,st_catImpuestos->stCatImpuesto[j].dPrcImpuesto
                            ,st_catImpuestos->stCatImpuesto[j].iCodTipImpto
                            ,st_catImpuestos->stCatImpuesto[j].szFlagImpto);
    }
    return(TRUE);
}
/****************************** Fin bfnCargaCodImptoCateg **********************************/

int iTotalizaImpuestoFactura(void)
{
    int i;

    stFaDetCons.dGravFactura=0;

    strcpy (szModulo, "iTotalizaImpuestoFactura");
    vDTrazasLog(szModulo, "\tEntro a %s ", LOG05, szModulo);

    for(i=0;i<stFaDetCons.iNumReg;i++)
    {
        if(  bfnFindCodImptoFact(stFaDetCons.stDetConsumo[i].iCodConcepto))
        {
            stFaDetCons.dGravFactura  += stFaDetCons.stDetConsumo[i].dTotalFacturableNet;
        }
    }

    return(TRUE);
}

BOOL bfnFindCodImptoFact(int iCodConcepto)
{
    COD_IMPTOFACT  stkey;
    COD_IMPTOFACT *elementoPtr = (COD_IMPTOFACT *)NULL;

    vDTrazasLog (szExeName, "\n*Ingresa a bfnFindCodImptoFact... ", LOG05);

    if (pstImptosFact.iNumReg > 0)
    {
        vDTrazasLog (szExeName, "\n*Busca Codigo de Impuesto Factura Cod. Concepto [%d]", LOG05,iCodConcepto);
        stkey.lCodImptoFact=iCodConcepto;
        if ( (elementoPtr = (COD_IMPTOFACT *)bsearch (&stkey, pstImptosFact.stCodImptosFact , pstImptosFact.iNumReg,
            sizeof (COD_IMPTOFACT),ifnCmpCodImptoFact )) == (COD_IMPTOFACT *)NULL)
        {
            vDTrazasLog(szExeName, "Cod. Concepto [%i] no encontrado ...", LOG06, iCodConcepto);
            return  (FALSE);
        }
    }
    else
    {
        vDTrazasLog (szExeName, "\n Estructura pstImptosFact no tiene datos.", LOG05);
    }

    return (TRUE);
}


int ifnCmpCodImptoFact (const void *cad1,const void *cad2)
{
    return ( ((COD_IMPTOFACT *)cad1)->lCodImptoFact - ((COD_IMPTOFACT *)cad2)->lCodImptoFact );
}

BOOL bfnTotImptosCateg(int iCodConcepto,int iColumna,double *pdTotalPrimeraCategoria, double *pdTotalSegundaCategoria )
{
    register int i;
    int iCategoria;
    double dAcumPrimeraCategoria=0.0;
    double dAcumSegundaCategoria=0.0;
    strcpy (szModulo, "bfnTotImptosCateg");

    vDTrazasLog(szModulo, "\tEntro a %s "
                          "\n\t\tBusqueda Concepto  [%d] Columna [%d] "
                          , LOG05, szModulo, iCodConcepto, iColumna );

    if (iCodConcepto == 0 )
        return TRUE;

    for (i=0; i < stFaDetCons.iNumReg; i++ )
    {
        if ( stFaDetCons.stDetConsumo[i].iCodConcerel == iCodConcepto &&
             stFaDetCons.stDetConsumo[i].iColumnaRel  == iColumna     &&
             stFaDetCons.stDetConsumo[i].iCodTipConce == 1)
        {
            if(!bfnCategImpto(stFaDetCons.stDetConsumo[i].iCodConcepto,&iCategoria,stFaDetCons.stDetConsumo[i].dPrcImpuesto))
            {
                vDTrazasLog("bfnCategImpto","No pudo encontrar el concepto con su categoria [%d][%f]"
                                           ,LOG05,stFaDetCons.stDetConsumo[i].iCodConcepto
                                           ,stFaDetCons.stDetConsumo[i].dPrcImpuesto);
            }
            else
            {
                vDTrazasLog("bfnCategImpto","\tConcepto         [%d]"
                                            "\tPorcentaje       [%f]"
                                            "\tCategoria Actual [%d] Primera categoria [%d]"
                                            ,LOG05,stFaDetCons.stDetConsumo[i].iCodConcepto
                                            ,stFaDetCons.stDetConsumo[i].dPrcImpuesto
                                            ,iCategoria,iGPrimCateg);
                if (iCategoria == iGPrimCateg)
                {
                    dAcumPrimeraCategoria +=stFaDetCons.stDetConsumo[i].dTotalFacturableNet;
                }
                else
                {
                    dAcumSegundaCategoria +=stFaDetCons.stDetConsumo[i].dTotalFacturableNet;
                }
            }
        }
    }
    *pdTotalPrimeraCategoria=dAcumPrimeraCategoria;
    *pdTotalSegundaCategoria=dAcumSegundaCategoria;

    return(TRUE);
}

BOOL bfnCategImpto(int iCodConcepto, int *iCodCategoria,double dPrcImpto)
{

    CATIMPUES  stkey;
    CATIMPUES *elementoPtr = (CATIMPUES *)NULL;

    vDTrazasLog (szExeName, "\n\t* Busca Categoria del Impuesto"
                            "\n\t\tCod. Concepto [%d]"
                            "\n\t\tPorcentaje [%f]", LOG05,iCodConcepto,dPrcImpto);
    stkey.iCodConcepto=iCodConcepto;
    stkey.dPrcImpuesto=dPrcImpto;

    if (pstCatImpues.iNumRegs > 0)
    {
        if ( (elementoPtr = (CATIMPUES *)bsearch (&stkey, pstCatImpues.stCatImpuesto , pstCatImpues.iNumRegs,
            sizeof (CATIMPUES),ifnCmpCodImptos )) == (CATIMPUES *)NULL)
        {
            return  (FALSE);
        }
    }
    else
    {
        vDTrazasLog(szExeName, "No existen datos para buscar en estructura de Categorias de impuestos ...", LOG01);
    }

    *iCodCategoria=elementoPtr->iCodCategoria;
    strcpy(elementoPtr->szFlagImpto,"S");           

    return (TRUE);
}

int ifnCmpCodImptos (const void *cad1,const void *cad2)
{
    if  ( ((CATIMPUES *)cad1)->iCodConcepto < ((CATIMPUES *)cad2)->iCodConcepto ) return -1;
    else if ( ((CATIMPUES  *)cad1)->iCodConcepto > ((CATIMPUES  *)cad2)->iCodConcepto ) return 1;
    else if ( ((CATIMPUES  *)cad1)->dPrcImpuesto < ((CATIMPUES  *)cad2)->dPrcImpuesto ) return -1;
    else if ( ((CATIMPUES  *)cad1)->dPrcImpuesto > ((CATIMPUES  *)cad2)->dPrcImpuesto ) return 1;
        return 0;

}

BOOL bfnPorcenImptosCateg(double *pdTotalPorcenPrimeraCateg, double *pdTotalPorcenSegundaCateg )
{
     int i;
     double dPorcenPrimeraCategoria=0.0; 
     double dPorcenSegundaCategoria=0.0; 

    strcpy (szModulo, "bfnPorcenImptosCateg");
    vDTrazasLog(szModulo, "\tEntro a %s ", LOG05, szModulo);
    for (i=0; i < pstCatImpues.iNumRegs; i++ )
    {
        if(strcmp(pstCatImpues.stCatImpuesto[i].szFlagImpto,"S")==0)
        {
            if (pstCatImpues.stCatImpuesto[i].iCodCategoria == iGPrimCateg)
            {
                dPorcenPrimeraCategoria +=pstCatImpues.stCatImpuesto[i].dPrcImpuesto;
            }
            else
            {
                dPorcenSegundaCategoria +=pstCatImpues.stCatImpuesto[i].dPrcImpuesto;
            }
            strcpy(pstCatImpues.stCatImpuesto[i].szFlagImpto," ");
        }
    }
    *pdTotalPorcenPrimeraCateg=dPorcenPrimeraCategoria;
    *pdTotalPorcenSegundaCateg=dPorcenSegundaCategoria;
    return(TRUE);
}

BOOL bfnTipoImpuesto(int iCodConcepto, int *iCodTipoImpuesto,double dPrcImpto)
{

    CATIMPUES  stkey;
    CATIMPUES *elementoPtr = (CATIMPUES *)NULL;

    vDTrazasLog (szExeName, "\n\t\t* Busca Tipo Impuesto \n\t Cod. Concepto [%d]", LOG05,iCodConcepto);
    stkey.iCodConcepto=iCodConcepto;
    stkey.dPrcImpuesto=dPrcImpto;

    if (pstCatImpues.iNumRegs > 0)
    {
        if ( (elementoPtr = (CATIMPUES *)bsearch (&stkey, pstCatImpues.stCatImpuesto , pstCatImpues.iNumRegs,sizeof (CATIMPUES),ifnCmpCodImptos )) == (CATIMPUES *)NULL)
        {
            return  (FALSE);
        }
    }
    else
    {
        vDTrazasLog(szExeName, "No existen datos para buscar en estructura de Tipos de impuestos ...", LOG01);
    }


    *iCodTipoImpuesto=elementoPtr->iCodTipImpto;

    return (TRUE);
}

BOOL bfnBuscaCategImpto(int iCodConcepto, int *iCodCategoria, double dPrcImpto)
{

    CATIMPUES  stkey;
    CATIMPUES *elementoPtr = (CATIMPUES *)NULL;

    vDTrazasLog (szExeName, "Funcion bfnBuscaCategImpto * Busca Categoria del Impuesto \n\t Cod. Concepto [%d]"
                          , LOG05,iCodConcepto);
    stkey.iCodConcepto=iCodConcepto;
    stkey.dPrcImpuesto=dPrcImpto;

    if (pstCatImpues.iNumRegs > 0)
    {
        if ( (elementoPtr = (CATIMPUES *)bsearch (&stkey, pstCatImpues.stCatImpuesto , pstCatImpues.iNumRegs,
            sizeof (CATIMPUES),ifnCmpCodImptos )) == (CATIMPUES *)NULL)
        {
            vDTrazasLog ("bfnBuscaCategImpto", "No encuentra categoria para  [%d]", LOG05,iCodConcepto);
            return  (FALSE);
        }
    }
    else
    {
        vDTrazasLog(szExeName, "No existen datos para buscar en estructura de Categ. de impuestos ...", LOG01);
    }


    *iCodCategoria=elementoPtr->iCodCategoria;
    return (TRUE);
}

int ifnGetNum_Terminales(int *Num_Terminales)
{
    int Numero_Reg;
    register int i;
    int NTerminales;
    long lNumAboAnte= 0L;

   NTerminales = 0;
   Numero_Reg = stFaDetCons.iNumReg;
   for (i=0;i<Numero_Reg;i++)
   {
        if ( stFaDetCons.stDetConsumo[i].lNumAbonado > 0 && 
             stFaDetCons.stDetConsumo[i].iCodConcepto == iCodAbonoCel && 
             stFaDetCons.stDetConsumo[i].lNumAbonado  != lNumAboAnte )
     {
        lNumAboAnte = stFaDetCons.stDetConsumo[i].lNumAbonado ;
        NTerminales++;
     }
   }
   *Num_Terminales = NTerminales;
   vDTrazasLog ("ifnGetNum_Terminales", "Numero de terminales [%i]", LOG05,*Num_Terminales);
   return(TRUE);
}

BOOL bfnLimpiaFlag(CATIMPUESTOS *st_catImpuestos)
{
   int i;
   for (i=0; i < st_catImpuestos->iNumRegs; i++ )
    {
     strcpy(st_catImpuestos->stCatImpuesto[i].szFlagImpto," ");
    }
    return(TRUE);
}

BOOL bfnCargaUltsPagos (PAGO **pstPago, int *iNumRegs, long lCodCliente, long lCodCicloFact)
{
    int         rc = 0;
    int         iNumFilas;
    PAGO_HOSTS  stPagoHost;
    PAGO        *pstPagoTemp;
    int         iCont;

    vDTrazasLog (szExeName,"\n\t* Carga Pagos ", LOG06);

    *iNumRegs = 0;
    *pstPago = (PAGO *)NULL;

    if (ifnOpenPagos(lCodCliente, lCodCicloFact))
        return FALSE;

    while (rc != SQLNOTFOUND)
    {
        rc = bfnFetchPagos(&stPagoHost,&iNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
        return FALSE;

        if (!iNumFilas)
            break;

        *pstPago =(PAGO*) realloc(*pstPago,(int)(((*iNumRegs)+iNumFilas)*sizeof(PAGO)));

        if (!*pstPago)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error bfnCargaUltsPagos", "no se pudo reservar memoria");
            return FALSE;
        }

        pstPagoTemp = &(*pstPago)[(*iNumRegs)];
        memset(pstPagoTemp, 0, (int)(sizeof(PAGO)*iNumFilas));
        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            pstPagoTemp[iCont].dMonto       = stPagoHost.dMonto[iCont];
            strcpy( pstPagoTemp[iCont].szFecha     , stPagoHost.szFecha[iCont]);
            strcpy( pstPagoTemp[iCont].szDecrip    , stPagoHost.szDecrip[iCont]);
            strcpy( pstPagoTemp[iCont].szModPago, stPagoHost.szModPago[iCont]);
            pstPagoTemp[iCont].lTipPago    =  stPagoHost.lTipPago[iCont];        
            strcpy( pstPagoTemp[iCont].szCodOperadora,  stPagoHost.szCodOperadora[iCont]); 
            pstPagoTemp[iCont].lCodTipDocum = stPagoHost.lCodTipDocum[iCont];              
        }
        (*iNumRegs) += iNumFilas;

    }

    vDTrazasLog (szExeName,"\n\t\t* Pagos del cliente cargados [%ld]", LOG06, *iNumRegs);

    rc = ifnClosePagos();
    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error bfnCargaCodClientes", szfnORAerror ());
        return FALSE;
    }

    vfnPrintPagos (*pstPago, *iNumRegs);

    return (TRUE);
}
/***************************** Final bfnCargaUltsPagos *********************/

static int ifnOpenPagos(long lCodCliente, long lCodCicloFact)
{
    lhCodCliente   = lCodCliente;
    lhCodCilclFact = lCodCicloFact;

    vDTrazasLog (szExeName,"\n\t\t* Open=> CO_ULTPAGO_TT", LOG06);

    EXEC SQL OPEN curPagos;

    if (SQLCODE != SQLOK)
        iDError (szExeName,ERR000,vInsertarIncidencia,"Open=> CO_ULTPAGO_TT",szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnOpenPagos **********************/

static BOOL bfnFetchPagos (PAGO_HOSTS *pstHost,int *piNumFilas)
{

    EXEC SQL FETCH curPagos
              INTO  :pstHost->dMonto     ,
                    :pstHost->szFecha    ,
                    :pstHost->szDecrip   ,
                    :pstHost->szModPago  ,
                    :pstHost->lTipPago       ,
                    :pstHost->szCodOperadora ,
                    :pstHost->lCodTipDocum    ;

    if (SQLCODE==SQLOK)
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if (SQLCODE==SQLNOTFOUND)
            *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
        else
            iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=> CO_ULTPAGO_TT", szfnORAerror ());
    return SQLCODE;
}
/***************************** Final bfnFetchPagos ****************/

static int ifnClosePagos(void)
{
    vDTrazasLog (szExeName,"\n\t\t* Open=> CO_ULTPAGO_TT", LOG06);

    EXEC SQL CLOSE curPagos;

    if (SQLCODE != SQLOK)
       iDError (szExeName,ERR000,vInsertarIncidencia,"Close=> Cursor=> CO_ULTPAGO_TT",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnClosePagos **********************/

void vfnPrintPagos (PAGO *pstPago, int iNumRegs)
{
    int i = 0;

    if (stStatus.LogNivel >= LOG06)
    {
        vDTrazasLog (szExeName,"\n\t\t* Carga Tabla Pagos [%d]", LOG06, iNumRegs);

        for (i=0;i<iNumRegs;i++)
        {
             vDTrazasLog (szExeName,"\n\t\t=> [%d]: Monto Pago          [%f]"
                                    "\n\t\t=> [%d]: Fecha Pago          [%s]"
                                    "\n\t\t=> [%d]: Descripcion         [%s]"
                                    "\n\t\t=> [%d]: Cod. Modalidad Pago [%s]"
                                    "\n\t\t=> [%d]: Tipo de Pago        [%ld]"
                                    ,LOG06
                                    ,i, pstPago[i].dMonto
                                    ,i, pstPago[i].szFecha
                                    ,i, pstPago[i].szDecrip
                                    ,i, pstPago[i].szModPago
                                    ,i, pstPago[i].lTipPago  );
        }
    }
}
/*************************** vfnPrintPagos *****************************/

/** P-MIX-09003 77 **/
/***********************************************************************/
/* FUNCION : bfnCargaTipoImpuestos                                     */
/***********************************************************************/
BOOL bfnCargaTiposImpuestos (TIPOIMPUESTO **pstTipoImpuesto, int *iNumRegs)
{
    int                  rc = 0;
    int                  iNumFilas;
    TIPOSIMPUESTOS_HOSTS stTipoImpuestoHost;
    TIPOIMPUESTO        *pstTipoImpuestoTemp;
    int  iCont;

    vDTrazasLog (szExeName,"\n\t* Carga Tipos Impuestos ", LOG06);

    *iNumRegs = 0;
    *pstTipoImpuesto = (TIPOIMPUESTO *)NULL;

    if (ifnOpenTiposImpuestos())
        return FALSE;

    while (rc != SQLNOTFOUND)
    {
        rc = bfnFetchTiposImpuestos(&stTipoImpuestoHost,&iNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
        return FALSE;

        if (!iNumFilas)
            break;

        *pstTipoImpuesto =(TIPOIMPUESTO*) realloc(*pstTipoImpuesto,((*iNumRegs)+iNumFilas)*sizeof(TIPOIMPUESTO));

        if (!*pstTipoImpuesto)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error bfnCargaTiposImpuestos", "no se pudo reservar memoria");
            return FALSE;
        }

        pstTipoImpuestoTemp = &(*pstTipoImpuesto)[(*iNumRegs)];
        memset(pstTipoImpuestoTemp, 0, (int)(sizeof(TIPOIMPUESTO)*iNumFilas));
        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            strcpy( pstTipoImpuestoTemp[iCont].szDesTipImpue, alltrim(stTipoImpuestoHost.szDesTipImpue[iCont]));

            pstTipoImpuestoTemp[iCont].iCodTipImpue       = stTipoImpuestoHost.iCodTipImpue[iCont];

        }
        (*iNumRegs) += iNumFilas;

    }

    vDTrazasLog (szExeName,"\n\t\t* Tipos Impuestos  [%d]", LOG06, *iNumRegs);

    rc = ifnCloseTiposImpuestos();
    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error bfnCargaTiposImpuestos", szfnORAerror ());
        return FALSE;
    }

    if (*iNumRegs >0)
    {
        qsort((void*)*pstTipoImpuesto, *iNumRegs, sizeof(TIPOIMPUESTO),ifnCmpTiposImpuestos);
        vfnPrintTiposImpuestos (*pstTipoImpuesto, *iNumRegs);
    }

    return (TRUE);
}
/***************************** Final bfnCargaTiposImpuestos *********************/

/********************************************************************************/
/* FUNCION: ifnOpenTiposImpuestos                                               */
/********************************************************************************/
int ifnOpenTiposImpuestos( void )
{
    vDTrazasLog (szExeName,"\n\t\t* Open=> GE_TIPIMPUES", LOG06);

    EXEC SQL DECLARE cCurTiposImpuestos CURSOR FOR
         SELECT COD_TIPIMPUE, DES_TIPIMPUE 
         FROM GE_TIPIMPUES
         ORDER BY COD_TIPIMPUE ASC;

    EXEC SQL OPEN cCurTiposImpuestos;

    if (SQLCODE != SQLOK)
        iDError (szExeName,ERR000,vInsertarIncidencia,"Open=> GE_TIPIMPUES",szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnOpenTiposImpuestos **********************/

/********************************************************************************/
/* FUNCION : bfnFetchTiposImpuestos                                             */
/********************************************************************************/
BOOL bfnFetchTiposImpuestos(TIPOSIMPUESTOS_HOSTS *pstHost,int *piNumFilas)
{

    EXEC SQL FETCH cCurTiposImpuestos
              INTO  :pstHost->iCodTipImpue,                   
                    :pstHost->szDesTipImpue;

    if (SQLCODE==SQLOK)
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if (SQLCODE==SQLNOTFOUND)
            *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
        else
            iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=> GE_TIPIMPUES", szfnORAerror ());
    return SQLCODE;
}
/***************************** Final bfnFetchTiposImpuestos ****************/

void vfnPrintTiposImpuestos (TIPOIMPUESTO *pstTipoImpuesto, int iNumRegs)
{
    int i = 0;

    if (stStatus.LogNivel >= LOG06)
    {
        vDTrazasLog (szExeName,"\n\t\t* Carga Tipos Impuestos [%d]", LOG06, iNumRegs);

        for (i=0;i<iNumRegs;i++)
        {
             vDTrazasLog (szExeName,"\n\t\t=> [%d]: Cod TipImpue    [%d]"
                                    "\n\t\t=> [%d]: Descripcion     [%s]"
                                    ,LOG06
                                    ,i, pstTipoImpuesto[i].iCodTipImpue
                                    ,i, pstTipoImpuesto[i].szDesTipImpue );
        }
    }
}
/*************************** vfnPrintTiposImpuestos *****************************/

/********************************************************************************/
/* FUNCION : ifnCmpTiposImpuestos */
/********************************************************************************/
int ifnCmpTiposImpuestos(const void *cad1,const void *cad2)
{
    int rc = 0;

    return
        ( (rc = ((TIPOIMPUESTO *)cad1)->iCodTipImpue-
                ((TIPOIMPUESTO *)cad2)->iCodTipImpue) != 0)?rc:0;

}
/*************************** ifnCmpTiposImpuestos *****************************/

int ifnCloseTiposImpuestos(void)
{
    vDTrazasLog (szExeName,"\n\t\t* Close => GE_TIPIMPUES", LOG06);

    EXEC SQL CLOSE cCurTiposImpuestos;

    if (SQLCODE != SQLOK)
       iDError (szExeName,ERR000,vInsertarIncidencia,"Close=> Cursor=> cCurTiposImpuestos",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnCloseTiposImpuestos **********************/

/*********************************************************************************/
/* FUNCION : bfnSumarImpuestos */
/*********************************************************************************/
BOOL bfnSumarImpuestos (int    iCodTipoImpuesto,
                        long   lIndOrdenTotal,
                        long   lCodCiclFact,
                        double *dTotalImpuesto)
{
	
    EXEC SQL BEGIN DECLARE SECTION;
         int  ihCodTipoImpuesto;
         long lhIndOrdenTotal;
         long lhCodCiclFact;
         double dhTotalImpuesto = 0.0;
    EXEC SQL END DECLARE SECTION;
    	
    char szTablaConc [40]    ="";
    char szQry       [1000]  ="";
    
    ihCodTipoImpuesto = iCodTipoImpuesto;
    lhIndOrdenTotal   = lIndOrdenTotal;
    lhCodCiclFact     = lCodCiclFact;
    
    strcpy (szModulo, "bfnSumarImpuestos");
    vDTrazasLog(szModulo, "\t\t**Entrando a %s "
                          "\n\t========================="
                          "\n\t=> Tipo Impuesto   [%d]"
                          "\n\t=> Ind.Ordentotal  [%ld]"
                          "\n\t=> Cod. Ciclo Fact [%ld]"
                        , LOG06
                        , szModulo
                        , ihCodTipoImpuesto
                        , lhIndOrdenTotal
                        , lhCodCiclFact);

    if ( !lhCodCiclFact ) {
        sprintf(szTablaConc,"FA_FACTCONC_NOCICLO");  }
    else {
        sprintf(szTablaConc,"FA_FACTCONC_%ld",lhCodCiclFact); }	
	
    sprintf(szQry, "\n SELECT NVL(SUM(C.IMP_FACTURABLE),0)"
                   "\n FROM %s C, "
                   "\n     (SELECT  distinct (A.COD_CONCGENE), A.COD_TIPIMPUES "
                   "\n      FROM GE_IMPUESTOS A, GE_TIPIMPUES B "
                   "\n      WHERE A.COD_TIPIMPUES = B.COD_TIPIMPUE "
                   "\n      ORDER BY A.COD_CONCGENE ASC) D "
                   "\n WHERE C.COD_CONCEPTO = D.COD_CONCGENE "
                   "\n AND   C.IND_ORDENTOTAL = :lhIndOrdenTotal "
                   "\n AND   D.COD_TIPIMPUES =  :ihCodTipoImpuesto"         
                 , szTablaConc);

    vDTrazasLog(szModulo,"\t\tQRY:[ %s ]",LOG06,szQry);

    EXEC SQL PREPARE sql_Cur_TipImpuesto FROM :szQry;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-PREPARE sql_Abonados_DetLlam **"
                                      "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-PREPARE sql_Abonados_DetLlam **"
                                      "\t\tError : [%s] [%d]  [%s] ",LOG01,szQry,SQLCODE,SQLERRM);
    }

    EXEC SQL DECLARE curTipImpuesto CURSOR FOR sql_Cur_TipImpuesto;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\t\tError en SQL-DECLARE curTipImpuesto **"
                        "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\t\tError en SQL-DECLARE curTipImpuesto **"
                        "\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }

    EXEC SQL OPEN curTipImpuesto USING :lhIndOrdentotal, :ihCodTipoImpuesto;
    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (szModulo,"\n\t\tError en SQL-OPEN CURSOR curTipImpuesto **"
                               "\n\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        vDTrazasError(szModulo,"\n\t\tError en SQL-OPEN CURSOR curTipImpuesto **"
                               "\n\t\tError : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
    }	
    
    EXEC SQL FETCH curTipImpuesto INTO :dhTotalImpuesto;   

    if ((SQLCODE != SQLOK) && (SQLCODE != SQLNOTFOUND))
    {
      vDTrazasError(szModulo,"\t\tError en Fetch curTipImpuesto : %s", LOG01, SQLERRM);
      dhTotalImpuesto = 0;      
    }
    
    *dTotalImpuesto = dhTotalImpuesto;
        
    return (TRUE);
}
/***************************** Fin bfnSumarImpuestos *****************************/
/** P-MIX-09003 77 **/

BOOL bfnCargaMinutosPlanes (MINPLAN **pstMinPlan, int *iNumRegs)
{
    int     rc = 0;
    int     iNumFilas;
    MINPLAN_HOSTS stMinPlanHost;
    MINPLAN     *pstMinPlanTemp;
    int  iCont;

    vDTrazasLog (szExeName,"\n\t* Carga Valor de minutos por plan ", LOG06);

    *iNumRegs = 0;
    *pstMinPlan = (MINPLAN *)NULL;

    if (ifnOpenMinPlanes())
        return FALSE;

    while (rc != SQLNOTFOUND)
    {
        rc = bfnFetchMinPlanes(&stMinPlanHost,&iNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
        return FALSE;

        if (!iNumFilas)
            break;

        *pstMinPlan =(MINPLAN*) realloc(*pstMinPlan,((*iNumRegs)+iNumFilas)*sizeof(MINPLAN));

        if (!*pstMinPlan)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error bfnCargaMinutosPlanes", "no se pudo reservar memoria");
            return FALSE;
        }

        pstMinPlanTemp = &(*pstMinPlan)[(*iNumRegs)];
        memset(pstMinPlanTemp, 0, (int)(sizeof(MINPLAN)*iNumFilas));
        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            strcpy( pstMinPlanTemp[iCont].szCod_Plan       , alltrim(stMinPlanHost.szCod_Plan[iCont]));
            strcpy( pstMinPlanTemp[iCont].szCod_Thor       , alltrim(stMinPlanHost.szCod_Thor[iCont]));
            pstMinPlanTemp[iCont].lSeg_Inic       = stMinPlanHost.lSeg_Inic[iCont];
            pstMinPlanTemp[iCont].lSeg_Adic       = stMinPlanHost.lSeg_Adic[iCont];
            pstMinPlanTemp[iCont].dMto_Inic       = stMinPlanHost.dMto_Inic[iCont];
            pstMinPlanTemp[iCont].dMto_Adic       = stMinPlanHost.dMto_Adic[iCont];
        }
        (*iNumRegs) += iNumFilas;

    }

    vDTrazasLog (szExeName,"\n\t\t* minutos por planes  [%d]", LOG06, *iNumRegs);

    rc = ifnCloseMinPlanes();
    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error bfnCargaMinutosPlanes", szfnORAerror ());
        return FALSE;
    }

    if (*iNumRegs >0)
    {
        qsort((void*)*pstMinPlan, *iNumRegs, sizeof(MINPLAN),ifnCmpMinPlanes);
        vfnPrintMinPlanes (*pstMinPlan, *iNumRegs);
    }

    return (TRUE);
}
/***************************** Final bfnCargaMinutosPlanes *********************/

int ifnOpenMinPlanes( void )
{
    EXEC SQL BEGIN DECLARE SECTION  ;
        char szhTolCodLlam  [21];
        char szhTolCodTDir  [21];
        char szhTolCodTHor  [21];
        char szhTolCodTHorAlta  [21];
        char szhTolCodTHorBaja  [21];
        char szhTolConCliente[21];
        char szhTolCodOperador[21];
        char szhTolCodTDia  [21];
        char szhTolCodSFran [21];
    EXEC SQL END DECLARE SECTION  ;

    vDTrazasLog (szExeName,"\n\t\t* Open=> TOL_AGRULLAM / TOL_ESTCOBRO", LOG06);

    strcpy (szhTolCodLlam       ,alltrim(stGedParametros.szTolCodLlam)    );
    strcpy (szhTolCodTDir       ,alltrim(stGedParametros.szTolCodTDir)    );
    strcpy (szhTolCodTHor       ,alltrim(stGedParametros.szTolCodTHor)    );
    strcpy (szhTolCodTHorAlta   ,alltrim(stGedParametros.szTolCodTHorAlta) );
    strcpy (szhTolCodTHorBaja   ,alltrim(stGedParametros.szTolCodTHorBaja) );
    strcpy (szhTolConCliente    ,alltrim(stGedParametros.szTolConCliente ) );
    strcpy (szhTolCodOperador   ,alltrim(stGedParametros.szTolCodOperador) );
    strcpy (szhTolCodTDia       ,alltrim(stGedParametros.szTolCodTDia    ) );
    strcpy (szhTolCodSFran      ,alltrim(stGedParametros.szTolCodSFran   ) );

    vDTrazasLog (szExeName, "\n\t\t* Open "
                            "\n\t\t\t* => [%s]"
                            "\n\t\t\t* => [%s]"
                            "\n\t\t\t* => [%s]"
                            "\n\t\t\t* => [%s]"
                            "\n\t\t\t* => [%s]"
                            "\n\t\t\t* => [%s]"
                            "\n\t\t\t* => [%s]"
                            "\n\t\t\t* => [%s]"
                            "\n\t\t\t* => [%s]"
                            , LOG06, szhTolCodLlam, szhTolCodTDir, szhTolCodTHor
                            , szhTolCodTHorAlta, szhTolCodTHorBaja, szhTolConCliente
                            , szhTolCodOperador, szhTolCodOperador, szhTolCodSFran);

    EXEC SQL DECLARE cCurMinPlan CURSOR FOR
        SELECT B.COD_PLAN, A.COD_THOR, B.SEG_INIC, B.SEG_ADIC, B.MTO_MIN, B.MTO_ADIC
          FROM TOL_AGRULLAM A, TOL_ESTCOBRO B
         WHERE A.COD_SENTIDO = 'S'
           AND A.COD_LLAM = :szhTolCodLlam
           AND A.COD_TDIR = :szhTolCodTDir
           AND A.COD_THOR IN (:szhTolCodTHor, :szhTolCodTHorAlta, :szhTolCodTHorBaja)
           AND A.CON_CLIENTE = :szhTolConCliente
           AND A.FEC_INI_VIG <= SYSDATE
           AND A.FEC_TER_VIG >= SYSDATE
           AND B.COD_OPERADOR = :szhTolCodOperador
           AND B.COD_PLAN <> ' '
           AND B.COD_AGRULLAM = A.COD_AGRULLAM
           AND B.COD_TDIA = :szhTolCodTDia
           AND B.COD_SFRAN = :szhTolCodSFran
           AND B.FEC_INI_VIG <= SYSDATE
           AND B.FEC_TER_VIG >= SYSDATE;


    EXEC SQL OPEN cCurMinPlan;

    if (SQLCODE != SQLOK)
        iDError (szExeName,ERR000,vInsertarIncidencia,"Open=> TOL_AGRULLAM/ TOL_ESTCOBRO",szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnOpenMinPlanes **********************/

BOOL bfnFetchMinPlanes(MINPLAN_HOSTS *pstHost,int *piNumFilas)
{

    EXEC SQL FETCH cCurMinPlan
              INTO  :pstHost->szCod_Plan,
                    :pstHost->szCod_Thor,
                    :pstHost->lSeg_Inic ,
                    :pstHost->lSeg_Adic ,
                    :pstHost->dMto_Inic ,
                    :pstHost->dMto_Adic;


    if (SQLCODE==SQLOK)
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if (SQLCODE==SQLNOTFOUND)
            *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
        else
            iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=> TOL_AGRULLAM / TOL_ESTCOBRO", szfnORAerror ());
    return SQLCODE;
}
/***************************** Final bfnFetchMinPlanes ****************/

int ifnCloseMinPlanes(void)
{
    vDTrazasLog (szExeName,"\n\t\t* Close => TOL_AGRULLAM / TOL_ESTCOBRO", LOG06);

    EXEC SQL CLOSE cCurMinPlan;

    if (SQLCODE != SQLOK)
       iDError (szExeName,ERR000,vInsertarIncidencia,"Close=> Cursor=> TOL_AGRULLAM / TOL_ESTCOBRO",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnCloseMinPlanes **********************/

void vfnPrintMinPlanes (MINPLAN *pstMinPlan, int iNumRegs)
{
    int i = 0;

    if (stStatus.LogNivel >= LOG06)
    {
        vDTrazasLog (szExeName,"\n\t\t* Carga Minutos Planes [%d]", LOG06, iNumRegs);

        for (i=0;i<iNumRegs;i++)
        {
             vDTrazasLog (szExeName,"\n\t\t=> [%d]: Cod Plan    [%s]"
                                    "\n\t\t=> [%d]: Cod THor    [%s]"
                                    "\n\t\t=> [%d]: Seg Inic    [%ld]"
                                    "\n\t\t=> [%d]: Seg Adic    [%ld]"
                                    "\n\t\t=> [%d]: Mto Inic    [%f]"
                                    "\n\t\t=> [%d]: Mto Adic    [%f]"
                                    ,LOG06
                                    ,i, pstMinPlan[i].szCod_Plan
                                    ,i, pstMinPlan[i].szCod_Thor
                                    ,i, pstMinPlan[i].lSeg_Inic
                                    ,i, pstMinPlan[i].lSeg_Adic
                                    ,i, pstMinPlan[i].dMto_Inic
                                    ,i, pstMinPlan[i].dMto_Adic );
        }
    }
}
/*************************** vfnPrintMinPlanes *****************************/

int ifnCmpMinPlanes(const void *cad1,const void *cad2)
{
    int rc;
    return ( (rc = strcmp  (((MINPLAN *)cad1)->szCod_Plan,
                            ((MINPLAN *)cad2)->szCod_Plan)) != 0)?rc:
           ( (rc = strcmp  (((MINPLAN *)cad1)->szCod_Thor,
                            ((MINPLAN *)cad2)->szCod_Thor)) != 0)?rc:0;
}
/*************************** ifnCmpCod_PlanTarif *****************************/

BOOL bfnFindMinPlan (char *szCodPlanTarif, char *szCodThor, MINPLAN *pstMinPlan)
{
    MINPLAN  stkey;
    MINPLAN  *pstAux = (MINPLAN *)NULL;

    strcpy (szModulo, "bfnFindMinPlan");

    vDTrazasLog (szModulo, "\n\t\t* Busca Minutos de Plan Tarifario "
                           "\n\t\t=> Cod. Plan Tarifario [%s]"
                           "\n\t\t=> Cod. T Hor          [%s]"
                           , LOG05,szCodPlanTarif
                           , szCodThor);

    strcpy(stkey.szCod_Plan, szCodPlanTarif);
    strcpy(stkey.szCod_Thor, szCodThor);

    if (stMinutosPlanes.iNumRegs > 0)
    {
        if ( (pstAux = (MINPLAN *)bsearch (&stkey, stMinutosPlanes.stMinPlan , stMinutosPlanes.iNumRegs,
            sizeof (MINPLAN), ifnCmpMinPlanes ))== (MINPLAN *)NULL)
        {

            vDTrazasLog(szModulo, "Codigo de Plan Tarifario [%s] no encontrado ...", LOG01, szCodPlanTarif);
            return  (FALSE);
        }
        memcpy (pstMinPlan, pstAux, sizeof(MINPLAN));
    }
    else
    {
        vDTrazasLog(szModulo, "No existen datos para buscar en estructura de Minutos Planes ...", LOG01);
    }

    return (TRUE);
}

BOOL bfnCargaPrimCateg (void)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int     ihCodCateg =0 ;
    EXEC SQL END DECLARE SECTION;

    strcpy (szModulo, "bfnCargaPrimCateg");

    EXEC SQL
        SELECT MIN(COD_CATEIMP)
          INTO :ihCodCateg
          FROM GE_TIPIMPUES;

    if (sqlca.sqlcode != SQLOK && sqlca.sqlcode == SQLNOTFOUND)
    {
        vDTrazasLog(szModulo, "Error en SELECT de bfnCargaPrimCateg [%d]", LOG02, sqlca.sqlcode);
        return (FALSE);
    }

    iGPrimCateg=ihCodCateg;
    vDTrazasLog(szModulo, "Primera Categoria [%d]", LOG05, iGPrimCateg);

    return (TRUE);

}
/************************************ Final bfnChequeaProcesosPrevios **********************************************/

int ifnCmpOperadores(const void *cad1,const void *cad2)
{
    int rc = 0;

    return
        ( (rc = ((CODOPER *)cad1)->iCodOperador-
                ((CODOPER *)cad2)->iCodOperador) != 0)?rc:0;

}

BOOL bfnCargaOperadores (CODOPER **pstOper, int *iNumOperadores)
{
    int     rc = 0;
    int     iNumFilas;
    CODOPER_HOSTS stOperHost;
    CODOPER *pstOperTemp;
    int     iCont;

    vDTrazasLog (szExeName,"\n\t* Carga Operadores ", LOG06);

    *iNumOperadores = 0;
    *pstOper = NULL;

    if (ifnOpenOperadores())
        return FALSE;

    while (rc != SQLNOTFOUND)
    {
        rc = bfnFetchOperadores(&stOperHost,&iNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
        return FALSE;

        if (!iNumFilas)
            break;

        *pstOper =(CODOPER*) realloc(*pstOper,(int)(((*iNumOperadores)+iNumFilas)*sizeof(CODOPER)));

        if (!*pstOper)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error bfnCargaOperadores", "no se pudo reservar memoria");
            return FALSE;
        }

        pstOperTemp = &(*pstOper)[(*iNumOperadores)];
        memset(pstOperTemp, 0, (int)(sizeof(CODOPER)*iNumFilas));
        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            pstOperTemp[iCont].iCodOperador       = stOperHost.iCodOperador[iCont];
            strcpy( pstOperTemp[iCont].szDesOperador    ,stOperHost.szDesOperador[iCont]);
        }
        (*iNumOperadores) += iNumFilas;

    }

    vDTrazasLog (szExeName,"\n\t\t* Codigos de Operadores cargados [%d]", LOG06, *iNumOperadores);

    rc = ifnCloseOperadores();
    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error bfnCargaOperadores", szfnORAerror ());
        return FALSE;
    }

    qsort((void*)*pstOper, *iNumOperadores, sizeof(CODOPER),ifnCmpOperadores);

    vDTrazasLog (szExeName,"\n\t\t* (bfnCargaOperadores) Saliendo de la funcion...", LOG06);

    return (TRUE);
}
/***************************** Final bfnCargaOperadores *********************/

int ifnOpenOperadores(void)
{
    vDTrazasLog (szExeName,"\n\t\t* En la funcion ifnOpenOperadores", LOG06);

    EXEC SQL DECLARE Cur_Operadores CURSOR for
        SELECT COD_OPERADOR, DES_OPERADOR
        FROM  TA_OPERADORES;

    EXEC SQL OPEN Cur_Operadores;

    if (SQLCODE != SQLOK)
        iDError (szExeName,ERR000,vInsertarIncidencia,"Open=> TA_OPERADORES",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnOpenOperadores **********************/

BOOL bfnFetchOperadores (CODOPER_HOSTS *pstHost,int *piNumFilas)
{
    vDTrazasLog (szExeName,"\n\t\t* En la funcion bfnFetchOperadores", LOG06);

    EXEC SQL FETCH Cur_Operadores
              INTO :pstHost->iCodOperador ,
                   :pstHost->szDesOperador;

    if (SQLCODE==SQLOK)
        *piNumFilas = TAM_HOSTS_PEQ;
    else
        if (SQLCODE==SQLNOTFOUND)
            *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
        else
            iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=> TA_OPERADORES", szfnORAerror ());
    return SQLCODE;
}
/***************************** Final bfnFetchOperadores ****************/

int ifnCloseOperadores(void)
{
    vDTrazasLog (szExeName,"\n\t\t* En la funcion ifnCloseOperadores", LOG06);

    EXEC SQL CLOSE Cur_Operadores;

    if (SQLCODE != SQLOK)
       iDError (szExeName,ERR000,vInsertarIncidencia,"Close=> Cursor=> TA_OPERADORES",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnCloseCodClientes **********************/

void vfnPrintOperadores (CODOPER *pstCodOper, int iNumFilas)
{
    int i = 0;

    if (stStatus.LogNivel >= LOG06)
    {
        vDTrazasLog (szExeName,"\n\t\t* Carga Tabla Operadores [%d]", LOG06, iNumFilas);

        for (i=0;i<iNumFilas;i++)
        {
             vDTrazasLog (szExeName,"\t\t=> [%d]: Cod. Operador [%d] Desc. Operador [%s]"
                                    ,LOG06, i, pstCodOper[i].iCodOperador, pstCodOper[i].szDesOperador);
        }

    }
}
/*************************** vfnPrintOperadores *****************************/

BOOL bfnFindCod_Operador (int iCodOperador, CODOPER *pstOper)
{
    CODOPER  stkey;
    CODOPER  *pstAux = (CODOPER *)NULL;

    vDTrazasLog (szExeName, "\n\t\t* Busca Operador "
                            "\n\t\t=> Cod. Operador   [%d]"
                            , LOG05,iCodOperador );

    stkey.iCodOperador = iCodOperador;

    vDTrazasLog (szExeName, "\n\t\t* Cantidad de Operadores [%d]",LOG05,stOperadores.iNumRegs);

    if (stOperadores.iNumRegs > 0)
    {
        if ( (pstAux = (CODOPER *)bsearch (&stkey, stOperadores.stOper , stOperadores.iNumRegs,
            sizeof (CODOPER),ifnCmpOperadores ))== (CODOPER *)NULL)
        {

            vDTrazasLog(szExeName, "Codigo Operador [%d] no encontrado ...", LOG01, iCodOperador);
            return  (FALSE);
        }
        memcpy (pstOper, pstAux, sizeof(CODOPER));
    }
    else
    {
        vDTrazasLog(szExeName, "No existen datos para buscar en estructura de Operadores...", LOG01);
    }

    return (TRUE);
}

BOOL bfnCargarDocsPeriodo ( DOCPERIODO **pstDocPeriodo, 
                            int        *iNumRegs, 
                            long       lCodCliente, 
                            char       *pszFecDesde, 
                            char       *pszFecHasta)
{
    int    rc = 0;
    int    iNumFilas = 0;
    DOCPERIODO_HOSTS stDocPeriodoHost;
    DOCPERIODO      *pstDocPeriodoTemp;
    int    iCont = 0;

    vDTrazasLog (szExeName,"\n\t* Carga Pagos ", LOG06);

    memset (&stDocPeriodoHost, 0 ,sizeof(DOCPERIODO_HOSTS));

    *iNumRegs = 0;
    *pstDocPeriodo = NULL;

    if (ifnOpenDocsPeriodo(lCodCliente,pszFecDesde,pszFecHasta))
        return FALSE;

    while (rc != SQLNOTFOUND)
    {
        rc = bfnFetchDocsPeriodo(&stDocPeriodoHost,&iNumFilas);

        if (rc != SQLOK  && rc != SQLNOTFOUND)
            return FALSE;

        if (!iNumFilas)
            break;

        vDTrazasLog (szExeName,"\n\t\t* 60894 - CONTINUA iNumFilas[%d]", LOG03,iNumFilas);


        *pstDocPeriodo =(DOCPERIODO*) realloc(*pstDocPeriodo,(((*iNumRegs)+iNumFilas)*sizeof(DOCPERIODO)));

        if (!*pstDocPeriodo)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,
                          "Error bfnCargarDocsPeriodo()", "no se pudo reservar memoria");
            return FALSE;
        }

        pstDocPeriodoTemp = &(*pstDocPeriodo)[(*iNumRegs)];

        memset(pstDocPeriodoTemp, 0, (int)(sizeof(DOCPERIODO)*iNumFilas));

        for (iCont = 0 ; iCont < iNumFilas ; iCont++)
        {
            pstDocPeriodoTemp[iCont].iCodTipDocum = stDocPeriodoHost.iCodTipDocum[iCont];
            pstDocPeriodoTemp[iCont].lNumFolio    = stDocPeriodoHost.lNumFolio[iCont];
            pstDocPeriodoTemp[iCont].dTotFactura  = stDocPeriodoHost.dTotFactura[iCont];

            strcpy( pstDocPeriodoTemp[iCont].szCodOperadora  , stDocPeriodoHost.szCodOperadora[iCont]);
            strcpy( pstDocPeriodoTemp[iCont].szCodOficina    , stDocPeriodoHost.szCodOficina[iCont]);
            strcpy( pstDocPeriodoTemp[iCont].szDesTipDocum   , stDocPeriodoHost.szDesTipDocum[iCont]);
            strcpy( pstDocPeriodoTemp[iCont].szPrefPlaza     , stDocPeriodoHost.szPrefPlaza[iCont]);
            strcpy( pstDocPeriodoTemp[iCont].szFecEmision    , stDocPeriodoHost.szFecEmision[iCont]);
        }
        vDTrazasLog (szExeName,"\n\t\t* 60894 - 2.- iCont: [%d]", LOG03, iCont);
        (*iNumRegs) += iNumFilas;
        vDTrazasLog (szExeName,"\n\t\t* 60894 - 2.- iNumFilas: [%d]"
                               "\n\t\t* 60894 - *iNumRegs: [%d]"
                               , LOG03, iNumFilas, *iNumRegs);

    }

    vDTrazasLog (szExeName,"\n\t\t* Documentos del periodo cargados: [%d]", LOG05, *iNumRegs);

    rc = ifnCloseDocsPeriodo();
    if (rc != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error bfnCargarDocsPeriodo", szfnORAerror ());
        return FALSE;
    }

    return (TRUE);
}
/***************************** Final bfnCargarDocsPeriodo *********************/

int ifnOpenDocsPeriodo(long lCodCliente, char *pszFecDesde, char *pszFecHasta)
{
    lhCodCliente = lCodCliente;
    strcpy(szhFecDesde,pszFecDesde);
    strcpy(szhFecHasta,pszFecHasta);

    vDTrazasLog (szExeName,"\n\t\t* Open=> FA_HISTDOCU, GE_TIPDOCUMEN", LOG06);

    EXEC SQL OPEN curDocsPeriodo;

    if (SQLCODE != SQLOK)
        iDError (szExeName,ERR000,vInsertarIncidencia,"Open=> FA_HISTDOCU, GE_TIPDOCUMEN",szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnOpenPagos **********************/

BOOL bfnFetchDocsPeriodo(DOCPERIODO_HOSTS *pstHost,int *piNumFilas)
{

    EXEC SQL FETCH curDocsPeriodo
        INTO  :pstHost->szCodOperadora  ,
              :pstHost->szCodOficina    ,
              :pstHost->iCodTipDocum    ,
              :pstHost->szDesTipDocum   ,
              :pstHost->szPrefPlaza     ,
              :pstHost->lNumFolio       ,
              :pstHost->szFecEmision    ,
              :pstHost->dTotFactura    ;

    if (SQLCODE == SQLOK){
        *piNumFilas = TAM_HOSTS_PEQ;
      }
    else{
        if (SQLCODE == SQLNOTFOUND){
            *piNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;
            vDTrazasLog (szExeName,"\n\t\t* 60894 - bfnFetchDocsPeriodo / sqlca.sqlerrd[2][%d]", LOG03,sqlca.sqlerrd[2]);
          }
        else
            iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=> FA_HISTDOCU, GE_TIPDOCUMEN", szfnORAerror ());
        }

    vDTrazasLog (szExeName,"\n\t\t* 60894 - bfnFetchDocsPeriodo / piNumFilas[%d]", LOG03,*piNumFilas);

    return SQLCODE;
}
/***************************** Final bfnFetchPagos ****************/

int ifnCloseDocsPeriodo(void)
{
    vDTrazasLog (szExeName,"\n\t\t* Close=> FA_HISTDOCU, GE_TIPDOCUMEN", LOG06);

    EXEC SQL CLOSE curDocsPeriodo;

    if (SQLCODE != SQLOK)
       iDError (szExeName,ERR000,vInsertarIncidencia,"Close=> Cursor=> FA_HISTDOCU, GE_TIPDOCUMEN",
                 szfnORAerror ());

    return SQLCODE;
}
/***************************** Final ifnClosePagos **********************/

BOOL bfnCargarTipoDirLlamada(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char szhCodTdir [11];  EXEC SQL VAR szhCodTdir IS STRING(11);
    EXEC SQL END   DECLARE SECTION;


    EXEC SQL
        SELECT A.COD_TOPE || A.COD_TOPE
        INTO
            :szhCodTdir
        FROM TA_OPERADORES A,
             TOL_PAISOPERADORA B
        WHERE A.COD_OPERADOR = B.COD_OPERADOR;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog ("bfnCargarTipoDirLlamada","\n\t\t* En sentenia SELECT, Codigo: [%d]", LOG01,sqlca.sqlcode);
        return FALSE;
    }
    alltrim(szhCodTdir);
    strcpy(gszCodTdir,szhCodTdir);

    return TRUE;
}

void vfnCargarDesOperador(int iCodOperador, char *pszCodTdir, char *pszDesOperador)
{

    CODOPER stOper;

    memset(&stOper,'\0',sizeof(CODOPER));
    alltrim(pszCodTdir);

    if(!strcmp(pszCodTdir,gszCodTdir))
    {
        if(!bfnFindCod_Operador(iCodOperador,&stOper))
        {
            vDTrazasLog ("vfnCargarDesOperador","\n\t\t* No se Encuentra Codigo de Operador", LOG01);
            return;
        }
        else
        {
            vDTrazasLog ("vfnCargarDesOperador","\n\t\t* Codigo de Operador Encontrado."
                                                "\n\t\t* stOper.szDesOperador: [%s].", LOG06,stOper.szDesOperador);
            strcpy(pszDesOperador,"");
            strcpy(pszDesOperador, stOper.szDesOperador);
        }
    }
    else
        vDTrazasLog ("vfnCargarDesOperador","\n\t\t(vfnCargarDesOperador)* Codigos de Operador distintos.", LOG05);
}

/* FUNCION QUE RESCATA DATOS PARA EL REGISTRO A2600 (VENTAS) */
/*---------------------------------------------------------------------------*/
/* Funcion: ifnLlenarSeriesDeVenta                                            */
/*---------------------------------------------------------------------------*/

int ifnLlenarSeriesDeVenta ( reg_entrada *pstEntrada )
{
    EXEC SQL BEGIN DECLARE SECTION;
        long lhNum_venta         ;
        long lhCod_cliente       ;
        int  ihTipoVenta         ;
        char szhNumSerie   [25+1]; EXEC SQL VAR szhNumSerie    IS STRING(25+1);
        long lhNumAbonado        ;
        long lhCodConcepto       ;
        char szhDesConcepto[60+1]; EXEC SQL VAR szhDesConcepto IS STRING(60+1);
        char chString1      [1+1]; EXEC SQL VAR chString1      IS STRING (1+1);
        char szFecVenta       [9]; EXEC SQL VAR szFecVenta     IS STRING (9);
        char szIndVenta       [2]; EXEC SQL VAR szIndVenta     IS STRING (2);
        long lhNumCelular    ; //HPL
    EXEC SQL END DECLARE SECTION;

    char modulo[]="ifnLlenarSeriesDeVenta";
    stSalida * paux;
    long lContador;

    paux = NULL;
    strcpy(chString1,"I");

    lhNum_venta   = pstEntrada->lNumVenta;
    lhCod_cliente = pstEntrada->lCodCliente;
  
    ihTipoVenta = 0;

    EXEC SQL
    SELECT TO_CHAR (FEC_VENTA, 'DDMMYYYY'), IND_VENTA
      INTO :szFecVenta, :szIndVenta
      FROM GA_VENTAS C
     WHERE C.NUM_VENTA   = :lhNum_venta
       AND C.COD_CLIENTE = :lhCod_cliente;

    if (sqlca.sqlcode != SQLOK)
    {
        vDTrazasLog (modulo,"\n\tERROR, al obtener procedencia de la venta. Sqlca.sqlcode [%d]", LOG01,sqlca.sqlcode);
        return FALSE;
    }

    //if (strcmp (szIndVenta,"E")==0) HPL|MA-201072|CSR|18-03-2014
	if (strcmp(szIndVenta,"E")==0 || strcmp(szIndVenta,"W")==0)
    {
        EXEC SQL DECLARE cursorCargosOOSS CURSOR FOR
            SELECT  A.NUM_SERIE,
              A.NUM_ABONADO,
              A.COD_CONCEPTO,
              B.DES_CONCEPTO,
              A.NUM_TERMINAL
            FROM GE_CARGOS A,
                 FA_CONCEPTOS B
           WHERE A.NUM_VENTA = :lhNum_venta
             AND A.COD_CLIENTE = :lhCod_cliente
             AND A.COD_CONCEPTO=B.COD_CONCEPTO;

        EXEC SQL OPEN cursorCargosOOSS;
        lContador = 0;

        while (1)
        {
            EXEC SQL
                FETCH cursorCargosOOSS
                 INTO :szhNumSerie,
                      :lhNumAbonado,
                      :lhCodConcepto,
                      :szhDesConcepto,
                      :lhNumCelular;

            if (sqlca.sqlcode == SQLNOTFOUND)
                break;
            else if (sqlca.sqlcode != SQLOK)
            {
                vDTrazasLog (modulo,"\n\tERROR, al leer cursor CARGOS OOSS .Sqlca.sqlcode [%d]", LOG01,sqlca.sqlcode);
                return FALSE;
            }

            paux = (stSalida *) malloc(sizeof(stSalida));
            if(paux == NULL)
            {
                vDTrazasLog (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                vDTrazasError (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                return (FALSE);
            }

            strcpy(paux->szNumSerie,szhNumSerie);
            paux->lNumAbonado = lhNumAbonado;
            paux->iCodConcepto = lhCodConcepto;
            strcpy(paux->szDesConcepto,szhDesConcepto);
            paux->lNumCelular  = lhNumCelular;

            paux->sgte  = lstSalida;
            lstSalida   = paux;
            lContador++;
            vDTrazasLog ("IMEI","\n\n En el CursorCargosOOSS -->  lhNumCelular: (%ld)  ", LOG05,lhNumCelular );

        }

        EXEC SQL CLOSE cursorCargosOOSS;
    }
    else
    {

         EXEC SQL
           SELECT COUNT(1)
            INTO :ihTipoVenta
            FROM GA_EQUIPABOSER A
            WHERE A.NUM_ABONADO IN (  SELECT B.NUM_ABONADO
                                        FROM GA_ABOAMIST B
                                       WHERE B.NUM_VENTA   = :lhNum_venta
                                         AND B.COD_CLIENTE = :lhCod_cliente
                                         AND TRUNC(B.FEC_ALTA) IN ( SELECT TRUNC(C.FEC_VENTA)
                                                                      FROM GA_VENTAS C
                                                                     WHERE C.NUM_VENTA   = :lhNum_venta
                                                                       AND C.COD_CLIENTE = :lhCod_cliente))
                AND A.IND_PROCEQUI = :chString1;

        if (sqlca.sqlcode != SQLOK) {
            vDTrazasLog (modulo,"\n\tERROR, al obtener procedencia de la venta. Sqlca.sqlcode [%d]", LOG01,sqlca.sqlcode);
            return FALSE;
        }

        if (ihTipoVenta > 0)
        {
            vDTrazasLog (modulo,"\n\tProcedencia es prepago KIT...", LOG05);

            EXEC SQL DECLARE cursorAbonadoPrePagoKIT CURSOR FOR
                SELECT
                    A.NUM_KIT,
                    D.NUM_ABONADO,
                    B.COD_CONCEPTO,
                    B.DES_CONCEPTO,
                    NVL(A.NUM_TELEFONO,0)
                FROM
                      AL_COMPONENTE_KIT A,
                      FA_CONCEPTOS B,
                      AL_ARTICULOS C,
                      GA_EQUIPABOSER D
                WHERE C.COD_ARTICULO  = A.COD_KIT
                  AND A.NUM_SERIE = D.NUM_SERIE
                  AND D.TIP_TERMINAL IN ( SELECT E.VAL_PARAMETRO
                                          FROM   GED_PARAMETROS E
                                          WHERE  E.NOM_PARAMETRO IN ('TIP_DIGITAL', 'COD_SIMCARD_GSM'))
                  AND D.NUM_ABONADO IN  ( SELECT F.NUM_ABONADO
                                          FROM   GA_ABOAMIST F
                                          WHERE  F.NUM_VENTA       = :lhNum_venta
                                            AND  F.COD_CLIENTE     = :lhCod_cliente
                                            AND  TRUNC(F.FEC_ALTA) IN ( SELECT TRUNC(G.FEC_VENTA)
                                                                        FROM   GA_VENTAS G
                                                                        WHERE  G.NUM_VENTA   = :lhNum_venta
                                                                          AND  G.COD_CLIENTE = :lhCod_cliente))
                    AND C.COD_CONCEPTOART = B.COD_CONCEPTO
                    AND D.IND_PROCEQUI    = :chString1;

            EXEC SQL OPEN cursorAbonadoPrePagoKIT;
            lContador = 0;

            while (1)
            {
                EXEC SQL
                    FETCH cursorAbonadoPrePagoKIT
                     INTO :szhNumSerie,
                          :lhNumAbonado,
                          :lhCodConcepto,
                          :szhDesConcepto,
                          :lhNumCelular;

        vDTrazasLog(szModulo, "\tDentro de funcion ifnLlenarSeriesDeVenta - cursorAbonadoPrePagoKIT  "
                              "\n\t  ->lNumCelular (%ld) "
                              , LOG05, lhNumCelular);


                if (sqlca.sqlcode == SQLNOTFOUND)
                    break;
                else if (sqlca.sqlcode != SQLOK)
                {
                    vDTrazasLog (modulo,"\n\tERROR, al leer cursor Abonado PrePago KIT.Sqlca.sqlcode [%d]"
                                       , LOG01,sqlca.sqlcode);
                    return FALSE;
                }

                paux = (stSalida *) malloc(sizeof(stSalida));
                if(paux == NULL)
                {
                    vDTrazasLog (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                    vDTrazasError (modulo,"\n\nERROR:1:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                    return (FALSE);
                }


                strcpy(paux->szNumSerie,szhNumSerie);
                paux->lNumAbonado = lhNumAbonado;
                paux->iCodConcepto = lhCodConcepto;
                strcpy(paux->szDesConcepto,szhDesConcepto);
                paux->lNumCelular  = lhNumCelular;



        vDTrazasLog(szModulo, "\tDentro de funcion ifnLlenarSeriesDeVenta -  paux->lNumCelular  "
                              "\n\t   paux->lNumCelular (%ld) "
                              , LOG05,  paux->lNumCelular);

                paux->sgte  = lstSalida;
                lstSalida   = paux;
                lContador++;

            }

            EXEC SQL CLOSE cursorAbonadoPrePagoKIT;

            if (lContador == 0)
            {
                vDTrazasLog (modulo,"\n\tProcedencia es prepago...", LOG05);

                EXEC SQL DECLARE cursorAbonadoPrePago CURSOR FOR
                SELECT
                    A.NUM_SERIE,
                    A.NUM_ABONADO,
                    B.COD_CONCEPTO,
                    B.DES_CONCEPTO,
                    D.NUM_CELULAR     
                FROM
                    GA_EQUIPABOSER A,
                    FA_CONCEPTOS   B,
                    AL_ARTICULOS   C,
                    GA_ABOAMIST    D
                WHERE
                    A.NUM_ABONADO IN (SELECT D.NUM_ABONADO
                                      FROM   GA_ABOAMIST D
                                      WHERE  D.NUM_VENTA       = :lhNum_venta
                                        AND  D.COD_CLIENTE     = :lhCod_cliente
                                        AND  TRUNC(D.FEC_ALTA) IN (SELECT TRUNC(E.FEC_VENTA)
                                                                   FROM   GA_VENTAS E
                                                                   WHERE  E.NUM_VENTA   = :lhNum_venta
                                                                     AND  E.COD_CLIENTE = :lhCod_cliente))
                    AND C.COD_ARTICULO    = A.COD_ARTICULO
                    AND C.COD_CONCEPTOART = B.COD_CONCEPTO
                    AND A.NUM_ABONADO     = D.NUM_ABONADO
                    AND A.IND_PROCEQUI    = :chString1;

                EXEC SQL OPEN cursorAbonadoPrePago;


                while (1)
                {
                    EXEC SQL
                        FETCH cursorAbonadoPrePago
                         INTO :szhNumSerie,
                              :lhNumAbonado,
                              :lhCodConcepto,
                              :szhDesConcepto,
                              :lhNumCelular;

        vDTrazasLog(szModulo, "\tDentro de funcion ifnLlenarSeriesDeVenta -  cursorAbonadoPrePago  "
                              "\n\t   lhNumCelular (%ld) "
                              , LOG05,  lhNumCelular);


                    if (sqlca.sqlcode == SQLNOTFOUND)
                        break;
                    else if (sqlca.sqlcode != SQLOK)
                    {
                        vDTrazasLog (modulo,"\n\tERROR, Al leer cursor Abonado PrePago. sqlca.sqlcode [%d]"
                                           , LOG01,sqlca.sqlcode);
                        return FALSE;
                    }

                    paux = (stSalida *) malloc(sizeof(stSalida));
                    if(paux == NULL)
                    {
                        vDTrazasLog (modulo,"\n\nERROR:2:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                        vDTrazasError (modulo,"\n\nERROR:2:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                        return (FALSE);
                    }


                    strcpy(paux->szNumSerie,szhNumSerie);
                    paux->lNumAbonado = lhNumAbonado;
                    paux->iCodConcepto = lhCodConcepto;
                    strcpy(paux->szDesConcepto,szhDesConcepto);
                    paux->lNumCelular  = lhNumCelular;

        vDTrazasLog(szModulo, "\tDentro de funcion ifnLlenarSeriesDeVenta -  cursorAbonadoPrePago - paux->lNumCelular "
                              "\n\t   paux->lNumCelular (%ld) "
                              , LOG05,  paux->lNumCelular);



                    paux->sgte  = lstSalida;
                    lstSalida   = paux;


                }


                EXEC SQL CLOSE cursorAbonadoPrePago;
            }
        }
        else
        {
            vDTrazasLog (modulo,"\n\tProcedencia es postpago...", LOG05);


                EXEC SQL DECLARE cursorAbonadoPostPago CURSOR FOR
                SELECT
                    A.NUM_SERIE
                    ,A.NUM_ABONADO
                    ,B.COD_CONCEPTO
                    ,B.DES_CONCEPTO
                    ,D.NUM_CELULAR  
                FROM
                    GA_EQUIPABOSER A
                    ,FA_CONCEPTOS B
                    ,AL_ARTICULOS C
                    ,GA_ABOCEL     D
                WHERE
                    A.NUM_ABONADO IN (SELECT D.NUM_ABONADO
                                      FROM   GA_ABOCEL D
                                      WHERE  D.NUM_VENTA       = :lhNum_venta
                                        AND  D.COD_CLIENTE     = :lhCod_cliente
                                        AND  TRUNC(D.FEC_ALTA) IN (SELECT TRUNC(E.FEC_VENTA)
                                                                   FROM   GA_VENTAS E
                                                                   WHERE  E.NUM_VENTA       = :lhNum_venta
                                                                     AND  E.COD_CLIENTE = :lhCod_cliente))
                  AND C.COD_ARTICULO    = A.COD_ARTICULO
                  AND C.COD_CONCEPTOART = B.COD_CONCEPTO
                  AND A.NUM_ABONADO     = D.NUM_ABONADO
                  AND A.IND_PROCEQUI    = :chString1;


                EXEC SQL OPEN cursorAbonadoPostPago;

            while (1)
            {
                EXEC SQL
                    FETCH cursorAbonadoPostPago
                      INTO :szhNumSerie
                          ,:lhNumAbonado
                          ,:lhCodConcepto
                          ,:szhDesConcepto
                          ,:lhNumCelular;




                if (sqlca.sqlcode == SQLNOTFOUND)
                    break;
                else if(sqlca.sqlcode != SQLOK)
                {
                    vDTrazasLog (modulo,"\n\tERROR, al leer cursor Abonado PostPago. Sqlca.sqlcode[%d]"
                                       , LOG01,sqlca.sqlcode);
                    return FALSE;
                }

                paux = (stSalida *) malloc(sizeof(stSalida));
                if(paux == NULL)
                {
                    vDTrazasLog (modulo,"\n\nERROR:3:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                    vDTrazasError (modulo,"\n\nERROR:3:(%s): En asignacion de memoria a paux.", LOG05,modulo );
                    return (FALSE);
                }

                strcpy(paux->szNumSerie,szhNumSerie);
                paux->lNumAbonado = lhNumAbonado;
                paux->iCodConcepto = lhCodConcepto;
                strcpy(paux->szDesConcepto,szhDesConcepto);
                paux->lNumCelular  = lhNumCelular;

        vDTrazasLog("IMEI", "\tDentro de funcion ifnLlenarSeriesDeVenta -  cursorAbonadoPostPago - paux->lNumCelular "
                              "\n\t   paux->lNumCelular (%ld) "
							                "\n\t   lNumCelular (%ld) "
                              , LOG03,  paux->lNumCelular,lhNumCelular);


                paux->sgte  = lstSalida;
                lstSalida   = paux;

            }

            EXEC SQL CLOSE cursorAbonadoPostPago;

        }
    }
    return TRUE;

} 
/* ifnLlenarSeriesDeVenta */

int ifnObtenerSeriesFactMiscela(reg_entrada *pstEntrada)
{

    EXEC SQL BEGIN DECLARE SECTION;
    long    lhNumProceso     = 0L;
    long    lhCodConcepto    = 0L;
    long    lhColumna        = 0L;
    char    szhNumSerieResp  [30];   EXEC SQL VAR szhNumSerieResp IS STRING(30);
    long    lhNumProcesoResp = 0L;
    long    lhCodConceptoResp= 0L;
    long    lhColumnaResp    = 0L;
    EXEC SQL END   DECLARE SECTION;

    char    szhDesConcepto[60+1];

    char *pszModulo="ifnObtenerSeriesFactMiscela";

    stSalida *paux;

    lhNumProceso     = pstEntrada->lNumProceso;
    lhCodConcepto    = pstEntrada->iCodConcepto;
    lhColumna        = pstEntrada->iColumna;
    strcpy(szhDesConcepto,pstEntrada->szDesConcepto);

    paux = NULL;

    vDTrazasLog (pszModulo, "\n\tProceso: [%ld]"
                            "\n\tConcepto: [%ld]"
                            "\n\tColumna: [%ld]"
                            , LOG05,lhNumProceso,lhCodConcepto,lhColumna);

    EXEC SQL DECLARE curSeriesMiscelaneas CURSOR FOR
        SELECT
            A.NUM_SERIE,
            A.NUM_PROCESO,
            A.COD_CONCEPTO,
            A.COLUMNA
       FROM
            FA_SERIES_TO A
        WHERE
            A.NUM_PROCESO      = :lhNumProceso
            AND A.COD_CONCEPTO = :lhCodConcepto
            AND A.COLUMNA      = :lhColumna;

        if(SQLCODE != SQLOK)
        {
            vDTrazasLog (pszModulo,"\n\tERROR, En DECLARE de cursor curSeriesMiscelaneas, sqlcode: [%d]"
                                  , LOG01,sqlca.sqlcode);
            return FALSE;
        }

        EXEC SQL OPEN curSeriesMiscelaneas;

        for(;;)
        {

            EXEC SQL
            FETCH
                curSeriesMiscelaneas
                    INTO
                        :szhNumSerieResp,
                        :lhNumProcesoResp,
                        :lhCodConceptoResp,
                        :lhColumnaResp;

            if (SQLCODE == SQLNOTFOUND)
                break;

            if(SQLCODE !=SQLOK)
            {
                vDTrazasLog (pszModulo,"\n\tERROR, En FETCH de cursor curSeriesMiscelaneas, sqlcode: [%d]"
                                      , LOG01,sqlca.sqlcode);
                return FALSE;
            }


            paux = (stSalida *) malloc(sizeof(stSalida));
            if(paux == NULL)
            {
                vDTrazasLog (pszModulo,"\n\nERROR:(%s): En asignacion de memoria a paux.", LOG05,pszModulo );
                vDTrazasError (pszModulo,"\n\nERROR:(%s): En asignacion de memoria a paux.", LOG05,pszModulo );
                return (FALSE);
            }

            strcpy(paux->szNumSerie,szhNumSerieResp);
            paux->lNumAbonado  = 0L;
            paux->iCodConcepto = lhCodConceptoResp;
            strcpy(paux->szDesConcepto,szhDesConcepto);
            paux->lNumCelular  = 0L;

            paux->sgte  = lstSalida;
            lstSalida   = paux;

        }

        EXEC SQL CLOSE curSeriesMiscelaneas;


    return TRUE;
}
/*
 * Obtener Valor total de la deuda financiada y saldo pendiente para la cuota ingresada
 * por parametro.
 */

int ifnObtenerMontosTotalesCuota( rg_cuotas pstCuota, double *pdMtoTotDeuda, double *pdMtoSaldoPend, int record)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int    ihCodCliente        = 0;
    long   lhCodConcepto       = 0L;
    long   lhNumFolio          = 0L;
    double dhMtoDeudaCartera   = 0.0;
    double dhMtoPagadoCartera  = 0.0;
    double dhTotalCancelado    = 0.0;
    int    ihSecCuota          = 0; 

    EXEC SQL END   DECLARE SECTION;

    double dMontoTotalDeuda = 0.0;
    double dSaldoPendiente  = 0.0;
    int    ihRecord = 0;

    char *pszModulo="ifnObtenerMontosTotalesCuota";

    vDTrazasLog (pszModulo,"\tDentro de la funcion(%s):  \n"
                           "\t\tCodigo de Cliente : [%d] \n"
                           "\t\tCodigo de Concepto: [%ld]\n"
                           "\t\tNumero de folio   : [%ld]"
                          ,LOG05,pszModulo,pstCuota.iCodCliente, pstCuota.iCod_Concepto, pstCuota.lNum_Folio);


    ihCodCliente  = pstCuota.iCodCliente;
    lhCodConcepto = pstCuota.iCod_Concepto;
    lhNumFolio    = pstCuota.lNum_Folio;
    ihSecCuota    = pstCuota.iSecCuota;
    ihRecord      = record;

    if (ihRecord == 1)
    {
        EXEC SQL
            SELECT
                SUM(A.IMPORTE_DEBE),
                SUM(A.IMPORTE_HABER)
            INTO
                :dhMtoDeudaCartera,
                :dhMtoPagadoCartera
            FROM
                CO_CARTERA A
            WHERE
                A.COD_CLIENTE      = :ihCodCliente
                AND A.NUM_FOLIO    = :lhNumFolio
                AND NOT EXISTS (SELECT 1 FROM FA_CUOTCREDITO B        
                                WHERE A.COD_CLIENTE = B.COD_CLIENTE   
                                AND   A.COD_CONCEPTO = B.COD_CONCEPTO 
                                AND   A.NUM_FOLIO = B.NUM_FOLIO       
                                AND   A.NUM_CUOTA = B.NUM_CUOTA       
                                AND   A.SEC_CUOTA = B.SEC_CUOTA)      
            GROUP BY
                A.COD_CLIENTE,
                A.NUM_FOLIO;
    }
    else if (ihRecord == 2) 
    {

        EXEC SQL
            SELECT
                SUM(A.IMPORTE_DEBE),
                SUM(A.IMPORTE_HABER)
            INTO
                :dhMtoDeudaCartera,
                :dhMtoPagadoCartera
            FROM
                CO_CARTERA A
            WHERE
                A.COD_CLIENTE      = :ihCodCliente
                AND A.COD_CONCEPTO = :lhCodConcepto
                AND A.NUM_FOLIO    = :lhNumFolio
                AND NOT EXISTS (SELECT 1 FROM FA_CUOTCREDITO B       
                                WHERE A.COD_CLIENTE = B.COD_CLIENTE  
                                AND   A.COD_CONCEPTO = B.COD_CONCEPTO
                                AND   A.NUM_FOLIO = B.NUM_FOLIO     
                                AND   A.NUM_CUOTA = B.NUM_CUOTA     
                                AND   A.SEC_CUOTA = B.SEC_CUOTA)    
            GROUP BY
                A.COD_CLIENTE,
                A.COD_CONCEPTO,
                A.NUM_FOLIO;
    }


    if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
    {
        vDTrazasLog (pszModulo,"\n\nERROR:(%s): En SELECT A CO_CARTERA, SQLCODE: [%d].", LOG01,pszModulo,sqlca.sqlcode);
        return FALSE;
    }

    if(SQLCODE == SQLNOTFOUND)
    {
        vDTrazasLog (pszModulo,"\n\nATENCION:(%s): No se encuentran datos en CO_CARTERA, Numero de registros: [%d]."
                              , LOG05,pszModulo,sqlca.sqlerrd[2]);

        dhMtoDeudaCartera  = 0.0;
        dhMtoPagadoCartera = 0.0;
    }

    if (ihSecCuota == 0)
    {

        EXEC SQL
        SELECT
            SUM(A.IMPORTE_HABER)
        INTO
            :dhTotalCancelado
        FROM
            CO_CANCELADOS A
        WHERE
            A.COD_CLIENTE      = :ihCodCliente
            AND A.NUM_FOLIO    = :lhNumFolio
        GROUP BY
            A.COD_CLIENTE,
            A.NUM_FOLIO;
    }
    else
    {

        EXEC SQL
        SELECT
            SUM(A.IMPORTE_HABER)
        INTO
            :dhTotalCancelado
        FROM
            CO_CANCELADOS A
        WHERE
            A.COD_CLIENTE      = :ihCodCliente
            AND A.COD_CONCEPTO = :lhCodConcepto
            AND A.NUM_FOLIO    = :lhNumFolio
        GROUP BY
            A.COD_CLIENTE,
            A.COD_CONCEPTO,
            A.NUM_FOLIO;
    }

    if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
    {
        vDTrazasLog (pszModulo,"\n\nERROR:(%s): En SELECT A CO_CANCELADOS, SQLCODE: [%d].", LOG01,pszModulo,sqlca.sqlcode);
        return FALSE;
    }

    if(SQLCODE == SQLNOTFOUND)
    {
        vDTrazasLog (pszModulo,"\n\nATENCION:(%s): No se encuentran datos en CO_CANCELADOS, Numero de registros: [%d].", LOG05,pszModulo,sqlca.sqlerrd[2]);
        dhTotalCancelado = 0.0;
    }


    dMontoTotalDeuda = dhMtoDeudaCartera + dhTotalCancelado;
    dSaldoPendiente  = dMontoTotalDeuda - (dhMtoPagadoCartera + dhTotalCancelado);

    vDTrazasLog("ifnObtenerMontosTotalesCuota", "\t(ifnObtenerMontosTotalesCuota): Monto Total deuda : [%015.4f]\n"
                                                "\t(ifnObtenerMontosTotalesCuota): Saldo Pendiente   : [%015.4f]"
                                                , LOG06, dMontoTotalDeuda, dSaldoPendiente);



    *pdMtoTotDeuda = dMontoTotalDeuda;
    *pdMtoSaldoPend= dSaldoPendiente;

    return TRUE;
}

/* FUNCION QUE RESCATA EL PLAN TARIFARIO DEL ABONADO DE LA GA_INFACCEL*/
/*---------------------------------------------------------------------------*/
/* Funcion: bfnGetPlanTarifAbo                                            */
/*---------------------------------------------------------------------------*/

BOOL bfnGetPlanTarifAbo(long lNumAbonado, long lCodcliente, char *szCodPlanTarifAbo)
{
    EXEC SQL BEGIN DECLARE SECTION;
         char szhCodPlanTarif [4]; EXEC SQL VAR szhCodPlanTarif IS STRING(4);
         long lhCodCliente       ;
         long lhNumAbonado       ;
    EXEC SQL END   DECLARE SECTION;


    lhCodCliente = lCodcliente;
    lhNumAbonado = lNumAbonado;

    EXEC SQL
           SELECT COD_PLANTARIF 
           INTO   :szhCodPlanTarif
           FROM   GA_INTARCEL A
           WHERE  A.COD_CLIENTE = :lhCodCliente 
           AND    A.NUM_ABONADO   = :lhNumAbonado
           AND    A.FEC_DESDE     =( SELECT MAX(C.FEC_DESDE)  
                                       FROM   GA_INTARCEL C
                                       WHERE  C.COD_CLIENTE   = :lhCodCliente
                                       AND    C.NUM_ABONADO   = :lhNumAbonado);

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog ("bfnGetPlanTarifAbo","\n\t\t* En sentenia SELECT, Codigo: [%d]", LOG01,sqlca.sqlcode);
        return FALSE;
    }

    strcpy (szCodPlanTarifAbo, szhCodPlanTarif);

    return (TRUE);
}

int ifnCmpOrden(const void *cad1,const void *cad2)
{
    return ( strcmp (((ST_ORDEN  *)cad1)->szKey,((ST_ORDEN  *)cad2)->szKey) );

}

int ifnLiberaDetCons (void)
{
    free(stFaDetCons.stDetConsumo);
    memset (&stFaDetCons,0,sizeof(stFaDetCons));

  
    free(stOrden2DetConsumo.stOrden);
    memset(&stOrden2DetConsumo, 0, sizeof (stOrden2DetConsumo));

    return 1;
}

/* RPL 19-05-2020 FUNCION PARA LIBERAR ESTRUCTURA NUEVA DE DESCUENTOS  */
int ifnLiberaConcDescuentos (void)
{
    free(stConcAllDescuentos.stConcDescuento);
    memset (&stConcAllDescuentos,0,sizeof(stConcAllDescuentos));


    return 1;
}

BOOL fnGrabaAnoProceso (long lCod_Cliente, long lCod_CiclFact, int iCod_Anomalia, char *szObs_Anomalia)
{
    static int  iTitulo;
    static long lsCod_Cliente;
    char modulo[]   ="fnGrabaAnomaliaImpresion";

    char    szhDes_Proceso  [41];
    char    szhObs_Anomalia[101];

    strncpy(szhDes_Proceso,"ImpresionScl",40);
    strncpy(szhObs_Anomalia,szObs_Anomalia,100);

    vDTrazasLog (modulo,"\tDentro de la funcion(%s):  ",LOG03,modulo);
    vDTrazasLog (modulo,"\n\t\t* Valores de Anomalia:"
                        "\t\t* Proceso        [%ld]"
                        "\t\t* Cliente        [%ld]"
                        "\t\t* Ciclo de Fact. [%ld]"
                        "\t\t* Desc. Proceso  [%s]"
                        "\t\t* Cod. Anomalia  [%d]"
                        "\t\t* Desc. Anomalia [%s]"
                        , LOG06,lgNum_Proceso
                        , lCod_Cliente
                        , lCod_CiclFact
                        , szhDes_Proceso
                        , iCod_Anomalia
                        , szhObs_Anomalia);

    if (iTitulo != 1)
    {
        fprintf(fpAnomalias,"PROCESO ANOMALIA|CLIENTE|CICLO DE FACT|DESC PROCESO|COD ANOMALIA|DESC ANOMALIA|\n");
        fprintf(fpAnomalias,"----------------|-------|-------------|------------|------------|-------------|\n");
        iTitulo = 1;
    }

    if (lsCod_Cliente != lCod_Cliente)
    {
        fprintf(fpAnomalias,"%ld|%ld|%ld|%s|%d|%s|\n"
                           ,lgNum_Proceso
                           ,lCod_Cliente
                           ,lCod_CiclFact
                           ,szhDes_Proceso
                           ,iCod_Anomalia
                           ,szhObs_Anomalia);
        lsCod_Cliente = lCod_Cliente;
    }
    
    //RPL PROY CSR 04-08-2020 SE INVICA NUEVA FUNCION QUE REGISTRA LOS DOCUMENTOS CON ANOMALIAS ESTO POR EL CLIENTE
    suma_errores(lCod_Cliente);
    return(TRUE);
}

long lObtieneNumProcAnomalias(void)
{
    char modulo[]   ="bObtieneNumProcAnomalias";
    EXEC SQL BEGIN DECLARE SECTION;
         long    lhNum_Proceso ;
    EXEC SQL END DECLARE SECTION;

    vDTrazasLog (modulo,"\tDentro de la funcion(%s):  ",LOG03,modulo);

    EXEC SQL
    SELECT FA_SEQ_NUMPRO.NEXTVAL
      INTO :lhNum_Proceso
    FROM DUAL;

    if(SQLCODE == SQLOK)
        return(lhNum_Proceso);
    else
    {
        vDTrazasLog (modulo,"\n\t\t* En sentencia SELECT, Codigo: [%d]", LOG01,sqlca.sqlcode);
        return(-1);
    }
}

int bfnLiberarBenefPromo(void)
{
    if (stBenefPromo.stNodo)
    {
        free(stBenefPromo.stNodo);
    }

    stBenefPromo.lNumBenef = 0;

    return TRUE;
}

int bfnCargarBenefPromo(long lCodCliente , long lCodCiclFact)
{
    EXEC SQL BEGIN DECLARE SECTION;
    long   lhNumAbonado;
    char   szhCodEstadoBenef[6]; EXEC SQL VAR szhCodEstadoBenef IS STRING(6);
    char   szhCodPlan       [6]; EXEC SQL VAR szhCodPlan        IS STRING(6);
    char   szhDesPlan      [31]; EXEC SQL VAR szhDesPlan        IS STRING(31);
    int    ihNumPeriodos       ;
    int    ihPeriodosOtor      ;
    int    ihPeriodosRest      ;
    int    ihMinAdicionales    ;
    double dhMontCargaAdic     ;
    char   szhNomUsuario   [31]; EXEC SQL VAR szhNomUsuario     IS STRING(31);
    char   szhFecIngreso   [20]; EXEC SQL VAR szhFecIngreso     IS STRING(20);
    double dhValAcumulado      ;
    char   szhCodEstado     [6]; EXEC SQL VAR szhCodEstado      IS STRING(6);
    char   szhIndReevalua   [2]; EXEC SQL VAR szhIndReevalua    IS STRING(2);
    char   szhTipBeneficio  [6]; EXEC SQL VAR szhTipBeneficio   IS STRING(6);
    long   lhCodCiclFact       ;
    long   lhCodCliente        ;
    int    ihValorCero         ;
    char  szhCod_Estado1    [4]; EXEC SQL VAR szhCod_Estado1    IS STRING(4);
    char  szhCod_Estado2    [4]; EXEC SQL VAR szhCod_Estado2    IS STRING(4);
    int   iCont;
    EXEC SQL END   DECLARE SECTION;

    BENEF_NODO *stBenefNodoTemp;

    vDTrazasLog("bfnCargarBenefPromo", "[INFO] Entrando en bfnCargarBenefPromo \n"
                                       "                   Cod. Cliente:[%ld] \n"
                                       "                   lCodCiclFact:[%ld] \n"
                                     , LOG05, lCodCliente,lCodCiclFact);

    iCont = 0;
    lhCodCiclFact = lCodCiclFact;
    lhCodCliente = lCodCliente;
    strcpy(szhCod_Estado1,"EJE");
    strcpy(szhCod_Estado2,"EPR");
    ihValorCero = 0;
    stBenefPromo.lNumBenef = 0;

    stBenefPromo.stNodo = NULL;

    EXEC SQL DECLARE cursor_benef_promo CURSOR FOR
    SELECT
           A.NUM_ABONADO,
           C.COD_ESTADO,
           B.COD_PLAN,
           NVL(B.DES_PLAN,' '),
           NVL(A.NUM_PERIODOS,:ihValorCero),
           MAX(C.SEC_PERIODO),
           A.NUM_PERIODOS - MAX(C.SEC_PERIODO),
           NVL(B.CNT_MINADIC,:ihValorCero),
           NVL(B.MTO_CARGADIC,:ihValorCero),
           NVL(A.NOM_USUARIO,' '),
           TO_CHAR(A.FEC_INGRESO,'YYYY-MM-DD HH24:MI:SS'),
           NVL(A.VAL_ACUMULADO,:ihValorCero),
           A.COD_ESTADO,
           B.IND_REEVALUA,
           B.TIP_BENEFICIO
    FROM BPT_BENEFICIOS C,BPT_BENEFICIARIOS A, BPD_PLANES B
    WHERE  C.COD_CLIENTE   = :lhCodCliente
    AND    C.COD_PLAN      = B.COD_PLAN
    AND    C.FEC_DESDEAPLI = B.FEC_DESDEAPLI
    AND    A.FEC_INGRESO   = C.FEC_INGRESO
    AND    C.COD_ESTADO   IN (:szhCod_Estado1,:szhCod_Estado2)
    AND    C.COD_CICLFACT  = :lhCodCiclFact
    AND    A.COD_CLIENTE   = C.COD_CLIENTE
    AND    A.NUM_ABONADO   = C.NUM_ABONADO
    AND    A.COD_PLAN      = B.COD_PLAN
    AND    A.FEC_DESDEAPLI = B.FEC_DESDEAPLI
    GROUP BY  A.NUM_ABONADO,C.COD_ESTADO,B.COD_PLAN,B.DES_PLAN,
              A.NUM_PERIODOS,B.CNT_MINADIC,B.MTO_CARGADIC,
              A.NOM_USUARIO,A.FEC_INGRESO,A.VAL_ACUMULADO,
              A.COD_ESTADO,B.IND_REEVALUA,B.TIP_BENEFICIO;

    if (SQLCODE != SQLOK)
    {
        vDTrazasLog("bfnCargarBenefPromo", "[ERROR] (bfnCargarBenefPromo): Error en ejecucion de EXEC SQL DECLARE cursor_benef_promo, SQLCODE: [%d]", LOG01, SQLCODE);
        return(FALSE);
    }

    EXEC SQL OPEN cursor_benef_promo;
    if (SQLCODE != SQLOK)
    {
        vDTrazasLog("bfnCargarBenefPromo", "[ERROR] (bfnCargarBenefPromo): Error en ejecucion de EXEC SQL OPEN cursor_benef_prom, SQLCODE: [%d]", LOG01, SQLCODE);
        return(FALSE);
    }

    for(iCont = 0;;iCont++)
    {
        EXEC SQL FETCH cursor_benef_promo
        INTO :lhNumAbonado,
             :szhCodEstadoBenef,
             :szhCodPlan,
             :szhDesPlan,
             :ihNumPeriodos,
             :ihPeriodosOtor,
             :ihPeriodosRest,
             :ihMinAdicionales,
             :dhMontCargaAdic,
             :szhNomUsuario,
             :szhFecIngreso,
             :dhValAcumulado,
             :szhCodEstado,
             :szhIndReevalua,
             :szhTipBeneficio;

        if(SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
        {
            vDTrazasLog("bfnCargarBenefPromo", "[ERROR] (bfnCargarBenefPromo): Error en ejecucion de EXEC SQL FETCH cursor_benef_promo, SQLCODE: [%d]", LOG01, SQLCODE);
            return(FALSE);
        }

        if(SQLCODE == SQLNOTFOUND)
            break;

        if(!stBenefPromo.stNodo)
        {
            stBenefPromo.stNodo = (BENEF_NODO*)malloc(sizeof(BENEF_NODO) );
        }
        else
        {
            stBenefPromo.stNodo = (BENEF_NODO*)realloc(stBenefPromo.stNodo, (int) sizeof(BENEF_NODO) * (iCont+1));
        }

        if(!stBenefPromo.stNodo)
        {
            vDTrazasLog("bfnCargarBenefPromo", "[ERROR] (bfnCargarBenefPromo): Error en Alocacion de memoria dinamica"
                                             , LOG01);
            return(FALSE);
        }

        stBenefNodoTemp = &(stBenefPromo.stNodo)[iCont];
        memset(stBenefNodoTemp, 0, sizeof(BENEF_NODO));

        stBenefNodoTemp->lNumAbonado = lhNumAbonado;
        strcpy(stBenefNodoTemp->szCodEstadoBenef,szhCodEstadoBenef);
        strcpy(stBenefNodoTemp->szCodPlan,szhCodPlan);
        strcpy(stBenefNodoTemp->szDesPlan,szhDesPlan);
        stBenefNodoTemp->iNumPeriodos = ihNumPeriodos;
        stBenefNodoTemp->iPeriodosOtor = ihPeriodosOtor;
        stBenefNodoTemp->iPeriodosRest = ihPeriodosRest;
        stBenefNodoTemp->iMinAdicionales = ihMinAdicionales;
        stBenefNodoTemp->dMontCargaAdic = dhMontCargaAdic;
        strcpy(stBenefNodoTemp->szNomUsuario,szhNomUsuario);
        strcpy(stBenefNodoTemp->szFecIngreso,szhFecIngreso);
        stBenefNodoTemp->dValAcumulado = dhValAcumulado;
        strcpy(stBenefNodoTemp->szCodEstado,szhCodEstado);
        strcpy(stBenefNodoTemp->szIndReevalua,szhIndReevalua);
        strcpy(stBenefNodoTemp->szTipBeneficio,szhTipBeneficio);

        stBenefPromo.lNumBenef++;
    }

    EXEC SQL CLOSE cursor_benef_promo;

    vDTrazasLog("bfnCargarBenefPromo", "bfnCargarBenefPromo(): Cantidad de registros rescatados : [%d]"
                                     , LOG05, stBenefPromo.lNumBenef);

    return TRUE;
}

/******************************************************************************************/
/** Informacisn de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisisn                                            : */
/**  %PR% */
/** Autor de la Revisisn                                : */
/**  %AUTHOR% */
/** Estado de la Revisisn ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creacisn de la Revisisn                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/
