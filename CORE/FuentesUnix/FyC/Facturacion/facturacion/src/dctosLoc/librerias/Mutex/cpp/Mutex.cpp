#ifndef NO_INDENT
#ident "@(#)$RCSfile: Mutex.cpp,v $ $Revision: 1.3 $ $Date: 2008/05/22 17:36:00 $"
#endif

///
/// \file Mutex.cpp
///


#include "Mutex.h"

#ifdef WIN32
// __fastcall make sure to pass argument as register for direct atomic operation (not in callstack)
// volatile make sure to manipulate variable not in register, assume it migth be change by other process
// not prolog and return stuff generated by compiler (faster)
#ifndef __GNUWIN32__
__declspec(naked)
unsigned long __fastcall myExchange(volatile unsigned long *oldVal,
				                    volatile unsigned long newVal) throw()
{
__asm
  {
	 mov eax, [ecx]
	 xchg [ecx], edx
   	 ret     
  }  
}
#else // __GNUWIN32__
unsigned long myExchange(volatile unsigned long *oldVal,
                         volatile unsigned long newVal) throw()
{
__asm __volatile(".intel_syntax noprefix \n"
                 "mov eax, [ebp+16] \n"
                 "mov ecx, [ebp+8] \n"
                 "mov edx, [ebp+12] \n"
                 "xchg dword ptr [ecx], edx; \n"
                 ".att_syntax \n"
                 "\n");
}    
#endif // __GNUWIN32__



#ifndef __GNUWIN32__
__declspec(naked)
unsigned long __fastcall myInterlockedExchange(volatile unsigned long *oldVal,
						volatile unsigned long newVal) throw()
{
__asm
  {
	 mov eax, [ecx]
	 lock xchg [ecx], edx
   	 ret     
  }
}
#else // __GNUWIN32__
unsigned long  myInterlockedExchange(volatile unsigned long *oldVal,
						             volatile unsigned long newVal) throw()
{
__asm __volatile(".intel_syntax noprefix \n"
                 "mov eax, [ebp+16] \n"
                 "mov ecx, [ebp+8] \n"
                 "mov edx, [ebp+12] \n"
                 "lock xchg dword ptr [ecx], edx; \n"
                 ".att_syntax \n"
                 "\n");
}    
#endif // __GNUWIN32__


#ifndef __GNUWIN32__
__declspec(naked) bool __fastcall LockCompareAndExchange(volatile unsigned long* dest, int source, int comparend)
{
__asm 
{
     mov eax, [esp+4]
     lock cmpxchg dword ptr [ecx], edx;   // if([ECX]==EAX){ZF=1;[ECX]=EDX;}else ZF=0;
     setz al                              // return 1 si ZF == 0
     ret 4                                // Return al (bool format)
}
}
#else
bool LockCompareAndExchange(volatile unsigned long* dest, int source, int comparend)
{
__asm __volatile(".intel_syntax noprefix \n"
                 "mov eax, [ebp+16] \n"
                 "mov ecx, [ebp+8] \n"
                 "mov edx, [ebp+12] \n"
                 "lock cmpxchg dword ptr [ecx], edx; \n"
                 "setz al \n"
                 ".att_syntax \n"
                 "\n");
}
#endif // __GNUWIN32__
#endif // WIN32




///////////////////////////////////////////////////////////////////////////////////////////////
POSIXMutex::POSIXMutex()
{
#ifndef WIN32
	pthread_mutex_init(&_mutexLock, 0);
#else
	_mutexLock = UNLOCKED;
#endif
}




///////////////////////////////////////////////////////////////////////////////////////////////
POSIXMutex::~POSIXMutex()
{
#ifndef WIN32
   pthread_mutex_destroy(&_mutexLock);
#endif
}




///////////////////////////////////////////////////////////////////////////////////////////////
void POSIXMutex::lock() volatile 
{
#ifndef WIN32
	pthread_mutex_lock(const_cast<LockType*>(&_mutexLock));
#else
	static int numProcessors = getNumProcessors();
	if (numProcessors == 1)
	{
/*
#ifndef __GNUWIN32__
       while(myExchange(&_mutexLock, LOCKED) != UNLOCKED)
#else
       while(InterlockedExchange(&_mutexLock, LOCKED) != UNLOCKED)		
#endif
*/
      while(!myExchange(&_mutexLock, LOCKED) != UNLOCKED)
		{
			yield();
		}

	}else{

/*
#ifndef __GNUWIN32__
		while(LockCompareAndExchange(&_mutexLock, LOCKED, UNLOCKED))
#else
        while(InterlockedCompareExchange(&_mutexLock, LOCKED, UNLOCKED) != UNLOCKED)
#endif
*/
        int count = 0;
		while(!LockCompareAndExchange(&_mutexLock, LOCKED, UNLOCKED))
		{
			count++;
			if (count > 100)
			{
				yield();
				count = 0;
			}
		}

	}
#endif
}




///////////////////////////////////////////////////////////////////////////////////////////////
void POSIXMutex::unlock() volatile
{
#ifndef WIN32
    pthread_mutex_unlock(const_cast<LockType*>(&_mutexLock));
#else
    _mutexLock = UNLOCKED;
#endif
}





#ifdef WIN32
///////////////////////////////////////////////////////////////////////////////////////////////
void POSIXMutex::yield(void) volatile
{
	Sleep(10); // 10 milli-sec
}




///////////////////////////////////////////////////////////////////////////////////////////////
int POSIXMutex::getNumProcessors(void) volatile
{
	static int numProcessors = 0;
	if (numProcessors == 0)
	{
		SYSTEM_INFO infoReturn[1];
		GetSystemInfo(infoReturn);
		numProcessors = (int) (infoReturn -> dwNumberOfProcessors);
	}

	return numProcessors;
}
#endif
