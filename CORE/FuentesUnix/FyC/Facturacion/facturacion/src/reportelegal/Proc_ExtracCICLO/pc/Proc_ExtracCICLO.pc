/* *********************************************************************** */
/* *  Fichero : Proc_ExtracCICLO.pc                                      * */
/* *  Extractor de data para la Generacion de Reportes Legales		 * */
/* *  Autor : Patricio Gonzalez Gomez	                                 * */
/* *  Modif : 								 * */
/* *  Parametros : 							 * */
/* *         -u Usuario/Password                                         * */
/* *         -c Ciclo de Facturacion 	                                 * */
/* *         -l Nivel de Log						 * */
/* *********************************************************************** */

#define _PROC_EXTRACCICLO_PC_

#include <deftypes.h>
#include <stdlib.h>
#include <New_Interfact.h>
#include <GenFA.h>
#include "Proc_ExtracCICLO.h"

/****************************************************************************/
/*           Variables de Retorno de Oracle-Pro-C                           */
/****************************************************************************/

char  modulo[30];

EXEC SQL INCLUDE sqlca;




/* DESDE AQUI PGG FUNCIONES NUEVAS */
void trim (const char *c, char *result)
{
   char *l;
   char *r;
   for(l=(char *)c;  *l==' '; l++);
   for(r=(char *)c+strlen(c)-1;  *r==' '; r--);

   strncpy(result, l, (r>=l)?r-l+1:1);
   result[r-l+1]=0;
}

/* --------Estructura DatosAcum Desde Aqui */

void vfnPrintDatosAcum (REG_DATOSACUM *pstDatosAcum, int iNumAcum)
{
        int i = 0;

	strcpy(modulo,"vfnPrintDatosAcum");
        vDTrazasLog(modulo,"\n\t\t* Despliegue de la Carga de Datos Acum ... [%d]", LOG05, iNumAcum);

        for (i=0;i<iNumAcum;i++)
        {
                vDTrazasLog(modulo,	"----------------------------------------------------\n"
					"pstDatosAcum[%d].lNum_Secuenci      		[%ld]\n"
					"pstDatosAcum[%d].lCod_Tipdocum      		[%ld]\n"
					"pstDatosAcum[%d].lCod_Vendedor_Agente		[%ld]\n"
					"pstDatosAcum[%d].szLetra         		[%s] \n"
					"pstDatosAcum[%d].lCod_Centremi      		[%ld]\n"
					"pstDatosAcum[%d].dTot_Pagar         		[%f] \n"					
					"pstDatosAcum[%d].szFec_Emision	     		[%s] \n"
					"pstDatosAcum[%d].dAcum_Netograv    		[%f] \n"
					"pstDatosAcum[%d].dAcum_Netonograv   		[%f] \n"
					"pstDatosAcum[%d].lInd_Ordentotal		[%ld]\n"
					"pstDatosAcum[%d].lInd_Anulada          	[%ld]\n"
					"pstDatosAcum[%d].lNum_Folio	        	[%ld]\n"
					"pstDatosAcum[%d].szFec_Vencimie		[%s] \n"
					"pstDatosAcum[%d].lCod_Ciclfact	      		[%ld]\n"
					"pstDatosAcum[%d].lCod_Concepto	      		[%ld]\n"  
					"pstDatosAcum[%d].szFec_Efectividad	        [%s] \n"
					"pstDatosAcum[%d].dImp_Concepto	                [%f] \n"
					"pstDatosAcum[%d].szCod_Provincia	        [%s]\n"
					"pstDatosAcum[%d].szCod_Comuna	                [%s]\n"					
					"pstDatosAcum[%d].lCod_Ciudad	                [%ld]\n"
					"pstDatosAcum[%d].dImp_Montobase	        [%f] \n"
					"pstDatosAcum[%d].lInd_Factur		        [%ld]\n"
					"pstDatosAcum[%d].dImp_Facturable	        [%f] \n"
					"pstDatosAcum[%d].szCod_Tipidtrib               [%s] \n"
					"pstDatosAcum[%d].szNum_Identtrib               [%s] \n"
					"pstDatosAcum[%d].szNom_Cliente                 [%s] \n"
					"pstDatosAcum[%d].szNom_Apeclien1               [%s] \n"
					"pstDatosAcum[%d].szNom_Apeclien2               [%s] \n"
					"pstDatosAcum[%d].szDes_Tipident                [%s] \n"
					"pstDatosAcum[%d].lCod_Zonaimpo                [%ld] \n"					
					,LOG05
					,i , pstDatosAcum[i].lNum_Secuenci      			
					,i , pstDatosAcum[i].lCod_Tipdocum      			
					,i , pstDatosAcum[i].lCod_Vendedor_Agente			
					,i , pstDatosAcum[i].szLetra         		
					,i , pstDatosAcum[i].lCod_Centremi      			
					,i , pstDatosAcum[i].dTot_Pagar         			
					,i , pstDatosAcum[i].szFec_Emision	     			
					,i , pstDatosAcum[i].dAcum_Netograv    		
					,i , pstDatosAcum[i].dAcum_Netonograv   			
					,i , pstDatosAcum[i].lInd_Ordentotal		                
					,i , pstDatosAcum[i].lInd_Anulada          	                
					,i , pstDatosAcum[i].lNum_Folio	        	
					,i , pstDatosAcum[i].szFec_Vencimie		                
					,i , pstDatosAcum[i].lCod_Ciclfact	      			
					,i , pstDatosAcum[i].lCod_Concepto	      			
					,i , pstDatosAcum[i].szFec_Efectividad	        
					,i , pstDatosAcum[i].dImp_Concepto	                        					
					,i , pstDatosAcum[i].szCod_Provincia	                        
					,i , pstDatosAcum[i].szCod_Comuna	                        
					,i , pstDatosAcum[i].lCod_Ciudad	                        
					,i , pstDatosAcum[i].dImp_Montobase	                        
					,i , pstDatosAcum[i].lInd_Factur		                
					,i , pstDatosAcum[i].dImp_Facturable	                        
					,i , pstDatosAcum[i].szCod_Tipidtrib                      
					,i , pstDatosAcum[i].szNum_Identtrib                      
					,i , pstDatosAcum[i].szNom_Cliente                        
					,i , pstDatosAcum[i].szNom_Apeclien1                      
					,i , pstDatosAcum[i].szNom_Apeclien2                      
					,i , pstDatosAcum[i].szDes_Tipident  		
					,i , pstDatosAcum[i].lCod_Zonaimpo);
        }
}/*************************** vfnPrintDatosAcum *****************************/

static int ifnOpenDatosAcum (void)
{
	int i = 0;
	long	lAnoBusqueda;
	long	lMesBusqueda;
	
	EXEC SQL BEGIN DECLARE SECTION;
  		char    szhCadenaPaso[4096];
  		long	lhDiaHoy;  			
  		long	lhMesHoy;
  		long	lhAnoHoy;
  		char	szhFechaIni[9];
  		char	szhFechaFin[9];
  		long	lhUltimoDiaMes;
	EXEC SQL END DECLARE SECTION ;

	vDTrazasLog(modulo, "\n\t\t* Entro a ifnOpenDatosAcum... ciclo [%ld]\n",   LOG05, stLineaComando.lCodCiclFact);
	
	memset (szhCadenaPaso, '\0', sizeof(szhCadenaPaso));

	sprintf (szhCadenaPaso, "SELECT /*+ ORDERED*/ "
			"A.NUM_SECUENCI				, A.COD_TIPDOCUM        		, A.COD_VENDEDOR_AGENTE 		, A.LETRA		, A.COD_CENTREMI        , "
			"A.TOT_PAGAR    			, TO_CHAR(A.FEC_EMISION, 'DDMMYYYY')	, A.ACUM_NETOGRAV       		, A.ACUM_NETONOGRAV    	, A.IND_ORDENTOTAL	, "
			"A.IND_ANULADA  			, A.NUM_FOLIO				, TO_CHAR(A.FEC_VENCIMIE, 'DDMMYYYY')	, A.COD_CICLFACT       	, B.COD_CONCEPTO        , "
			"TO_CHAR(B.FEC_EFECTIVIDAD, 'DDMMYYYY')	, SUM(B.IMP_CONCEPTO)                	, B.COD_PROVINCIA 			, F.COD_COMUNA          , B.COD_CIUDAD          , "
			"SUM(B.IMP_MONTOBASE)   		, B.IND_FACTUR          		, SUM(B.IMP_FACTURABLE)              	, C.COD_TIPIDENT        , C.NUM_IDENT           , "
			"C.NOM_CLIENTE				, NVL(C.NOM_APECLIEN1, ' ')		, NVL(C.NOM_APECLIEN2, ' ')		, D.DES_TIPIDENT        , A.COD_ZONAIMPO "
			"FROM "
			"FA_HISTCONC_%ld B  		, "
			"FA_HISTDOCU A			, "
			"GE_CLIENTES C  		, "
			"FA_CATEGORIACONCEPTO_TD E	, "
			"GA_DIRECCLI G			, "
			"GE_DIRECCIONES F        	, "
			"GE_TIPIDENT D "
			"WHERE 	B.IND_ORDENTOTAL	= A.IND_ORDENTOTAL "
			"AND B.COD_PRODUCTO		> 0 "
			"AND B.COD_CONCEPTO     	= E.COD_CONCEPTO "
			"AND A.IND_ANULADA 	   	= 0 "
			"AND A.COD_CLIENTE      	= C.COD_CLIENTE "
			"AND C.COD_CLIENTE		= G.COD_CLIENTE "
			"AND C.COD_TIPIDENT      	= D.COD_TIPIDENT "
			"AND A.COD_CICLFACT 	   	= '%ld' "
			"AND E.COD_CONCEPTO		> 0 "
			"AND E.COD_IMPUESTO 		> 0 "
			"AND G.COD_TIPDIRECCION 	= '1' "
			"AND G.COD_DIRECCION    	= F.COD_DIRECCION "
			"GROUP BY "
			"A.NUM_SECUENCI 			, A.COD_TIPDOCUM        		, A.COD_VENDEDOR_AGENTE 		, A.LETRA		, A.COD_CENTREMI	, "
			"A.TOT_PAGAR  				, TO_CHAR(A.FEC_EMISION, 'DDMMYYYY')	, A.ACUM_NETOGRAV       		, A.ACUM_NETONOGRAV     , A.IND_ORDENTOTAL      , "
			"A.IND_ANULADA         			, A.NUM_FOLIO				, TO_CHAR(A.FEC_VENCIMIE, 'DDMMYYYY')	, A.COD_CICLFACT        , B.COD_CONCEPTO 	, "
			"TO_CHAR(B.FEC_EFECTIVIDAD, 'DDMMYYYY')	, B.COD_PROVINCIA               	, F.COD_COMUNA          		, B.COD_CIUDAD          , B.IND_FACTUR  	, "
			"C.COD_TIPIDENT        			, C.NUM_IDENT           		, C.NOM_CLIENTE				, C.NOM_APECLIEN1   	, C.NOM_APECLIEN2       , "
			"D.DES_TIPIDENT        			, A.COD_ZONAIMPO " , stLineaComando.lCodCiclFact, stLineaComando.lCodCiclFact);


	vDTrazasLog(modulo, "\n\t\t* QUERY PRINCIPAL 	[%s]\n",   LOG05, szhCadenaPaso);
	
	EXEC SQL PREPARE sql_select_datosacum FROM :szhCadenaPaso;
	if(SQLCODE != SQLOK)
        {
        	vDTrazasLog(modulo, "\n\t\t* PREPARE=> Cursor_DatosAcum\n",   LOG05);
                return(SQLCODE);
    	}

	EXEC SQL DECLARE Cursor_DatosAcum CURSOR FOR sql_select_datosacum;
	if(SQLCODE != SQLOK)
        {
        	vDTrazasLog(modulo, "\n\t\t* DECLARE=> Cursor_DatosAcum\n",   LOG05);
                return(SQLCODE);
    	}

        EXEC SQL OPEN Cursor_DatosAcum;
    	if(SQLCODE != SQLOK)
        {
        	vDTrazasLog(modulo, "\n\t\t* OPEN=> Cursor_DatosAcum\n",   LOG05);
                return(SQLCODE);
    	}

    	return (SQLCODE);
}/***************************** Final ifnOpenDatosAcum  **********************/

static BOOL ifnFetchDatosAcum (REG_DATOSACUM_HOST *pstHost,long *plNumFilas)
{

         EXEC SQL FETCH Cursor_DatosAcum
             INTO     :pstHost->lNum_Secuenci      	
                     ,:pstHost->lCod_Tipdocum      	
                     ,:pstHost->lCod_Vendedor_Agente	
                     ,:pstHost->szLetra         	
                     ,:pstHost->lCod_Centremi      	
                     ,:pstHost->dTot_Pagar        	
                     ,:pstHost->szFec_Emision	     	
                     ,:pstHost->dAcum_Netograv    	
                     ,:pstHost->dAcum_Netonograv   	
                     ,:pstHost->lInd_Ordentotal	     	
                     ,:pstHost->lInd_Anulada          	
                     ,:pstHost->lNum_Folio	        
                     ,:pstHost->szFec_Vencimie	       	
                     ,:pstHost->lCod_Ciclfact	      	
                     ,:pstHost->lCod_Concepto	        
                     ,:pstHost->szFec_Efectividad	
                     ,:pstHost->dImp_Concepto	        
                     ,:pstHost->szCod_Provincia	        
                     ,:pstHost->szCod_Comuna	         
                     ,:pstHost->lCod_Ciudad	        
                     ,:pstHost->dImp_Montobase	        
                     ,:pstHost->lInd_Factur		
                     ,:pstHost->dImp_Facturable	        
                     ,:pstHost->szCod_Tipidtrib         
                     ,:pstHost->szNum_Identtrib         
                     ,:pstHost->szNom_Cliente           
                     ,:pstHost->szNom_Apeclien1         
                     ,:pstHost->szNom_Apeclien2         
                     ,:pstHost->szDes_Tipident  
                     ,:pstHost->lCod_Zonaimpo;
	
	vDTrazasLog(modulo, "\n\t\t* FETCH=> Error [%ld]\n",   LOG05, SQLCODE);
                     
        if (SQLCODE==SQLOK)
                *plNumFilas = TAM_HOSTS_PEQ;
        else
                if (SQLCODE==SQLNOTFOUND)
                        *plNumFilas = sqlca.sqlerrd[2] % TAM_HOSTS_PEQ;

  	return (SQLCODE);
}/***************************** Final ifnFetchDatosAcum ****************/

int ifnCloseDatosAcum (void)
{

	EXEC SQL CLOSE Cursor_DatosAcum;

	strcpy(modulo,"ifnCloseDatosAcum");
	vDTrazasLog(modulo, "\n\t\t* CLOSE=> Cursor_DatosAcum \n",   LOG05);

	return (SQLCODE);
}/**************************** Final ifnCloseDatosAcum ******************/


int ifnCmpDatosAcum (const void *cad1, const void *cad2)
{
   int rc = 0;

   return
		( (rc = strcmp (((REG_DATOSACUM *)cad1)->szNum_Identtrib,
				((REG_DATOSACUM *)cad2)->szNum_Identtrib    ) )!= 0 )?rc:
   		( (rc = 	((REG_DATOSACUM *)cad1)->lCod_Tipdocum -
        	   		((REG_DATOSACUM *)cad2)->lCod_Tipdocum ) != 0)?rc:
		( (rc = 	((REG_DATOSACUM *)cad1)->lInd_Ordentotal -                     	   /* PGG SOPORTE 02-11-2005 XO-952 */	
   				((REG_DATOSACUM *)cad2)->lInd_Ordentotal ) != 0)?rc:0;         	   /* PGG SOPORTE 02-11-2005 XO-952 */		
        	   		
	                    
}/*********************** Final ifnCmpDatosAcum **********************************/

int iCargaDatosAcum(REG_DATOSACUM **pstDatosAcum, int *iNumAcum)
{
        int     rc = 0;
        long    lNumFilas;
        static  REG_DATOSACUM_HOST pstDatosAcumHost;
        REG_DATOSACUM *pstDatosAcumTemp;
        long lCont;

        strcpy(modulo,"iCargaDatosAcum");
        vDTrazasLog(modulo, "\n\t\t* Carga Estructura de Acumuladores\n",   LOG05);

        *iNumAcum = 0;
        *pstDatosAcum = NULL;

        if (ifnOpenDatosAcum ())
        {
		vDTrazasLog(modulo, "\n\t\t* Fallo la ejecucion del ifnOpenDatosAcum\n",   LOG05);
        	return (FALSE);
        }
	
	vDTrazasLog(modulo, "\n\t\t* Antes del while (rc != SQLNOTFOUND) \n",   LOG05);
        
        while (rc != SQLNOTFOUND)
        {
        rc = ifnFetchDatosAcum (&pstDatosAcumHost,&lNumFilas);
        if (rc != SQLOK  && rc != SQLNOTFOUND)
        {
        	vDTrazasLog(modulo, "\n\t\t* Fallo la ejecucion del ifnFetchDatosAcum\n",   LOG05);
		return (FALSE);
	}

                if (!lNumFilas)
                	break;

                *pstDatosAcum =(REG_DATOSACUM*) realloc(*pstDatosAcum,(((*iNumAcum)+lNumFilas)*sizeof(REG_DATOSACUM)));

                if (!*pstDatosAcum)
                        return (FALSE);

                pstDatosAcumTemp = &(*pstDatosAcum)[(*iNumAcum)];
                memset(pstDatosAcumTemp, 0, sizeof(REG_DATOSACUM)*lNumFilas);
                for (lCont = 0 ; lCont < lNumFilas ; lCont++)
                {
                	pstDatosAcumTemp[lCont].lNum_Secuenci      	=	pstDatosAcumHost.lNum_Secuenci      	[lCont];
                	pstDatosAcumTemp[lCont].lCod_Tipdocum      	=	pstDatosAcumHost.lCod_Tipdocum      	[lCont];
                	pstDatosAcumTemp[lCont].lCod_Vendedor_Agente	=	pstDatosAcumHost.lCod_Vendedor_Agente	[lCont];                	
                	trim(pstDatosAcumHost.szLetra         	[lCont]	, 	pstDatosAcumTemp[lCont].szLetra         	);                	
                	pstDatosAcumTemp[lCont].lCod_Centremi      	=	pstDatosAcumHost.lCod_Centremi      	[lCont];
                	pstDatosAcumTemp[lCont].dTot_Pagar         	=	pstDatosAcumHost.dTot_Pagar         	[lCont];
                	                	
                	trim(pstDatosAcumHost.szFec_Emision    	[lCont]	, 	pstDatosAcumTemp[lCont].szFec_Emision	     	);                	
                	pstDatosAcumTemp[lCont].dAcum_Netograv    	=	pstDatosAcumHost.dAcum_Netograv    	[lCont];
                	pstDatosAcumTemp[lCont].dAcum_Netonograv   	=	pstDatosAcumHost.dAcum_Netonograv   	[lCont];
                	pstDatosAcumTemp[lCont].lInd_Ordentotal	     	=	pstDatosAcumHost.lInd_Ordentotal	[lCont];
                	pstDatosAcumTemp[lCont].lInd_Anulada          	=	pstDatosAcumHost.lInd_Anulada          	[lCont];
                	pstDatosAcumTemp[lCont].lNum_Folio	        =	pstDatosAcumHost.lNum_Folio	        [lCont];                  	
                	trim(pstDatosAcumHost.szFec_Vencimie	[lCont]	, 	pstDatosAcumTemp[lCont].szFec_Vencimie		);                	
                	pstDatosAcumTemp[lCont].lCod_Ciclfact	      	=       pstDatosAcumHost.lCod_Ciclfact	      	[lCont];
                	pstDatosAcumTemp[lCont].lCod_Concepto	        =       pstDatosAcumHost.lCod_Concepto	        [lCont];                	
                	trim(pstDatosAcumHost.szFec_Efectividad	[lCont]	, 	pstDatosAcumTemp[lCont].szFec_Efectividad	);                	
                	pstDatosAcumTemp[lCont].dImp_Concepto	        =       pstDatosAcumHost.dImp_Concepto	        [lCont];
                	trim(pstDatosAcumHost.szCod_Provincia	        [lCont], pstDatosAcumTemp[lCont].szCod_Provincia	        );
                	trim(pstDatosAcumHost.szCod_Comuna	        [lCont], pstDatosAcumTemp[lCont].szCod_Comuna	        	);
                	pstDatosAcumTemp[lCont].lCod_Ciudad	        =       pstDatosAcumHost.lCod_Ciudad	        [lCont];
                	pstDatosAcumTemp[lCont].dImp_Montobase	        =       pstDatosAcumHost.dImp_Montobase	        [lCont];
                	pstDatosAcumTemp[lCont].lInd_Factur		=       pstDatosAcumHost.lInd_Factur		[lCont];
                	pstDatosAcumTemp[lCont].dImp_Facturable	        =       pstDatosAcumHost.dImp_Facturable	[lCont];
                	trim(pstDatosAcumHost.szCod_Tipidtrib	[lCont]	, 	pstDatosAcumTemp[lCont].szCod_Tipidtrib  	); 
                	trim(pstDatosAcumHost.szNum_Identtrib	[lCont]	, 	pstDatosAcumTemp[lCont].szNum_Identtrib  	);
                	trim(pstDatosAcumHost.szNom_Cliente  	[lCont]	, 	pstDatosAcumTemp[lCont].szNom_Cliente    	);
                	trim(pstDatosAcumHost.szNom_Apeclien1	[lCont]	, 	pstDatosAcumTemp[lCont].szNom_Apeclien1  	);
                	trim(pstDatosAcumHost.szNom_Apeclien2	[lCont]	, 	pstDatosAcumTemp[lCont].szNom_Apeclien2  	);
                	trim(pstDatosAcumHost.szDes_Tipident 	[lCont]	, 	pstDatosAcumTemp[lCont].szDes_Tipident   	);
                	pstDatosAcumTemp[lCont].lCod_Zonaimpo	        =       pstDatosAcumHost.lCod_Zonaimpo	[lCont];
                	
                	
		}
                (*iNumAcum) += lNumFilas;

        }/* fin while */

        vDTrazasLog(modulo,  "\n\t\t* Cantidad de Acumladores cargados [%d]\n",   LOG05, *iNumAcum);

        rc = ifnCloseDatosAcum();
        if (rc != SQLOK)
                return (FALSE);

	if (*iNumAcum == 0)
	{
		vDTrazasLog(modulo,  "\n\t\t* No existe data que cargar. Proceso Finalizado.\n",   LOG05);
		exit(0);
	}	

	
        return (TRUE);
}

/* --------Estructura DatosAcum Hasta Aqui */


BOOL bfnCargaEstructuras()
{

char modulo[]="bfnCargaEstructuras";
BOOL bExiste = TRUE;
int   i;
int   iContLeidos = 0;
int   iContTotal  = 0;

	if(!iCargaDatosAcum(&pstDatosAcum.stDatosAcum, &pstDatosAcum.iCantDatosAcum)!= SQLOK)
	{
		strcpy(modulo, "bfnCargaEstructuras");
		vDTrazasLog(modulo, "Error al Cargar los datos de acumulacion. Proceso se cancela.\n",   LOG05);
		return(FALSE);
	}
	
	qsort((void *) pstDatosAcum.stDatosAcum, pstDatosAcum.iCantDatosAcum, sizeof(REG_DATOSACUM), ifnCmpDatosAcum);
	
	vDTrazasLog(modulo,  "\n\t\t* MISMA ESTRUCTURA PERO ORDENADA POR CLIENTE \n",   LOG05);
	vfnPrintDatosAcum (pstDatosAcum.stDatosAcum, pstDatosAcum.iCantDatosAcum);
	
	return (TRUE);
}

BOOL iCargaTablasFacturacion()
{
	int i;
	char	szNumIdentAux[21];
	long	lCod_TipdocumAux;
	long	lInd_OrdenTotalAux;	/* PGG SOPORTE 02-11-2005 XO-952 */
	int 	iIndConceptoOK=0;
	int	a,k;
		
	EXEC SQL BEGIN DECLARE SECTION;
		long	lhNum_Secuenci      		        ;		
		long	lhCod_Tipdocum      		        ;
		long	lhCod_Vendedor_Agente		        ;
		char	szhLetra         		[1  + 1];
		long	lhCod_Centremi      		        ;
		double	dhTot_Pagar         		        ;
		long	lhCod_Cliente			        ;
		char	szhFec_Emision	     		[8  + 1];
		double	dhAcum_Netograv    		        ;
		double	dhAcum_Netonograv   		        ;
		long	lhInd_Ordentotal	     		;
		long	lhInd_Anulada          		        ;
		long	lhNum_Folio	        	        ;
		char	szhFec_Vencimie	       		[8  + 1];
		long	lhCod_Ciclfact	      		        ;
		long	lhCod_Concepto	        	        ;
		char	szhFec_Efectividad		[8  + 1];
		double	dhImp_Concepto	        	        ;		
		char	szhCod_Provincia	        [3  + 1];		
		char	szhCod_Comuna			[5  + 1];
		long	lhCod_Ciudad	        	        ;
		double	dhImp_Montobase	        	        ;
		long	lhInd_Factur			        ;
		double	dhImp_Facturable			;
		char	szhCod_Tipidtrib         	[2  + 1];
		char	szhNum_Identtrib         	[20 + 1];
		char	szhNom_Cliente           	[50 + 1];
		char	szhNom_Apeclien1         	[20 + 1];
		char	szhNom_Apeclien2         	[20 + 1];
		char	szhDes_Tipident          	[20 + 1];    
		
		char	szhCod_Impuesto			[5  + 1];
		char	szhDes_Impuesto			[20 + 1];
		double	dhAcumIva 				; 
		double	dhAcumIce 				; 
		long	lhCod_Zonaimpo				;
		long	lhAcumNCredito				;
		long	lhAcumNDebito                           ;  
		long	lhAcumDocumentos			;
	
		double	dhTot_MtoGrav                           ;
		double	dhTot_MtoExe                            ;
		double	dhTot_MtoIva                            ;
		double	dhTot_MtoIce				;
		
		int 	ihCantidadRegs				;
		
	EXEC SQL END DECLARE SECTION;
	
	lhAcumNCredito  = 0;
	lhAcumNDebito	= 0;
	lhAcumDocumentos= 0;
	
	dhTot_MtoGrav   = 0.0;
	dhTot_MtoExe    = 0.0;
	dhTot_MtoIva    = 0.0;
	dhTot_MtoIce	= 0.0;
        
        dhAcumIva 	= 0.0;
        dhAcumIce       = 0.0;
        
        
        trim (pstDatosAcum.stDatosAcum[0].szNum_Identtrib, szNumIdentAux);        
        lCod_TipdocumAux = pstDatosAcum.stDatosAcum[0].lCod_Tipdocum;
        lInd_OrdenTotalAux = 0;						/* PGG SOPORTE 02-11-2005 XO-952 */
                
	strcpy(szhNum_Identtrib,  pstDatosAcum.stDatosAcum[0].szNum_Identtrib);
	strcpy(szhCod_Tipidtrib,  pstDatosAcum.stDatosAcum[0].szCod_Tipidtrib);
	lhCod_Tipdocum = pstDatosAcum.stDatosAcum[0].lCod_Tipdocum;
        
        
        
        EXEC SQL SELECT COUNT(1)
		INTO :ihCantidadRegs
		FROM 	FA_RESUMEN_MONTOSIMP_TO 
		WHERE 	NUM_IDENTIFICACION 	= :szhNum_Identtrib
		AND 	COD_TIPIDENT 		= :szhCod_Tipidtrib
		AND 	TIPO_DOCUMENTO 		= :lhCod_Tipdocum;
        
        if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
	{
		vDTrazasLog(modulo, "Error En SELECT COUNT(1) en FA_RESUMEN_MONTOSIMP_TO. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
		return (FALSE);
	}
	
	if (ihCantidadRegs == 0)
        {
        
		EXEC SQL INSERT INTO FA_RESUMEN_MONTOSIMP_TO 
	        			(NUM_IDENTIFICACION, COD_TIPIDENT, ULT_FECHA_PERIODO, TIPO_DOCUMENTO, 
					TOT_MONTOGRAV, TOT_MONTOEXE, TOT_MONTOIVA, TOT_MONTOICE, 
					CANT_DOCVTAEMI, CANT_NCEMI, CANT_NDEMI, TOT_MONTOICEIMP)
				VALUES	(:szhNum_Identtrib	, :szhCod_Tipidtrib , to_date('01012001','DDMMYYYY'), :lhCod_Tipdocum, 
					0,0,0,0,
					0,0,0,0);
	        
		if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
		{
			vDTrazasLog(modulo, "Error En INSERT a la FA_RESUMEN_MONTOSIMP_TO. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
			return (FALSE);
		}
	}

        
	for (i=0;i < pstDatosAcum.iCantDatosAcum; i++)
	{
		if((strcmp(szNumIdentAux, pstDatosAcum.stDatosAcum[i].szNum_Identtrib) == 0) &&
			(lCod_TipdocumAux == pstDatosAcum.stDatosAcum[i].lCod_Tipdocum))
		{
			lhNum_Secuenci      		= pstDatosAcum.stDatosAcum[i].lNum_Secuenci      	; 	/*	-       */
			lhCod_Tipdocum      		= pstDatosAcum.stDatosAcum[i].lCod_Tipdocum      	;       /*	A - D   */
			lhCod_Vendedor_Agente		= pstDatosAcum.stDatosAcum[i].lCod_Vendedor_Agente	;       /*	-       */
			strcpy(szhLetra        		, pstDatosAcum.stDatosAcum[i].szLetra         		);      /*	-       */
			lhCod_Centremi      		= pstDatosAcum.stDatosAcum[i].lCod_Centremi      	;       /*	-       */
			dhTot_Pagar         		= pstDatosAcum.stDatosAcum[i].dTot_Pagar         	;       /*	D       */			
			strcpy(szhFec_Emision	     	, pstDatosAcum.stDatosAcum[i].szFec_Emision	     	);      /*	D       */
			dhAcum_Netograv    		= pstDatosAcum.stDatosAcum[i].dAcum_Netograv    	;       /*	D       */
			dhAcum_Netonograv   		= pstDatosAcum.stDatosAcum[i].dAcum_Netonograv   	;       /*	D       */
			lhInd_Ordentotal	     	= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal	     	;       /*	D       */
			lhInd_Anulada          		= pstDatosAcum.stDatosAcum[i].lInd_Anulada          	;       /*	-       */
			lhNum_Folio	        	= pstDatosAcum.stDatosAcum[i].lNum_Folio	        ;       /*	-       */
			strcpy(szhFec_Vencimie	   	, pstDatosAcum.stDatosAcum[i].szFec_Vencimie	       	);      /*	-       */
			lhCod_Ciclfact	      		= pstDatosAcum.stDatosAcum[i].lCod_Ciclfact	      	;       /*	-       */
			lhCod_Concepto	        	= pstDatosAcum.stDatosAcum[i].lCod_Concepto	        ;       /*	D       */
			strcpy(szhFec_Efectividad	, pstDatosAcum.stDatosAcum[i].szFec_Efectividad		);      /*	-       */
			dhImp_Concepto	        	= pstDatosAcum.stDatosAcum[i].dImp_Concepto	        ;       /*	-       */
			strcpy(szhCod_Provincia	        , pstDatosAcum.stDatosAcum[i].szCod_Provincia	        );       /*	A       */
			strcpy(szhCod_Comuna	        , pstDatosAcum.stDatosAcum[i].szCod_Comuna	        );       /*	-       */		
			lhCod_Ciudad	        	= pstDatosAcum.stDatosAcum[i].lCod_Ciudad	        ;       /*	-       */
			dhImp_Montobase	        	= pstDatosAcum.stDatosAcum[i].dImp_Montobase	        ;       /*	-       */
			lhInd_Factur			= pstDatosAcum.stDatosAcum[i].lInd_Factur		;       /*	-       */
			dhImp_Facturable		= pstDatosAcum.stDatosAcum[i].dImp_Facturable	      	;       /*	-       */
			strcpy(szhCod_Tipidtrib         , pstDatosAcum.stDatosAcum[i].szCod_Tipidtrib         	);      /*	A - D   */
			strcpy(szhNum_Identtrib         , pstDatosAcum.stDatosAcum[i].szNum_Identtrib         	);      /*	A - D   */
			strcpy(szhNom_Cliente           , pstDatosAcum.stDatosAcum[i].szNom_Cliente           	);      /*	A       */
			strcpy(szhNom_Apeclien1         , pstDatosAcum.stDatosAcum[i].szNom_Apeclien1         	);      /*	A       */
			strcpy(szhNom_Apeclien2         , pstDatosAcum.stDatosAcum[i].szNom_Apeclien2         	);      /*	A       */
			strcpy(szhDes_Tipident          , pstDatosAcum.stDatosAcum[i].szDes_Tipident          	);      /*	-	*/
			lhCod_Zonaimpo			= pstDatosAcum.stDatosAcum[i].lCod_Zonaimpo	      	;       /*	-       */
			
	
			EXEC SQL SELECT A.DES_IMPUESTO, A.COD_IMPUESTO
				INTO :szhDes_Impuesto, szhCod_Impuesto
				FROM FA_CATEGORIA_IMPUESTO_TD A, FA_CATEGORIACONCEPTO_TD B
				WHERE B.COD_CONCEPTO = :lhCod_Concepto
				AND B.COD_IMPUESTO = A.COD_IMPUESTO 
				AND B.VIGENTE = 'S';
			
			if(SQLCODE!=SQLOK)
			{
				vDTrazasLog(modulo, "Error En SELECT de Impuestos en FA_CATEGORIA_IMPUESTO_TD. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
				return (FALSE);
			}				
			
			trim (szhDes_Impuesto, szhDes_Impuesto);
			trim (szhCod_Impuesto, szhCod_Impuesto);

/* PGG SOPORTE: 20-09-2005 Modificacion para que sean considerados solo los conceptos de IVA e ICE */
/* PGG SOPORTE: 20-09-2005 Ademas se implementa modificacion para que sean considerados los montos de ICE desde el campo dhAcum_Netograv y no dhAcum_Netonograv = 0 */

			if (strcmp(szhDes_Impuesto, "IVA")==0)
			{
				iIndConceptoOK = 0;
				dhAcumIva 	=  dhImp_Concepto	;				
				dhTot_MtoGrav   += dhImp_Montobase; 	/* PGG SOPORTE 06-10-2005 */
				
				dhTot_MtoIva    += dhAcumIva		;
				
				if (lhCod_Tipdocum == 25) 	/* COD_TIPDOCUM = 25 --> NOTA CREDITO  */
				{
					if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
						lhAcumNCredito++;
				}
				else if (lhCod_Tipdocum == 26) /* COD_TIPDOCUM = 26 --> NOTA DEBITO  */
				{
					lhAcumNDebito++;
				}
				else				 /* CUALQUIER OTRO COD_TIPDOCUM */
				{
					if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */						
						lhAcumDocumentos++;
				}
				
			}
			else if (strcmp(szhDes_Impuesto, "ICE")==0)
			{
				iIndConceptoOK = 0;
				dhAcumIce 	=  dhImp_Concepto	;
				dhTot_MtoExe   += dhImp_Montobase; 	/* PGG SOPORTE 06-10-2005 */
				
				dhTot_MtoIce	+= dhAcumIce		;
								
				if (lhCod_Tipdocum == 25) 	/* COD_TIPDOCUM = 25 --> NOTA CREDITO  */
				{	
					if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
						lhAcumNCredito++;
				}
				else if (lhCod_Tipdocum == 26) /* COD_TIPDOCUM = 26 --> NOTA DEBITO  */
				{
					lhAcumNDebito++;
				}
				else				 /* CUALQUIER OTRO COD_TIPDOCUM */
				{
					if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
						lhAcumDocumentos++;
				}
			}
			else
			{
				iIndConceptoOK = 1;			
			}
			
			
			if (iIndConceptoOK == 0)
			{
				vDTrazasLog(modulo, "\t	Valores del Insert... \n",   LOG05);
				
				vDTrazasLog(modulo, "\t	szhNum_Identtrib[%s] \n",   LOG05, szhNum_Identtrib);
				vDTrazasLog(modulo, "\t	szhCod_Tipidtrib[%s] \n",   LOG05, szhCod_Tipidtrib);
				vDTrazasLog(modulo, "\t	lhInd_Ordentotal[%ld]\n",   LOG05, lhInd_Ordentotal);
				vDTrazasLog(modulo, "\t	lhCod_Cliente	[%ld]\n",   LOG05, lhCod_Cliente);
								
		                        
				EXEC SQL
		                INSERT INTO FA_DETALLE_MONTOSIMP_TO(
		                	NUM_IDENTIFICACION	, 
		                	COD_TIPIDENT		, 
		                	ULT_FECHA_PERIODO	, 
					IND_ORDENTOTAL		, 
					COD_CONCEPTO		, 
					COD_IMPUESTO		, 
					FEC_EMISION		,
					TOT_PAGAR		,
					ACUM_NETOGRAV		, 
					ACUM_NETONOGRAV		,
					ACUM_IVA		, 
					COD_ZONAIMPO		,
					COD_TIPDOCUM		,
					ACUM_ICE		,
					TIPO_DOCUMENTO) 
		                VALUES                          (
		                        :szhNum_Identtrib 	, 
		                        :szhCod_Tipidtrib	, 
		                        to_date('01012001', 'DDMMYYYY')		,                  
					:lhInd_Ordentotal	, 
					:lhCod_Concepto       , 
					:szhCod_Impuesto	, 
					to_date(:szhFec_Emision, 'DDMMYYYY')	,
					:dhTot_Pagar		,
					:dhAcum_Netograv	,
					:dhAcum_Netonograv	, 
					:dhAcumIva		, 
					:lhCod_Zonaimpo		, 
					:lhCod_Tipdocum		,
					:dhAcumIce	       	,
					:lhCod_Tipdocum		);  
		
		
		
		            	if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
				{
					vDTrazasLog(modulo, "Error En INSERT a la FA_DETALLE_MONTOSIMP_TO. CORREGIDO ... Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
		                	return (FALSE);
		            	}	
			}

/* PGG SOPORTE: 20-09-2005 HASTA AQUI*/
  	
		}
		else
		{
			
			EXEC SQL UPDATE FA_RESUMEN_MONTOSIMP_TO SET					
					TOT_MONTOGRAV		= TOT_MONTOGRAV		+ :dhTot_MtoGrav, 
					TOT_MONTOEXE		= TOT_MONTOEXE		+ :dhTot_MtoExe	, 
					TOT_MONTOIVA		= TOT_MONTOIVA		+ :dhTot_MtoIva, 
					TOT_MONTOICE		= TOT_MONTOICE		+ :dhTot_MtoIce, 
					CANT_DOCVTAEMI		= CANT_DOCVTAEMI	+ :lhAcumDocumentos, 
					CANT_NCEMI		= CANT_NCEMI		+ :lhAcumNCredito, 
					CANT_NDEMI		= CANT_NDEMI		+ :lhAcumNDebito, 
					COD_PROVINCIA		= :szhCod_Provincia, 
					COD_CANTON		= :szhCod_Comuna, 
					NOM_CLIENTE		= :szhNom_Cliente , 
					NOM_APECLIEN1		= :szhNom_Apeclien1, 
					NOM_APECLIEN2		= :szhNom_Apeclien2, 
					CERRADO 		= 'N'
				WHERE 	NUM_IDENTIFICACION 	= :szhNum_Identtrib
				AND 	COD_TIPIDENT 		= :szhCod_Tipidtrib
				AND 	TIPO_DOCUMENTO		= :lhCod_Tipdocum;
			
			
			
			if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
			{
				vDTrazasLog(modulo, "Error En UPDATE a la FA_RESUMEN_MONTOSIMP_TO. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
	                	return (FALSE);
	            	}

			lhAcumNCredito		= 0	;
			lhAcumNDebito		= 0	;
			lhAcumDocumentos	= 0	;
			dhTot_MtoGrav   	= 0.0	;
			dhTot_MtoExe    	= 0.0	;
			dhTot_MtoIva    	= 0.0	;
			dhTot_MtoIce		= 0.0	;
			dhAcumIva		= 0.0	;
                        dhAcumIce               = 0.0	;
                        

			lhNum_Secuenci      		= pstDatosAcum.stDatosAcum[i].lNum_Secuenci      	; 	/*	-       */
			lhCod_Tipdocum      		= pstDatosAcum.stDatosAcum[i].lCod_Tipdocum      	;       /*	A - D   */
			lhCod_Vendedor_Agente		= pstDatosAcum.stDatosAcum[i].lCod_Vendedor_Agente	;       /*	-       */
			strcpy(szhLetra        		, pstDatosAcum.stDatosAcum[i].szLetra         		);      /*	-       */
			lhCod_Centremi      		= pstDatosAcum.stDatosAcum[i].lCod_Centremi      	;       /*	-       */
			dhTot_Pagar         		= pstDatosAcum.stDatosAcum[i].dTot_Pagar         	;       /*	D       */
			
			strcpy(szhFec_Emision	     	, pstDatosAcum.stDatosAcum[i].szFec_Emision	     	);      /*	D       */
			dhAcum_Netograv    		= pstDatosAcum.stDatosAcum[i].dAcum_Netograv    	;       /*	D       */
			dhAcum_Netonograv   		= pstDatosAcum.stDatosAcum[i].dAcum_Netonograv   	;       /*	D       */
			lhInd_Ordentotal	     	= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal	     	;       /*	D       */
			lhInd_Anulada          		= pstDatosAcum.stDatosAcum[i].lInd_Anulada          	;       /*	-       */
			lhNum_Folio	        	= pstDatosAcum.stDatosAcum[i].lNum_Folio	        ;       /*	-       */
			strcpy(szhFec_Vencimie	   	, pstDatosAcum.stDatosAcum[i].szFec_Vencimie	       	);      /*	-       */
			lhCod_Ciclfact	      		= pstDatosAcum.stDatosAcum[i].lCod_Ciclfact	      	;      
			lhCod_Concepto	        	= pstDatosAcum.stDatosAcum[i].lCod_Concepto	        ;       /*	D       */
			strcpy(szhFec_Efectividad	, pstDatosAcum.stDatosAcum[i].szFec_Efectividad		);      /*	-       */
			dhImp_Concepto	        	= pstDatosAcum.stDatosAcum[i].dImp_Concepto	        ;       /*	-       */
			strcpy(szhCod_Provincia	        , pstDatosAcum.stDatosAcum[i].szCod_Provincia	        );       /*	A       */
			strcpy(szhCod_Comuna	        , pstDatosAcum.stDatosAcum[i].szCod_Comuna	        );       /*	-       */		
			lhCod_Ciudad	        	= pstDatosAcum.stDatosAcum[i].lCod_Ciudad	        ;       /*	-       */
			dhImp_Montobase	        	= pstDatosAcum.stDatosAcum[i].dImp_Montobase	        ;       /*	-       */
			lhInd_Factur			= pstDatosAcum.stDatosAcum[i].lInd_Factur		;       /*	-       */
			dhImp_Facturable		= pstDatosAcum.stDatosAcum[i].dImp_Facturable	      	;       /*	-       */
			strcpy(szhCod_Tipidtrib         , pstDatosAcum.stDatosAcum[i].szCod_Tipidtrib         	);      /*	A - D   */
			strcpy(szhNum_Identtrib         , pstDatosAcum.stDatosAcum[i].szNum_Identtrib         	);      /*	A - D   */
			strcpy(szhNom_Cliente           , pstDatosAcum.stDatosAcum[i].szNom_Cliente           	);      /*	A       */
			strcpy(szhNom_Apeclien1         , pstDatosAcum.stDatosAcum[i].szNom_Apeclien1         	);      /*	A       */
			strcpy(szhNom_Apeclien2         , pstDatosAcum.stDatosAcum[i].szNom_Apeclien2         	);      /*	A       */
			strcpy(szhDes_Tipident          , pstDatosAcum.stDatosAcum[i].szDes_Tipident          	);      /*	-	*/
			lhCod_Zonaimpo			= pstDatosAcum.stDatosAcum[i].lCod_Zonaimpo	      	;       /*	-       */
			
	
			EXEC SQL SELECT A.DES_IMPUESTO, A.COD_IMPUESTO
				INTO :szhDes_Impuesto, szhCod_Impuesto
				FROM FA_CATEGORIA_IMPUESTO_TD A, FA_CATEGORIACONCEPTO_TD B
				WHERE B.COD_CONCEPTO = :lhCod_Concepto
				AND B.COD_IMPUESTO = A.COD_IMPUESTO 
				AND B.VIGENTE = 'S';
			
			if(SQLCODE!=SQLOK)
			{
				vDTrazasLog(modulo, "Error En SELECT de Impuestos en FA_CATEGORIA_IMPUESTO_TD. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
				return (FALSE);
			}	
			
			trim (szhCod_Impuesto, szhCod_Impuesto);
			trim (szhDes_Impuesto, szhDes_Impuesto);

/* PGG SOPORTE: 20-09-2005 Modificacion para que sean considerados solo los conceptos de IVA e ICE */
/* PGG SOPORTE: 20-09-2005 Ademas se implementa modificacion para que sean considerados los montos de ICE desde el campo dhAcum_Netograv y no dhAcum_Netonograv = 0 */
			
			if (strcmp(szhDes_Impuesto, "IVA")==0)
			{
				iIndConceptoOK = 0;
				dhAcumIva 	=  dhImp_Concepto	;
				dhTot_MtoGrav   += dhImp_Montobase; 	/* PGG SOPORTE 06-10-2005 */				
				dhTot_MtoIva    += dhAcumIva		;
				
				
				if (lhCod_Tipdocum == 25) 	/* COD_TIPDOCUM = 25 --> NOTA CREDITO  */
				{
					if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
						lhAcumNCredito++;
				}
				else if (lhCod_Tipdocum == 26) /* COD_TIPDOCUM = 26 --> NOTA DEBITO  */
				{
					lhAcumNDebito++;
				}
				else				 /* CUALQUIER OTRO COD_TIPDOCUM */
				{
					if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
						lhAcumDocumentos++;
				}
				
				
			}
			else if (strcmp(szhDes_Impuesto, "ICE")==0)
			{
				iIndConceptoOK = 0;
				dhAcumIce 	=  dhImp_Concepto	;
				dhTot_MtoExe   += dhImp_Montobase; 	/* PGG SOPORTE 06-10-2005 */
				
				dhTot_MtoIce	+= dhAcumIce		;
				
				
				if (lhCod_Tipdocum == 25) 	/* COD_TIPDOCUM = 25 --> NOTA CREDITO  */
				{
					if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
						lhAcumNCredito++;
				}
				else if (lhCod_Tipdocum == 26) /* COD_TIPDOCUM = 26 --> NOTA DEBITO  */
				{
					lhAcumNDebito++;
				}
				else				 /* CUALQUIER OTRO COD_TIPDOCUM */
				{
					if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
						lhAcumDocumentos++;
				}
				
				
			}
			else
			{
				iIndConceptoOK = 1;
			}	
			
/* PGG SOPORTE: 20-09-2005 HASTA AQUI */

			if (iIndConceptoOK == 0)
			{
				strcpy(szhNum_Identtrib,  pstDatosAcum.stDatosAcum[i].szNum_Identtrib);
	       			strcpy(szhCod_Tipidtrib,  pstDatosAcum.stDatosAcum[i].szCod_Tipidtrib);
				lhCod_Tipdocum = pstDatosAcum.stDatosAcum[i].lCod_Tipdocum;
	        
	        
	        		EXEC SQL SELECT COUNT(1)
	        			INTO :ihCantidadRegs
	        			FROM 	FA_RESUMEN_MONTOSIMP_TO 
	        			WHERE 	NUM_IDENTIFICACION 	= :szhNum_Identtrib
	        			AND 	COD_TIPIDENT 		= :szhCod_Tipidtrib
	        			AND 	TIPO_DOCUMENTO		= :lhCod_Tipdocum;
	        		
	        		if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
				{
					vDTrazasLog(modulo, "Error En SELECT COUNT(1) a la FA_RESUMEN_MONTOSIMP_TO. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
		                	return (FALSE);
		            	}	
	        		
	        		if (ihCantidadRegs == 0)
	        		{	
					EXEC SQL INSERT INTO FA_RESUMEN_MONTOSIMP_TO 
		        			(NUM_IDENTIFICACION, COD_TIPIDENT, ULT_FECHA_PERIODO, TIPO_DOCUMENTO, 
						TOT_MONTOGRAV, TOT_MONTOEXE, TOT_MONTOIVA, TOT_MONTOICE, 
						CANT_DOCVTAEMI, CANT_NCEMI, CANT_NDEMI, TOT_MONTOICEIMP)
					VALUES	(:szhNum_Identtrib	, :szhCod_Tipidtrib , to_date('01012001','DDMMYYYY'), :lhCod_Tipdocum, 
						0,0,0,0,
						0,0,0,0);
		       
					if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
					{
						vDTrazasLog(modulo, "Error En INSERT a la FA_RESUMEN_MONTOSIMP_TO. ihCantidadRegs = 0. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
			                	return (FALSE);
			            	}
				}
				else
				{
	
					EXEC SQL SELECT A.DES_IMPUESTO, A.COD_IMPUESTO
						INTO :szhDes_Impuesto, szhCod_Impuesto
						FROM FA_CATEGORIA_IMPUESTO_TD A, FA_CATEGORIACONCEPTO_TD B
						WHERE B.COD_CONCEPTO = :lhCod_Concepto
						AND B.COD_IMPUESTO = A.COD_IMPUESTO
						AND B.VIGENTE = 'S';
	
					if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
					{
						vDTrazasLog(modulo, "Error En SELECT de obtencion de cod_impuesto. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
			                	return (FALSE);
			            	}
	
	
	
					trim (szhDes_Impuesto, szhDes_Impuesto);
					trim (szhCod_Impuesto, szhCod_Impuesto);
	
					dhAcumIva 		= 0.0;
					dhAcumIce 		= 0.0;
					lhAcumNCredito		= 0;
					lhAcumNDebito   	= 0;
					lhAcumDocumentos	= 0;
	
	
	
	/* PGG SOPORTE: 20-09-2005 Modificacion para que sean considerados solo los conceptos de IVA e ICE */
	
	
					if (strcmp(szhDes_Impuesto, "IVA")==0)
					{
						dhAcumIva = dhImp_Concepto;
	
						if (lhCod_Tipdocum == 25) 	/* COD_TIPDOCUM = 25 --> NOTA CREDITO  */
						{
							if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */							
								lhAcumNCredito++;
						}
						else if (lhCod_Tipdocum == 26) /* COD_TIPDOCUM = 26 --> NOTA DEBITO  */
						{
							lhAcumNDebito++;
						}
						else				 /* CUALQUIER OTRO COD_TIPDOCUM */
						{
							if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
								lhAcumDocumentos++;
						}
	
					}
					else if (strcmp(szhDes_Impuesto, "ICE")==0)
					{
						dhAcumIce = dhImp_Concepto;
	
						if (lhCod_Tipdocum == 25) 	/* COD_TIPDOCUM = 25 --> NOTA CREDITO  */
						{
							if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */							
								lhAcumNCredito++;
						}
						else if (lhCod_Tipdocum == 26) /* COD_TIPDOCUM = 26 --> NOTA DEBITO  */
						{
							lhAcumNDebito++;
						}
						else				 /* CUALQUIER OTRO COD_TIPDOCUM */
						{
							if (lInd_OrdenTotalAux	!= pstDatosAcum.stDatosAcum[i].lInd_Ordentotal)	/* PGG SOPORTE 02-11-2005 XO-952 */
								lhAcumDocumentos++;
						}
					}
	
	/* PGG SOPORTE: 20-09-2005 HASTA AQUI */
					
					EXEC SQL UPDATE FA_RESUMEN_MONTOSIMP_TO SET
							TOT_MONTOGRAV	= TOT_MONTOGRAV	 + :dhTot_MtoGrav	,
							TOT_MONTOEXE	= TOT_MONTOEXE	 + :dhTot_MtoExe	,
							TOT_MONTOIVA	= TOT_MONTOIVA	 + :dhAcumIva		,
							TOT_MONTOICE	= TOT_MONTOICE	 + :dhAcumIce		,
							CANT_DOCVTAEMI	= CANT_DOCVTAEMI + :lhAcumDocumentos	,
							CANT_NCEMI	= CANT_NCEMI	 + :lhAcumNCredito   	,
							CANT_NDEMI	= CANT_NDEMI	 + :lhAcumNDebito
						WHERE 	NUM_IDENTIFICACION 	= :szhNum_Identtrib
	        				AND 	COD_TIPIDENT 		= :szhCod_Tipidtrib
	        				AND 	TIPO_DOCUMENTO 		= :lhCod_Tipdocum;
	
					if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
					{
						vDTrazasLog(modulo, "Error En UPDATE FA_RESUMEN_MONTOSIMP_TO. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
			                	return (FALSE);
			            	}
				
				}
		
		            	
		            	vDTrazasLog(modulo, "\t	------------------------------\n",   LOG05);
				vDTrazasLog(modulo, "\t	Valores del Insert... \n",   LOG05);
				
				vDTrazasLog(modulo, "\t	szhNum_Identtrib[%s] \n",   LOG05, szhNum_Identtrib);
				vDTrazasLog(modulo, "\t	szhCod_Tipidtrib[%s] \n",   LOG05, szhCod_Tipidtrib);
				vDTrazasLog(modulo, "\t	lhInd_Ordentotal[%ld]\n",   LOG05, lhInd_Ordentotal);
				vDTrazasLog(modulo, "\t	lhCod_Concepto	[%ld]\n",   LOG05, lhCod_Concepto);
				vDTrazasLog(modulo, "\t	szhCod_Impuesto	[%s] \n",   LOG05, szhCod_Impuesto);
				vDTrazasLog(modulo, "\t	dhTot_Pagar	[%f] \n",   LOG05, dhTot_Pagar);
				vDTrazasLog(modulo, "\t	dhAcum_Netograv	[%f] \n",   LOG05, dhAcum_Netograv);
				vDTrazasLog(modulo, "\t	lhCod_Cliente	[%ld] \n",   LOG05, lhCod_Cliente);
				
		            	
				
				EXEC SQL
		                INSERT INTO FA_DETALLE_MONTOSIMP_TO(
		                	NUM_IDENTIFICACION	, 
		                	COD_TIPIDENT		, 
		                	ULT_FECHA_PERIODO	, 
					IND_ORDENTOTAL		, 
					COD_CONCEPTO		, 
					COD_IMPUESTO		, 
					FEC_EMISION		, 
					TOT_PAGAR		, 
					ACUM_NETOGRAV		, 
					ACUM_NETONOGRAV		, 
					ACUM_IVA		, 
					COD_ZONAIMPO		, 
					COD_TIPDOCUM		, 
					ACUM_ICE		,
					TIPO_DOCUMENTO)
		                VALUES                          (
		                        :szhNum_Identtrib 	, 
		                        :szhCod_Tipidtrib	, 
		                        to_date('01012001', 'DDMMYYYY'),                   
					:lhInd_Ordentotal	, 
					:lhCod_Concepto       , 
					:szhCod_Impuesto	, 
					to_date(:szhFec_Emision, 'DDMMYYYY'), 
					:dhTot_Pagar		, 
					:dhAcum_Netograv	, 
					:dhAcum_Netonograv	, 
					:dhAcumIva		, 
					:lhCod_Zonaimpo		, 
					:lhCod_Tipdocum		, 
					:dhAcumIce	       	,
					:lhCod_Tipdocum		);
		
		
		
		            	if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
				{
					vDTrazasLog(modulo, "Error En INSERT a la FA_DETALLE_MONTOSIMP_TO. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
		                	return (FALSE);
		            	}
	        	}
		}
		
		trim (pstDatosAcum.stDatosAcum[i].szNum_Identtrib , szNumIdentAux );
		lCod_TipdocumAux = pstDatosAcum.stDatosAcum[i].lCod_Tipdocum;
		lInd_OrdenTotalAux = pstDatosAcum.stDatosAcum[i].lInd_Ordentotal;	/* PGG SOPORTE 02-11-2005 XO-952 */
		
	}
	
	if (pstDatosAcum.iCantDatosAcum > 0)
	{
		
		EXEC SQL UPDATE FA_RESUMEN_MONTOSIMP_TO SET			
			TOT_MONTOGRAV		= TOT_MONTOGRAV		+ :dhTot_MtoGrav, 
			TOT_MONTOEXE		= TOT_MONTOEXE		+ :dhTot_MtoExe	, 
			TOT_MONTOIVA		= TOT_MONTOIVA		+ :dhTot_MtoIva, 
			TOT_MONTOICE		= TOT_MONTOICE		+ :dhTot_MtoIce, 
			CANT_DOCVTAEMI		= CANT_DOCVTAEMI	+ :lhAcumDocumentos, 
			CANT_NCEMI		= CANT_NCEMI		+ :lhAcumNCredito, 
			CANT_NDEMI		= CANT_NDEMI		+ :lhAcumNDebito, 
			COD_PROVINCIA		= :szhCod_Provincia, 
			COD_CANTON		= :szhCod_Comuna, 
			NOM_CLIENTE		= :szhNom_Cliente , 
			NOM_APECLIEN1		= :szhNom_Apeclien1, 
			NOM_APECLIEN2		= :szhNom_Apeclien2, 
			CERRADO 		= 'N'
		WHERE 	NUM_IDENTIFICACION 	= :szhNum_Identtrib
		AND 	COD_TIPIDENT 		= :szhCod_Tipidtrib
		AND 	TIPO_DOCUMENTO		= :lhCod_Tipdocum;
		
		if(SQLCODE!=SQLOK && SQLCODE!=SQLNOTFOUND)
		{
			vDTrazasLog(modulo, "Error En UPDATE a la FA_RESUMEN_MONTOSIMP_TO. Proceso se cancela. Error[%d] [%s]\n",   LOG05, SQLCODE, SQLERRM);
                	return (FALSE);
            	}
            	
	}
	
	return(TRUE);
}


BOOL bfnCargaTablas()
{

char modulo[]="bfnCargaTablas";
BOOL bExiste = TRUE;
int   i;
int   iContLeidos = 0;
int   iContTotal  = 0;


	if(!iCargaTablasFacturacion())
	{
		strcpy(modulo, "bfnCargaTablas");
		vDTrazasLog(modulo, "Error al Cargar Tablas con datos de Facturacion. Proceso se cancela.\n",   LOG05);
		return(FALSE);
	}


	return (TRUE);
}

BOOL bfnVerificaGeneracionReporte()
{
	EXEC SQL BEGIN DECLARE SECTION  ;
		char	szhValor[2];
	EXEC SQL END DECLARE SECTION    ;    

    	EXEC SQL SELECT VAL_PARAMETRO
    		INTO :szhValor 
		FROM GED_PARAMETROS
		WHERE COD_MODULO = 'FA'
		AND NOM_PARAMETRO = 'REPORTES_LEGALES_ECU';

	if(SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
        {
         	vDTrazasLog  (modulo, "Error en la obtencion de parametros. Error-Ora[%ld]: %s\n", LOG01, SQLCODE, SQLERRM);
            	return (FALSE);
        }
        
        if(SQLCODE == SQLNOTFOUND)
        {
            vDTrazasLog  (modulo, "Parametro no encontrado. Error-Ora[%ld]: %s\n", LOG01, SQLCODE, SQLERRM);
            return (FALSE);
        }
        
        if (strcmp(szhValor, "N") == 0)
        {
        	vDTrazasLog  (modulo, "Parametro indica que no se generan reportes legales.\n", LOG01);
            	exit(1);
        }
	
	return (TRUE);

}

BOOL bfnChequeaProcesosPrevios(long lCodCiclFact)
{
    EXEC SQL BEGIN DECLARE SECTION  ;
        long    lhCodCiclo          ;
        int     ihCodEstaPrec       ;
        int     ihTrazCodEstaProc   ;
        int     lhCod_Proceso       ;
    EXEC SQL END DECLARE SECTION    ;
    BOOL bFinCursor_cFaProcTraza=FALSE;

    strcpy (modulo, "bfnChequeaProcesosPrevios");

    lhCodCiclo = lCodCiclFact;
    lhCod_Proceso = iCOD_PROCESO;

    EXEC SQL DECLARE cFaProcTraza CURSOR FOR
        SELECT
                PROC.COD_ESTAPREC,
                NVL(TRAZ.COD_ESTAPROC,0)
        FROM    FA_TRAZAPROC  TRAZ,
                (SELECT A.COD_PROCESO   COD_PROCESO,
                        B.DES_PROCESO   DES_PROCESO,
                        A.COD_PROCPREC  COD_PROCPREC,
                        C.DES_PROCESO   DES_PROCPREC,
                        A.COD_ESTAPREC  COD_ESTAPREC
                FROM    FA_PROCFACTPREC A ,
                        FA_PROCFACT B ,
                        FA_PROCFACT C
                WHERE   A.COD_PROCESO  = :lhCod_Proceso
                AND     A.COD_PROCESO  = B.COD_PROCESO
                AND     A.COD_PROCPREC = C.COD_PROCESO) PROC
        WHERE   TRAZ.COD_CICLFACT (+)  = :lhCodCiclo
        AND     TRAZ.COD_PROCESO  (+)  = PROC.COD_PROCPREC
        ORDER BY PROC.COD_PROCESO;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (modulo, "\n\t**  Error : Declaracion del cursor FA_TRAZAPROC**"                                   
                                    ,LOG01);        
        return (FALSE);
    }

    EXEC SQL OPEN cFaProcTraza;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (modulo, "\n\t**  Error : Al Crear Cursor de Procesos FA_PROCFACT - FA_TRAZAPROC **"
                                    "\n\t\t=> Para el Codigo de Proceso [%d]"
                                    "\n\t\t=> Para el Codigo de Ciclo   [%ld]"
                                    "\n\t\t=> (No Existe Traza Para el Proceso)\n%s\n"
                                    ,LOG01,lhCod_Proceso,lhCodCiclo,SQLERRM);
        vDTrazasError(modulo, "\n\t**  Error : Al Crear Cursor de Procesos FA_PROCFACT - FA_TRAZAPROC **"
                                    "\n\t\t=> Para el Codigo de Proceso [%d]"
                                    "\n\t\t=> Para el Codigo de Ciclo   [%ld]"
                                    "\n\t\t=> (No Existe Traza Para el Proceso)\n%s\n"
                                    ,LOG01,lhCod_Proceso,lhCodCiclo,SQLERRM);
        return (FALSE);
    }
    /****************************************************************************/
    bFinCursor_cFaProcTraza = FALSE ;
    do
    {
        EXEC SQL FETCH cFaProcTraza INTO
                    :ihCodEstaPrec          ,
                    :ihTrazCodEstaProc      ;

        if(SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
        {
            vDTrazasLog  (modulo, "Error en Fetch de Cursor de cFaProcTraza Error-Ora[%ld]: %s"
                                        ,LOG01, SQLCODE, SQLERRM);
            vDTrazasError(modulo, "Error en Fetch de Cursor de cFaProcTraza Error-Ora[%ld]: %s"
                                        ,LOG01, SQLCODE, SQLERRM);
            return (FALSE);
        }
        if(SQLCODE == SQLNOTFOUND)
        {
            bFinCursor_cFaProcTraza = TRUE;
        }
        else
        {
            /****************************************************************************/
            /*  Valida que el Estado del Proceso Precedente este Actualizado en la      */
            /*  tabla de Traza  FA_TRAZAPROC.                                           */
            /****************************************************************************/
            if(ihCodEstaPrec != ihTrazCodEstaProc)
            {
                vDTrazasLog  (modulo, "\n\t* Error: No ha Terminado Proceso Previo **\n",LOG01);
                vDTrazasError(modulo, "\n\t* Error: No ha Terminado Proceso Previo **\n",LOG01);
                return(FALSE);
            }
        }
    } while(!bFinCursor_cFaProcTraza);

    EXEC SQL CLOSE cFaProcTraza;


    return (TRUE);

}


/* HASTA AQUI PGG FUNCIONES NUEVAS */


/****************************************************************************/
/*  Funcion :   main                                                        */
/****************************************************************************/

int main(int argc, char *argv[])
{
    char modulo[]="main"		;
    char *szUserid_Aux			;
    extern	char *optarg        	;
    char  	opt[]=":u:c:l:" 	;
    int   	iOpt =0             	;
    int   	sts			;
    char  	szHelpString[1024] = " ";
    char  	szLineaComando2[25]= ""	;
    int		iUserFlag 	= 0;
    int		iLogFlag 	= 0;
    int		iCicloFlag 	= 0;

    memset(&stLineaComando,0    ,sizeof(LINEACOMANDO));


    sprintf(szHelpString,"\n Argumentos de entrada de proceso : "
                         "\n\t -u Usuario/Password"
                         "\n\t -c Ciclo de Facturacion"
                         "\n\t -l Nivel de Log\n");


    /* JQH <20050825>: Informacion fecha y hora de esta compilacion */
    fprintf(stdout,"\n** Proceso Proc_ExtracCICLO **\n   Version de compilacion: [%s]-[%s]\n",__DATE__,__TIME__);
    if (argc == 1)
    {
	fprintf(stderr,"%s",szHelpString);
	return 1;
    }

    while ( (iOpt = getopt(argc,argv,opt)) != EOF)
    {
        switch(iOpt)
        {
		case 'u':
			strcpy(stLineaComando.szUsuario, optarg);
			if((szUserid_Aux=(char *)strstr(stLineaComando.szUsuario,"/")) == (char *)NULL)
			{
				fprintf(stderr, "\nUsuario Oracle no es valido.\n");
				return(1);
			}
			else
			{
				strncpy(stLineaComando.szUser,stLineaComando.szUsuario, szUserid_Aux-stLineaComando.szUsuario);
				strcpy(stLineaComando.szPass, szUserid_Aux+1);
				printf("stLineaComando.szUser	[%s]\n",stLineaComando.szUser);
				printf("stLineaComando.szPass	[%s]\n",stLineaComando.szPass);
				fprintf (stdout," -u?/? ");
				iUserFlag = 1;
			}
			break;
		case 'c':
                	if (strlen (optarg))
                 	{
                    		stLineaComando.lCodCiclFact = atol(optarg);
                    		fprintf (stdout,"-c %ld ", stLineaComando.lCodCiclFact);
                    		iCicloFlag = 1;
                 	}
                 	break;


		case 'l':
			if (strlen (optarg) )
			{
				stStatus.LogNivel =(atoi (optarg) > 0)? atoi (optarg):iLOGNIVEL_DEF ;
				fprintf (stdout,"-l%d ", stStatus.LogNivel)     ;
				iLogFlag = 1;
			}
			break;
		case '?':
			fprintf(stderr,"\n<< ERROR (main): Se ha ingresado parametro desconocido: -%c >>\n%s\n",optopt,szHelpString);
			return -1;
			
		case ':':
			if ( optopt == 'u' ) 
			{
				fprintf(stderr,"\n<< ERROR (main): Falta especificar usuario/password >>\n%s",szHelpString);
				return -1;
			}
			if ( optopt == 'c' ) 
			{
				fprintf(stderr,"\n<< ERROR (main): Falta especificar Ciclo de Facturacion >>\n%s",szHelpString);
			    	return -1;
			}
			if ( optopt == 'l' ) 
			{
				fprintf(stderr,"\n<< ERROR (main): Falta especificar nivel de LOG >>\n%s",szHelpString);
			   	return -1;
			}
			
        }/*End Switch */


    } /* End While */
    fprintf (stdout,"\n");

    /* Validacion de Parametros */

	if ((iCicloFlag == 0) || (iLogFlag == 0) || (iUserFlag == 0))
	{
		fprintf(stderr,"Faltan parametros \n\n%s",szHelpString);
		return 1;
	}

	if (stLineaComando.lCodCiclFact < 0)
	{
		fprintf(stderr, "\n\tCiclo de Facturacion Invalido o no ingresado\n");
		fprintf(stderr,"%s",szHelpString);
		return 1;
	}


	if (stStatus.LogNivel <= 0) stStatus.LogNivel = iLOGNIVEL_DEF;

	stLineaComando.iNivLog = stStatus.LogNivel;

    	if(!bfnConnectORA(stLineaComando.szUser,stLineaComando.szPass))
    	{
        	fprintf(stderr, "\n\tUsuario/Passwd Invalido\n\t\t"
                		"<usuario> <passwd> '\n");
		fprintf(stderr,"%s",szHelpString);
        	return (2);
    	}
    	else
    	{
        	printf( "\n\t-------------------------------------------------------"
                	"\n\tConectado a ORACLE: Usuario %s Passwd xxxxxxxx "
                	"\n\t-------------------------------------------------------\n",
	                stLineaComando.szUser);
    	}
    	
    	
    	
    	
	if (stLineaComando.lCodCiclFact != 0)
	{
	    	if (!bfnChequeaProcesosPrevios(stLineaComando.lCodCiclFact))
	        {
	            vDTrazasLog(modulo,"Error en ejecucion de bfnChequeaProcesosPrevios ",LOG02);
	            return(FALSE);
	        }
	}

	
	if (!bfnVerificaGeneracionReporte())
	{
		vDTrazasLog(modulo,"Error en ejecucion de bfnVerificaGeneracionReporte ",LOG02);
		return(FALSE);	
	}
	


    	/**************************************************************************************/
    	/* Crear archivos y directorios de log y errores */

    	sts = ifnAbreArchivosLog();


    	if ( sts != 0 ) return sts;

    	/*********************************************************************************************/

    	vDTrazasLog  ( modulo ,"\n\n\t**********************************************"
                           "\n\n\t****           Log Proc_ExtracCICLO           **"
                           "\n\n\t**********************************************"
                           ,LOG03);

        /* JQH <20050825>: Informacion fecha y hora de esta compilacion */
        vDTrazasLog(modulo, "\n\t\t** Proceso Proc_ExtracCICLO **"
                            "\n\t\t   Version de compilacion: [%s]-[%s]"
                            ,LOG03
                            ,__DATE__
                            ,__TIME__);
    	vDTrazasLog  ( modulo ,"\n\t\t***  Parametro de Entrada Proc_ExtracCICLO  ***"
                           "\n\t\t=> Usuario               	[%s]"
                           "\n\t\t=> Ciclo de Facturacion	[%ld]"
                             "\n\t\t=> Niv.Log              	[%d]"
                           ,LOG03
                           ,stLineaComando.szUser
                           ,stLineaComando.lCodCiclFact
                           ,stLineaComando.iNivLog);

    	/************************************************************************************/
    	/*			Proceso Principal						*/
    	/************************************************************************************/

    	strcpy(modulo,"Proc_ExtracCICLO");

    	vDTrazasLog(modulo,"\n\t\t***  Inicio Proceso principal  ***", LOG03);
    	vDTrazasLog(modulo,"\n\t\t*** Inicio del Cargado de Estructuras***\n", LOG03);

	if (!bfnCargaEstructuras())
	{
		vDTrazasLog  (modulo,"\n\t*** ATENCION ***\n\t\t\t Error en la carga de las Estructuras***\n", LOG01);
		vDTrazasError(modulo,"\n\t*** ATENCION ***\n\t\t\t Error en la carga de las Estructuras***\n", LOG01);
	        return (FALSE);
	}
	vDTrazasLog(modulo,"\n\t\t*** Inicio Ejecucion Procesos de carga de tablas***\n", LOG03);

	if (pstDatosAcum.iCantDatosAcum != 0)
	{
		if (!bfnCargaTablas())
		{
			vDTrazasLog  (modulo,"\n\t*** ATENCION ***\n\t\t\t Error en la ejecucion de procesos***\n", LOG01);
			vDTrazasError(modulo,"\n\t*** ATENCION ***\n\t\t\t Error en la ejecucion de procesos***\n", LOG01);
		        return (FALSE);
		}
	}


    	if (!bfnOraCommit ())
    	{
        	vDTrazasError(modulo," en Commit", LOG01);
        	vDTrazasLog  (modulo," en Commit", LOG01);
        	return FALSE;
    	}

	if(!bfnDisconnectORA(0))
	{
		vDTrazasLog  ( modulo ,	"\n\t--------------------------------------------"
					"\n\t ERROR en Desconeccion de  ORACLE  = finaliza"
					"\n\t--------------------------------------------\n"
					,LOG03);
		vDTrazasError( modulo ,	"\n\t--------------------------------------------"
					"\n\t ERROR en Desconeccion de  ORACLE  = finaliza"
					"\n\t--------------------------------------------\n"
					,LOG03);
	}
    	else
    	{
		vDTrazasLog  ( modulo,	"\n\t--------------------------------------------"
					"\n\tDesconectado de  ORACLE"
					"\n\t--------------------------------------------\n"
					,LOG03);
		vDTrazasError( modulo, 	"\n\t--------------------------------------------"
					"\n\tDesconectado de  ORACLE"
					"\n\t--------------------------------------------\n"
					,LOG03);

	}

    return (0);
}/* ********************* Fin Main * *************************************** */

/* ******************************************************************************** */
/* ifnAbreArchivosLog : Crea para escritura o appendea archivos de Log y de Errores */
/* ******************************************************************************** */
int ifnAbreArchivosLog(void)
{
	char modulo[]="ifnAbreArchivosLog";

	char *pathDir;
	char szArchivo[32]="";
	char szPath[128]="";
	char szComando[128]="";
	char szRechazadosName[32];

	memset(szArchivo,'\0',sizeof(szArchivo));
	sprintf(szArchivo,"Proc_ExtracCICLO");

	pathDir=(char *)malloc(128);
	pathDir=szGetEnv("XPF_LOG");
	sprintf(szPath,"%s/Proc_Extractor/Ciclo/%s",pathDir,cfnGetTime(2));
	free(pathDir);

	fprintf(stdout, "\nCrea Directorio Log  : %s\n", szPath);
	sprintf(szComando,"mkdir -p %s", szPath);
	system (szComando);

	fprintf(stdout, "\nCrea Archivo Log/Err : %s\n\n", szArchivo);

	sprintf(stStatus.ErrName,"%s/%s_%s.err",szPath,szArchivo,cfnGetTime(5));
	if((stStatus.ErrFile = fopen(stStatus.ErrName,"w")) == (FILE*)NULL )
	{	fprintf(stderr, "\n<< No pudo crearse el archivo de errores %s >> \n", stStatus.ErrName);
		return -7;
	}

	vDTrazasError(modulo, "%s  << Abre Archivo de Errores >>", LOG04, cfnGetTime(1));

	sprintf(stStatus.LogName,"%s/%s_%s.log",szPath,szArchivo,cfnGetTime(5));
	if((stStatus.LogFile = fopen(stStatus.LogName,"w")) == (FILE*)NULL )
	{	fprintf(stderr, "\n<< No pudo crearse el archivo de log %s >>\n", stStatus.LogName);
		vDTrazasError(modulo, "\n<< No pudo crearse el archivo de log %s >>\n", LOG01, stStatus.LogName);
		return -8;
	}

	vDTrazasLog(modulo, "%s << Abre Archivo de Log >>", LOG04, cfnGetTime(1));


	vDTrazasLog(modulo, "%s << Inicio de Proc_ExtracCICLO >>" , LOG03, cfnGetTime(1));

	return 0;


} /* Fin ifnAbreArchivosLog  */


/******************************************************************************************/
/** Informacin de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisin                                            : */
/**  %PR% */
/** Autor de la Revisin                                : */
/**  %AUTHOR% */
/** Estado de la Revisin ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creacin de la Revisin                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/
