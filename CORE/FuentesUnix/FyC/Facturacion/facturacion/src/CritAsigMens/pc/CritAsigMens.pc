/*********************************************************************************
	Aplicacion : CritAsigMens = CRITerio de ASIGnacion de MENSajes.
	Fecha 	   : 06/01/2000 // 13/01/2000
	Basado en CritAsigDesp = CRITerio de ASIGnacion de secuencia de DESPacho.
	Ultima modificacion : Nuevo parametro que condiciona la accion del programa
	                      -p : priorizacion de los mensajes a imprimir
*********************************************************************************/

#include "CritAsigMens.h"
#define _CRITMENS_PC_

EXEC SQL INCLUDE sqlca;

/********************************************************************************************/
/* modulo principal                                                                         */
/********************************************************************************************/
int main(int argc,char *argv[])
{
	
/* Define variables locales */

	char modulo[]="main";
	
	char status[16]="";
	 int sts;


	memset(status,0,sizeof(status));
    memset(&stLineaComando,0,sizeof(LINEACOMANDOGENERICA));

/* Inicia enviando un mensaje informativo a la salida standard (pantalla) */

	fprintf( stdout, "\n\t***** CritAsigMens *****"
					 "\n\t%s"
					 "\n\t** pid : [ %8ld ] **"
					 "\n\t************************\n", 
	                 cfnGetTime(1),getpid() );


/* Validacion de parámetros y carga de estructura */

	sts = ifnValidaParametros(argc,argv,&stLineaComando);
	if ( sts != 0 ) return sts;


/* Define archivo de Log y Errores para la traza */

	sts = ifnAbreArchivosLog(stLineaComando.szCodCritAsig);
	if ( sts != 0 ) return sts;


/* Accesa a la Base de Datos y realiza el procesamiento */

	sts = ifnAccesoBaseDatos(stLineaComando);
	if (sts == 0)
		strcpy(status,"normal");
	else
		strcpy(status,"anormal");
	
	vDTrazasError(modulo,"%s [%ld] Termino %s de la Aplicacion\n\n", LOG03, cfnGetTime(1),getpid(),status);
	vDTrazasLog  (modulo,"%s [%ld] Termino %s de la Aplicacion\n\n", LOG03, cfnGetTime(1),getpid(),status);	

	return sts;
	
} /* main */


/********************************************************************************************************/

/****************************************************************************/
/* ifnValidaParametros : Realiza la validacion de los Parametros de Entrada */
/****************************************************************************/
int ifnValidaParametros( int argc, char *argv[], LINEACOMANDOGENERICA *pstLineaCom )
{          
	       char modulo[]="ifnValidaParametros";

/* Definicion de variables para controlar la lista de argumentos recibidos */
	extern char  *optarg;
	extern  int  optind, opterr, optopt;
	        int  iOpt=0;
	       char  opt[] = ":u:l:c:d:p";
	
/* Variables locales */  
  	       char  *psztmp = "";

/* Flags de los valores recibidos*/
	        int  Userflag=FALSE;
 	        int  Logflag=FALSE;
 	        int  Ciclflag=FALSE;
 	        int  Asigflag=FALSE;
 	        int  Prioflag=FALSE;

    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);
	opterr=0;


/* Esta validacion corresponde sólo si se tiene al menos un parámetro que no sea opcional (necesario) */

	if(argc == 1)
	{
		fprintf (stderr,"\n\t<< Error : Parametros insuficientes >>\n%s\n",szUsage);
		return -1;
	}

/* Analisis de los argumentos recibidos */

	while ( (iOpt = getopt(argc, argv, opt) ) != EOF)
	{
		switch(iOpt)
		{
			case 'u':  /* Validacion del Usuario / Password Oracle*/
 				if(Userflag==FALSE)
				{
	                strcpy(pstLineaCom->szUsuarioOra, optarg);                      
    	            Userflag=TRUE;
					if ( (psztmp=(char *)strstr(pstLineaCom->szUsuarioOra,"/"))==(char *)NULL)
					{
						fprintf (stderr,"\n\t<< Error : Usuario Oracle no valido. Requiere '/' >>\n%s\n",szUsage);
						return -5;
					}
					else
					{
						strncpy (pstLineaCom->szOraAccount,pstLineaCom->szUsuarioOra,psztmp-pstLineaCom->szUsuarioOra);
						strcpy  (pstLineaCom->szOraPasswd, psztmp+1)                 ;
					}
				}
				else
				{
					fprintf (stderr,"\n\t<< Error : opcion '-%c' duplicada >>\n%s\n",optopt,szUsage);
					return -2;
				}
				break;

			case 'l': /* Validacion del Nivel de Log definido */
				if(Logflag==FALSE)
				{
                    stStatus.LogNivel = (atoi(optarg) > 0)? atoi(optarg):iLOGNIVEL_DEF ;
				    pstLineaCom->iLogLevel=stStatus.LogNivel ;
                    Logflag=TRUE;
				}
				else
				{
					fprintf (stderr,"\n\t<< Error : opcion '-%c' duplicada >>\n%s\n",optopt,szUsage);
					return -2;
				}
				break;

			case 'c':
				if(Ciclflag==FALSE)
				{
	                pstLineaCom->lCodCiclFact = atol(optarg);                      
                    Ciclflag=TRUE;
				}
				else
				{
					fprintf (stderr,"\n\t<< Error : opcion '-%c' duplicada >>\n%s\n",optopt,szUsage);
					return -2;
				}
				break;

			case 'd':
				if(Asigflag==FALSE)
				{
	                strncpy(pstLineaCom->szCodCritAsig, optarg,3);
                    Asigflag=TRUE;
				}
				else
				{
					fprintf (stderr,"\n\t<< Error : opcion '-%c' duplicada >>\n%s\n",optopt,szUsage);
					return -2;
				}
				break;

			case 'p':
				if(Prioflag==FALSE)
				{
	                pstLineaCom->iPriorizar=1;/*TRUE*/                      
                    Prioflag=TRUE;
				}
				else
				{
					fprintf (stderr,"\n\t<< Error : opcion '-%c' duplicada >>\n%s\n",optopt,szUsage);
					return -2;
				}
				break;

			case '?':
				fprintf (stderr,"\n\t<< Error : opcion '-%c' es desconocida >>\n%s\n",optopt,szUsage);
				return -3;
				/*break;*/

			case ':':
				fprintf (stderr,"\n\t<< Error : Falta parametro para opcion '-%c' >>\n%s\n",optopt,szUsage);
				return -4;
				/*break;*/
		}
	} 

	/* Valida la ocurrencia del parametro -p */
	if (Prioflag==FALSE)
	{
		/* Revisa ocurrencia de parametros necesarios */
		if (( Asigflag == FALSE)&&( Ciclflag==FALSE))
		{
			fprintf (stderr,"\n\t<< Error : Falta definir una de las opciones necesarias '-p' o '-c y -d'  >>\n%s\n",szUsage);
			return -6;			
		}
	
		if(Ciclflag==FALSE)
		{	
			fprintf (stderr,"\n\t<< Error : Falta definir opcion '-c' Cod Ciclo Facturacion >>\n%s\n",szUsage);
			return -6;
		}

		if(Asigflag==FALSE)
		{	
			fprintf (stderr,"\n\t<< Error : Falta definir opcion '-d' Cod Criterio Asignacion Mensaje >>\n%s\n",szUsage);
			return -6;
		}
		else
		{  
			if(!bfnValidaCriterio(pstLineaCom->szCodCritAsig))
			{	
				fprintf (stderr,"\n\t<< Error : Criterio ' %s ' Inesperado >>\n%s\n",pstLineaCom->szCodCritAsig,szUsage);
				return -6;
			}
		}
	}
	else
	{
		if (( Asigflag==FALSE )&&( Ciclflag==FALSE ))
		{
             sprintf(pstLineaCom->szCodCritAsig,"PRI");  /* Priorizar Mensajes */
		}
		else
		{
			fprintf (stderr,"\n\t<< Error : La opcion '-p' debe ir sola  >>\n%s\n",szUsage);
			return -6;			
		}
	}	

	if(Logflag==FALSE) /* Si no se definio log, se asumira por defecto  */
	{
        stStatus.LogNivel = iLOGNIVEL_DEF ;
	    pstLineaCom->iLogLevel=stStatus.LogNivel ;
	}

	return 0;

} /* bfnValidaParametros */

/********************************************************************************************************/

/************************************************************************************/
/* bfnValidaCriterio  */
/************************************************************************************/
BOOL bfnValidaCriterio(char *szCriterio)
{
	char modulo[]="bfnValidaCriterio";

	if ( (strcmp(szCriterio,critTODOS)==0)     || (strcmp(szCriterio,critTIPOCLI)==0)  || 
	     (strcmp(szCriterio,critCICLOFACT)==0) || (strcmp(szCriterio,critPLAN)==0)     || 
	     (strcmp(szCriterio,critPRODUCTO)==0)  || (strcmp(szCriterio,critINICIO)==0)   ||
	     (strcmp(szCriterio,critPAGOAUTOM)==0)   ) 
	{     
	     return TRUE;
	}
	else
	{
		return FALSE;
	}    
}


/************************************************************************************/
/* ifnAbreArchivosLog : Crea para escritura o appendea archivos de Log y de Errores */
/************************************************************************************/
int ifnAbreArchivosLog(char *szCriterio)
{
	char modulo[]="ifnAbreArchivosLog";

	char szArchivo[32]="";
	char *pathDir;
	char szPath[128]="";
	char szComando[128]="";	

    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);
	memset(szArchivo,'\0',sizeof(szArchivo));
	sprintf(szArchivo,"CritMens_%s_%s",szCriterio,cfnGetTime(4));

	pathDir=(char *)malloc(128);
	pathDir=szGetEnv("XPF_LOG");
	sprintf(szPath,"%s/CritAsigMens/%s",pathDir,cfnGetTime(2)); 
	free(pathDir);

	fprintf(stdout, "\n\t Creando directorio de log y errores : \n\t %s\n", szPath);
	sprintf(szComando,"mkdir -p %s", szPath); 
	if (system (szComando)!=0) return -7;

	fprintf(stdout, "\n\t Creando archivos de log y errores   : \n\t %s\n\n", szArchivo);
	sprintf(stStatus.ErrName,"%s/%s.err",szPath,szArchivo); 
	if ((stStatus.ErrFile = fopen(stStatus.ErrName,"a")) == (FILE*)NULL )
	{	fprintf(stderr, "\n\t<< No pudo crearse el archivo de errores %s >> \n", stStatus.ErrName);
		return -8;    }
	vDTrazasError(modulo, "%s [%ld] << Abre Archivo de Errores >>", LOG03, cfnGetTime(1),getpid());

	sprintf(stStatus.LogName,"%s/%s.log",szPath,szArchivo); 
	if ((stStatus.LogFile = fopen(stStatus.LogName,"a")) == (FILE*)NULL ) /* "wb+" */
	{	fprintf(stderr, "\n\t<< No pudo crearse el archivo de log %s >>\n", stStatus.LogName);
		vDTrazasError(modulo, "\n<< No pudo crearse el archivo de log %s >>\n", LOG01, stStatus.LogName);
		return -9;    }
	vDTrazasLog(modulo, "%s [%ld] << Abre Archivo de Log >>", LOG03, cfnGetTime(1),getpid());


	if ( strcmp(szCriterio,"PRI")==0 )
		vDTrazasLog(modulo, "%s [%ld] *** Priorizando los Mensajes a Imprimir ***", LOG03, cfnGetTime(1),getpid());
	
	
	return 0;
	
}/* ifnAbreArchivosLog */

/********************************************************************************************************/

/************************************************************************************/
/* ifnAccesoBaseDatos : Acceso a la Base y Procesamiento de la Información          */
/************************************************************************************/
int ifnAccesoBaseDatos(LINEACOMANDOGENERICA *pstLineaCom)
{
	char modulo[]="ifnAccesoBaseDatos";
 
    
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);
		
	if(!bfnConnectORA(pstLineaCom->szOraAccount,pstLineaCom->szOraPasswd))
	{
        vDTrazasError(modulo, "No Hay Conexion a la Base de Datos", LOG01);
        return -10;
    }

    
    if (!bGetDatosGener (&stDatosGener, szSysDate))		
	{
        vDTrazasError(modulo, "No pudo recuperar FA_DATOSGENER", LOG01);
        return -11;
    }


	if (pstLineaCom->iPriorizar == 1)
	{
        if (!bfnPriorizaMensajes())
        {
	        vDTrazasError(modulo, "No pudo priorizar los mensajes",LOG01);
        	return -12;
        }		
	}
	else
	{
	    if (!bfnGetCriterios(pstLineaCom->szCodCritAsig,pstLineaCom->lCodCiclFact))		
		{
	        vDTrazasError(modulo, "No pudo recuperar detalles del Criterio %s", LOG01,pstLineaCom->szCodCritAsig);
	        return -14;
	    }
	}    	
	
	if (!fnOraCommitRelease())
	{	
		vDTrazasError(modulo,"ERROR EN COMMIT.  Intentará hacer Rollback\n\t=> Detalle : %s\n", 
		                     LOG01, sqlca.sqlerrm.sqlerrmc);
		if (!fnOraRollBackRelease())
		{
	    	vDTrazasError(modulo,"ERROR EN ROLLBACK\n\t=>Detalle : %s\n", 
	    	                     LOG01, sqlca.sqlerrm.sqlerrmc);
		}
		
		return -15;	
	}

	return 0;
	
}

/********************************************************************************************************/

/***************************************************************************************/
/* bfnDeleteMensCiclo()  */
/***************************************************************************************/
BOOL bfnDeleteMensCiclo(char *szCrit, int iCodForm, int iCodBloq, long lCorrMsje, char *szCodOri) 
{
	char modulo[]="bfnDeleteMensCiclo";
	EXEC SQL BEGIN DECLARE SECTION;
		 int ihCodForm = 0    ;
		 int ihCodBloq = 0    ;
		long lhCorrMsje = 0   ;
		char szhCodOri[3] ="" ;
	EXEC SQL END DECLARE SECTION;
	
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);
	
	ihCodForm  = iCodForm;
	ihCodBloq  = iCodBloq;
	lhCorrMsje = lCorrMsje;
	strcpy(szhCodOri,szCodOri);
	
    vDTrazasLog (modulo, "\tCriterio       %s" , LOG05, szCrit  );
    vDTrazasLog (modulo, "\tCod_formulario %d" , LOG05, ihCodForm  );
    vDTrazasLog (modulo, "\tCod_Bloque     %d" , LOG05, ihCodBloq  );
    vDTrazasLog (modulo, "\tCorr_Mensaje   %ld", LOG05, lhCorrMsje );
    vDTrazasLog (modulo, "\tCod_Origen     %s" , LOG05, szhCodOri  );
	
	
	vDTrazasLog(modulo, "%s << Inicio Borrado >>", LOG05, cfnGetTime(1));
	
	if (strcmp(szCrit,critINICIO)==0) /* Si es inicio borra toda la tabla */
	{
		EXEC SQL DELETE FA_MENSCICLO ;	
	}
	else /* Si no borra solo lo que corresponde al criterio */
	{
		EXEC SQL DELETE FA_MENSCICLO 
		          WHERE COD_CLIENTE > 0
		          	AND COD_FORMULARIO  = :ihCodForm
		            AND COD_BLOQUE      = :ihCodBloq
		            AND CORR_MENSAJE    = :lhCorrMsje
		            AND COD_ORIGEN      = :szhCodOri;
	}


	if (SQLCODE != SQLNOTFOUND && SQLCODE != SQLOK)
	{
        vDTrazasError(modulo , "<< Al limpiar la tabla FA_MENSCICLO >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		if (!fnOraRollBack())
		{
 				vDTrazasError(modulo,"ERROR EN ROLLBACK\n\t=>Detalle : %s\n", 
   	                     LOG01, sqlca.sqlerrm.sqlerrmc);
		}
		return FALSE;
	}
	else
	{
		vDTrazasLog(modulo, "%s << TerminoBorrado >>", LOG05, cfnGetTime(1));
	}
    

	if(!fnOraCommit())
	{
		vDTrazasError(modulo,"ERROR EN COMMIT.  Intentará hacer Rollback\n\t=> Detalle : %s\n", 
	            	         LOG01, sqlca.sqlerrm.sqlerrmc);
		if (!fnOraRollBack())
		{
 				vDTrazasError(modulo,"ERROR EN ROLLBACK\n\t=>Detalle : %s\n", 
   	                     LOG01, sqlca.sqlerrm.sqlerrmc);
		}
		
		return FALSE;
			
	}

	return TRUE;
}


/***************************************************************************************/
/* bfnPreparaCursorCriterios  */
/***************************************************************************************/

BOOL bfnPreparaCursorCriterios(char *szCriterio)
{
	char modulo[]="bfnPreparaCursorCriterios";

    EXEC SQL BEGIN DECLARE SECTION;
    	char  szhCodCritAsig  [4] ;
    EXEC SQL END DECLARE SECTION;
	
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);

	strcpy(szhCodCritAsig,szCriterio);
	
    EXEC SQL DECLARE CursorCRITERIOS CURSOR FOR 	
    SELECT CRIT.ROWID, 
		   CRIT.COD_FORMULARIO, 
		   CRIT.COD_BLOQUE, 
		   CRIT.CORR_MENSAJE, 
		   CRIT.NUM_LINEAS, 
		   CRIT.COD_ORIGEN, 
		   ORI.COD_PRIORIDAD, 
		   NVL(CRIT.VAL_PARAM,'-1'), 
		   NVL(CRIT.VAL_OPERADOR,'<'), 
		   TO_CHAR(CRIT.FEC_DESDE,'YYYYMMDD'), 
		   TO_CHAR(CRIT.FEC_HASTA,'YYYYMMDD'), 
		   CRIT.IND_CICLO 
	  FROM FA_CRITASIGMEN CRIT, FA_ORIMENSAJE ORI 
	 WHERE CRIT.COD_CRITMENS   =  :szhCodCritAsig
	   AND CRIT.COD_ORIGEN     = ORI.COD_ORIGEN ;

   if (SQLCODE)
	{    
        vDTrazasError(modulo , "<< Al declarar el Cursor de los Criterios >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
	}
		
	EXEC SQL OPEN CursorCRITERIOS;	
	if (SQLCODE)
	{	
        vDTrazasError(modulo , "<< Al Abrir el Cursor de los Criterios >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
	}

	return TRUE;
}

/********************************************************************************************************/

/***************************************************************************************/
/* bfnGetCriterios : Obtiene informacion adicional segun el Cod Criterio dado (cursor) */
/***************************************************************************************/
BOOL bfnGetCriterios(char *szCritAsig, long lCodCiclFact)
{
	char modulo[]="bfnGetCriterios";
	char szMotivo[128]="";
	long lCont=0;
	 int iAux = 0;
	 int StsCicl=0;
	BOOL bTerminoOK_CRI=TRUE;
	
    EXEC SQL BEGIN DECLARE SECTION;
    	 int ihCodFormulario   ;
		 int ihCodBloque	   ;
		long lhCorrMensaje	   ;
		 int ihNumLineas	   ;
		char szhCodOrigen  [3] ;
		 int ihCodPrioridad	   ;
		char szhValParam  [21] ;
		char szhValOper    [3] ;
		char szhFecDesde   [9] ;
		char szhFecHasta   [9] ;
		char szhIndCiclo   [2] ;
		char szhFecProceso [9] ;
		char szhRowid     [20] ; EXEC SQL VAR szhRowid IS STRING(20) ;
		long lhCodCiclFact     ; /**/
    EXEC SQL END DECLARE SECTION;
	
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);
    vDTrazasLog (modulo, "<< '%s' v/s '%s' >>", LOG05, szCritAsig,critINICIO);
	
	if (strcmp(szCritAsig,critINICIO)==0) return bfnCargaMensajesDefault(lCodCiclFact);
		
	lhCodCiclFact=lCodCiclFact;

	if (!bfnPreparaCursorCriterios(szCritAsig))
		return FALSE;
	
	bTerminoOK_CRI=TRUE;
	lCont=0;
	while (1)
	{
		memset(szhValParam,0,sizeof(szhValParam));
	    memset(&stDatos,0,sizeof(REGISTRODATOS));	

		EXEC SQL FETCH CursorCRITERIOS	
			      INTO :szhRowid,
			      	   :ihCodFormulario	,
					   :ihCodBloque		,
					   :lhCorrMensaje	,
					   :ihNumLineas		,
					   :szhCodOrigen	,
					   :ihCodPrioridad	,
					   :szhValParam		,
					   :szhValOper		,
					   :szhFecDesde		,
					   :szhFecHasta		,
					   :szhIndCiclo		;
	
		if (SQLCODE == SQLNOTFOUND) 
		{
		    vDTrazasLog (modulo, "\t\t** Fin del Cursor **\n", LOG03); 
			bTerminoOK_CRI=TRUE;
			break;
		}
		else if (SQLCODE)
		{	
			bTerminoOK_CRI=FALSE;
			sprintf(szMotivo,"%s",sqlca.sqlerrm.sqlerrmc);
			break;
		}
		else /* SQLOK */
		{												
			lCont++;

			iAux = strlen(szhValParam) - 1; /* rtrim del 'valor del parametro' */
			while ((szhValParam[iAux]==' ') && (iAux>0))
			{  szhValParam[iAux]='\0';
			   iAux--; }

			stDatos.lCodCiclFact		= lhCodCiclFact		;
			strcpy(stDatos.szCriterio   , szCritAsig )		;
			stDatos.iCodFormulario		= ihCodFormulario	; 
			stDatos.iCodBloque			= ihCodBloque		; 
			stDatos.lCorrMensaje		= lhCorrMensaje		;
			stDatos.iNumLineas			= ihNumLineas		;
			strcpy(stDatos.szCodOrigen	, szhCodOrigen )	;
			stDatos.iCodPrioridad		= ihCodPrioridad	;
			strcpy(stDatos.szValParam	, szhValParam   )	;
			strcpy(stDatos.szValOper	, szhValOper    )	;
			strcpy(stDatos.szFecDesde	, szhFecDesde   )	;
			strcpy(stDatos.szFecHasta	, szhFecHasta   )	;
			strcpy(stDatos.szIndCiclo	, szhIndCiclo   )	;

		    vDTrazasLog (modulo, "\t\t Ocurrencia Criterio    [%ld]", LOG05,lCont                  );
		    vDTrazasLog (modulo, "\t\t stDatos.lCodCiclFact   [%ld]", LOG05,stDatos.lCodCiclFact   );
		    vDTrazasLog (modulo, "\t\t stDatos.szCriterio     [%s]" , LOG05,stDatos.szCriterio     );
		    vDTrazasLog (modulo, "\t\t stDatos.iCodFormulario [%d]" , LOG05,stDatos.iCodFormulario );
		    vDTrazasLog (modulo, "\t\t stDatos.iCodBloque     [%d]" , LOG05,stDatos.iCodBloque     );
		    vDTrazasLog (modulo, "\t\t stDatos.lCorrMensaje   [%ld]", LOG05,stDatos.lCorrMensaje   );
		    vDTrazasLog (modulo, "\t\t stDatos.iNumLineas     [%d]" , LOG05,stDatos.iNumLineas     );
		    vDTrazasLog (modulo, "\t\t stDatos.szCodOrigen    [%s]" , LOG05,stDatos.szCodOrigen    );
		    vDTrazasLog (modulo, "\t\t stDatos.iCodPrioridad  [%d]" , LOG05,stDatos.iCodPrioridad  );
			vDTrazasLog (modulo, "\t\t stDatos.szValParam     [%s]" , LOG05,stDatos.szValParam     );
			vDTrazasLog (modulo, "\t\t stDatos.szValOper      [%s]" , LOG05,stDatos.szValOper      );
			vDTrazasLog (modulo, "\t\t stDatos.szFecDesde     [%s]" , LOG05,stDatos.szFecDesde     );
			vDTrazasLog (modulo, "\t\t stDatos.szFecHasta     [%s]" , LOG05,stDatos.szFecHasta     );
			vDTrazasLog (modulo, "\t\t stDatos.szIndCiclo     [%s]" , LOG05,stDatos.szIndCiclo     );
			
			StsCicl=0;
			StsCicl=ifnValidaCiclo(&stDatos);
			if ( StsCicl < 0 )
    		{
        		sprintf(szMotivo,"Fallo la Validacion del Ciclo %ld, por error Oracle\n",lCodCiclFact);
        		bTerminoOK_CRI=FALSE;
        		break;    	
    		}
    		else if (StsCicl > 0)
    		{
			    vDTrazasLog (modulo, "\t\t** Fallo Validacion de Ciclo. NO SE PROCESA y pasa al sgte **\n", LOG03); 
    		}
    		else /* StsCicl == 0 */
    		{
		 		if (!bfnProcesaCriterio(stDatos)) 
				{
	       			sprintf(szMotivo,"No pudo procesar el Criterio %s\n",szCritAsig);
	       			bTerminoOK_CRI=FALSE;
	       			break;    	
				}
				else /* Se proceso correctamente el criterio */
				{    /* Se actualiza la tabla de los criterios */
					vDTrazasLog (modulo, "<< Actualizando FA_CRITASIGMEN >>\n", LOG03); 
					EXEC SQL UPDATE FA_CRITASIGMEN 
								SET COD_CICLFACT = :lhCodCiclFact,
								    FEC_PROCESO = SYSDATE
							  WHERE ROWID = :szhRowid;
					
					if (SQLCODE)
					{	
						bTerminoOK_CRI=FALSE;
						sprintf(szMotivo,"%s",sqlca.sqlerrm.sqlerrmc);
						break;
					}
					else if(!fnOraCommit())
					{
						vDTrazasError(modulo,"ERROR EN COMMIT.  Intentará hacer Rollback\n\t=> Detalle : %s\n", 
			            	         LOG01, sqlca.sqlerrm.sqlerrmc);
							if (!fnOraRollBack())
							{
			    				vDTrazasError(modulo,"ERROR EN ROLLBACK\n\t=>Detalle : %s\n", 
			    	                     LOG01, sqlca.sqlerrm.sqlerrmc);
							}
						bTerminoOK_CRI=FALSE;
						strcpy(szMotivo,sqlca.sqlerrm.sqlerrmc);
						break;
					}					 
				}
			}
		}
	} /* endwhile */			

	EXEC SQL CLOSE CursorCRITERIOS;
	
	if (SQLCODE)
	{	
		vDTrazasError(modulo,"<< Al Cerrar Cursor de los Criterios >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		sprintf(szMotivo,"%s",sqlca.sqlerrm.sqlerrmc);
		bTerminoOK_CRI=FALSE;
	}
	
	
	if (!bTerminoOK_CRI)
	{
		vDTrazasLog    (modulo,"<< Cursor de los Criterios No termino OK >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,szMotivo);
		vDTrazasError  (modulo,"<< Cursor de los Criterios No termino OK >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,szMotivo);
		return FALSE;
	}
    
	return TRUE;

}


/********************************************************************************************************/
/*********************************************************************************************/
/*	ifnValidaCiclo() */
/*********************************************************************************************/
BOOL ifnValidaCiclo(REGISTRODATOS *pstDatos)
{
	char modulo[]="ifnValidaCiclo";
	
	EXEC SQL BEGIN DECLARE SECTION;
		long lhCodCiclFact = 0;
		 int ihCodCiclo = 0;
		 int ihIndFacturacion=0;
		char szhPreproc [2]="";	
		char szhFecHastaCFijos[9]="";
		char szhFecEmision[9]="";
		char szhFecDesde[9]="";
		char szhFecHasta[9]="";
		EXEC SQL END DECLARE SECTION;

    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);

	lhCodCiclFact = pstDatos->lCodCiclFact; 	/* ciclo de facturacion */
	
	EXEC SQL SELECT COD_CICLO
	                ,IND_FACTURACION
	                ,TO_CHAR(FEC_HASTACFIJOS,'YYYYMMDD')
	                ,TO_CHAR(FEC_EMISION,'YYYYMMDD')
	           INTO  :ihCodCiclo
	                ,:ihIndFacturacion
	                ,:szhFecHastaCFijos
	                ,:szhFecEmision
			   FROM FA_CICLFACT
			  WHERE COD_CICLFACT = :lhCodCiclFact;

	if (SQLCODE)
	{    
        vDTrazasLog  (modulo , "<< En el SELECT de FA_CICLFACT >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
        vDTrazasError(modulo , "<< En el SELECT de FA_CICLFACT >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return -1; /* Error Oracle */
	}
	else
	{
		pstDatos->iCodCiclo = ihCodCiclo ;
		strcpy (pstDatos->szFecHastaCFijos ,szhFecHastaCFijos); 
		strcpy (pstDatos->szFecEmision ,szhFecEmision); 
		vDTrazasLog ( modulo, "\t\t stDatos.iCodCiclo        [%d]" , LOG05, pstDatos->iCodCiclo        );
		vDTrazasLog ( modulo, "\t\t stDatos.szFecHastaCFijos [%s]" , LOG05, pstDatos->szFecHastaCFijos );
		vDTrazasLog ( modulo, "\t\t stDatos.szFecEmision     [%s]" , LOG05, pstDatos->szFecEmision     );
	}

	if (strcmp(pstDatos->szCriterio,critINICIO)!=0) /* Si no es carga inicial, Valida la fecha */
	{	
		strcpy (szhFecDesde,pstDatos->szFecDesde); 
		strcpy (szhFecHasta,pstDatos->szFecHasta); 
	
	 	/* Validacion de la Fecha de Emision contra las fechas desde y hasta */    							
		if  (strcmp(szhFecDesde,szhFecEmision) > 0) 
		{
	    	vDTrazasLog   (modulo, " Fecha Emision [%s] anterior a Fecha Desde [%s]", 
	    							LOG01,szhFecEmision,szhFecDesde );
	    	vDTrazasError (modulo, " Fecha Emision [%s] anterior a Fecha Desde [%s]", 
	    							LOG01,szhFecEmision,szhFecDesde );
	    	return 1; /* Error Validacion : NO PROCESAR */
		}
		else if (strcmp(szhFecEmision,szhFecHasta) > 0)
		{
	    	vDTrazasLog   (modulo, " Fecha Emision [%s] posterior a Fecha Hasta [%s]", 
	    							LOG01,szhFecEmision,szhFecHasta );
	    	vDTrazasError (modulo, " Fecha Emision [%s] posterior a Fecha Hasta [%s]", 
	    							LOG01,szhFecEmision,szhFecHasta );
	    	return 1; /* Error Validacion : NO PROCESAR */
		}
	}
			
	/* Validacion del Ciclo */
	if (ihIndFacturacion > 0) /* periodo de tasacion cerrado, en facturacion o facturado */
	{
		    vDTrazasLog (modulo, "\n\t == PREFACT", LOG05 );
		    if (!bfnSelectTrazaProc(pstDatos->lCodCiclFact,iPROC_FAMASCARA,&stTrazaProc)) /*2000*/
		    {
		    	vDTrazasLog   (modulo, "\t Al seleccionar proceso [%ld][%d]", LOG01,pstDatos->lCodCiclFact, iPROC_FAMASCARA );
		    	vDTrazasError (modulo, "\t Al seleccionar proceso [%ld][%d]", LOG01,pstDatos->lCodCiclFact, iPROC_FAMASCARA );
		    	return -1; /* Error Oracle */
		    }

	    	vDTrazasLog   (modulo, "\t\tlCodCiclFact  %ld", LOG05,stTrazaProc.lCodCiclFact);
	    	vDTrazasLog   (modulo, "\t\tiCodProceso   %d" , LOG05,stTrazaProc.iCodProceso);
	    	vDTrazasLog   (modulo, "\t\tiCodEstaProc  %d" , LOG05,stTrazaProc.iCodEstaProc);
	    	vDTrazasLog   (modulo, "\t\tszFecInicio   %s" , LOG05,stTrazaProc.szFecInicio);
	    	vDTrazasLog   (modulo, "\t\tszFecTermino  %s" , LOG05,stTrazaProc.szFecTermino);
	    	vDTrazasLog   (modulo, "\t\tszGlsProceso  %s" , LOG05,stTrazaProc.szGlsProceso);
	    	vDTrazasLog   (modulo, "\t\tlCodCliente   %ld", LOG05,stTrazaProc.lCodCliente);
	    	vDTrazasLog   (modulo, "\t\tlNumAbonado   %ld", LOG05,stTrazaProc.lNumAbonado);
	    	vDTrazasLog   (modulo, "\t\tlNumRegistros %ld", LOG05,stTrazaProc.lNumRegistros);
		    
		    if (stTrazaProc.iCodEstaProc != iESTAPROC_TERMINADO_OK)
		    {    
		    	vDTrazasLog   (modulo, "\t El proceso [%ld][%d] No ha terminado OK", LOG01,pstDatos->lCodCiclFact, iPROC_FAMASCARA );
		    	vDTrazasError (modulo, "\t El proceso [%ld][%d] No ha terminado OK", LOG01,pstDatos->lCodCiclFact, iPROC_FAMASCARA );
		    	return 1; /* Error Validacion : NO PROCESAR */
		    }
       	
		    return 0; /* Ciclo Valido : PROCESAR */
	}
	else
	{
        vDTrazasLog  (modulo , "<< En la validacion de pre o pos facturacion >>"
                      "\n\t\t=> Detalle : IND_FACTUACION = 0  en FA_CICLFACT para COD_CICLFACT  %ld \n",LOG01,lhCodCiclFact);
        vDTrazasError(modulo , "<< En la validacion de pre o pos facturacion >>"
                      "\n\t\t=> Detalle : IND_FACTUACION = 0  en FA_CICLFACT para COD_CICLFACT  %ld \n",LOG01,lhCodCiclFact);
		return 1; /* Error Validacion : NO PROCESAR */
	}	
	/* RAO07052002: Se elimina ya que no se ejecuta nunca */
	/* return 0; Ciclo Valido : PROCESAR */

}

/*******************************************************************************************************/

/*******************************************************************************************************/

/*********************************************************************************************/
/*	bfnInitSqlDinamico() */
/*********************************************************************************************/
BOOL bfnInitSqlDinamico (char *szCadena, REGISTRODATOS stDat)
{
    char modulo[]="bfnInitSqlDinamico";
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);

	if (strcmp(stDat.szCriterio,critTODOS)==0)  
	{
		sprintf(szCadena,  " SELECT DISTINCT COD_CLIENTE"
							 " FROM FA_CICLOCLI"
							 " WHERE COD_CICLO = %d"
							 " AND IND_MASCARA = 1",
							 stDat.iCodCiclo );
	}
	else if (strcmp(stDat.szCriterio,critTIPOCLI)==0)	
	{
		sprintf(szCadena,   " SELECT DISTINCT COD_CLIENTE FROM" 
		                         " ( "
							     " SELECT CEL.COD_CLIENTE"
							       " FROM GA_INTARCEL CEL, FA_CICLOCLI FCC"
							      " WHERE FCC.COD_CICLO = %d"
							        " AND FCC.IND_MASCARA = 1"
							        " AND CEL.COD_CLIENTE = FCC.COD_CLIENTE"
							        " AND CEL.NUM_ABONADO = FCC.NUM_ABONADO"
							        " AND ( TO_DATE(%s,'YYYYMMDD') BETWEEN CEL.FEC_DESDE AND CEL.FEC_HASTA)"
							        " AND CEL.TIP_PLANTARIF %s '%s'"
							        " AND CEL.COD_CICLO = %d" 
							      " UNION ALL" 
							     " SELECT BEEP.COD_CLIENTE"
							       " FROM GA_INTARBEEP BEEP, FA_CICLOCLI FCC"
							      " WHERE FCC.COD_CICLO = %d"
							        " AND FCC.IND_MASCARA = 1"
							        " AND BEEP.COD_CLIENTE = FCC.COD_CLIENTE"
							        " AND BEEP.NUM_ABONADO = FCC.NUM_ABONADO"
							        " AND ( TO_DATE(%s,'YYYYMMDD') BETWEEN BEEP.FEC_DESDE AND BEEP.FEC_HASTA)"
							        " AND BEEP.TIP_PLANTARIF %s '%s' "
							        " AND BEEP.COD_CICLO = %d"
							        " ) ",
							stDat.iCodCiclo,
							stDat.szFecHastaCFijos,
							stDat.szValOper, 
							stDat.szValParam,
							stDat.iCodCiclo,
							stDat.iCodCiclo,
							stDat.szFecHastaCFijos,
							stDat.szValOper, 
							stDat.szValParam,
							stDat.iCodCiclo   );
	}
	else if (strcmp(stDat.szCriterio,critPLAN)==0)
	{
		sprintf(szCadena,   " SELECT DISTINCT COD_CLIENTE FROM "
		                         " ( "
							     " SELECT CEL.COD_CLIENTE"
							       " FROM GA_INTARCEL CEL, FA_CICLOCLI FCC"
							      " WHERE FCC.COD_CICLO = %d"
							        " AND FCC.IND_MASCARA = 1"
							        " AND CEL.COD_CLIENTE = FCC.COD_CLIENTE"
							        " AND CEL.NUM_ABONADO = FCC.NUM_ABONADO"
							        " AND ( TO_DATE(%s,'YYYYMMDD') BETWEEN CEL.FEC_DESDE AND CEL.FEC_HASTA)"
							        " AND CEL.COD_PLANTARIF %s '%s' " 
							        " AND CEL.COD_CICLO = %d" 
							      " UNION ALL" 
							     " SELECT BEEP.COD_CLIENTE"
							       " FROM GA_INTARBEEP BEEP, FA_CICLOCLI FCC"
							      " WHERE FCC.COD_CICLO = %d"
							        " AND FCC.IND_MASCARA = 1"
							        " AND BEEP.COD_CLIENTE = FCC.COD_CLIENTE"
							        " AND BEEP.NUM_ABONADO = FCC.NUM_ABONADO"
							        " AND ( TO_DATE(%s,'YYYYMMDD') BETWEEN BEEP.FEC_DESDE AND BEEP.FEC_HASTA)"
							        " AND BEEP.COD_PLANTARIF %s '%s' "
							        " AND BEEP.COD_CICLO = %d"
							        " ) ",
							stDat.iCodCiclo,
							stDat.szFecHastaCFijos,
							stDat.szValOper, 
							stDat.szValParam,
							stDat.iCodCiclo,
							stDat.iCodCiclo,
							stDat.szFecHastaCFijos,
							stDat.szValOper, 
							stDat.szValParam,
							stDat.iCodCiclo   );
	}
	else if (strcmp(stDat.szCriterio,critPRODUCTO)==0)
	{
		sprintf(szCadena,   "SELECT DISTINCT COD_CLIENTE "
							 " FROM FA_CICLOCLI"
							" WHERE COD_CICLO = %d"
							  " AND IND_MASCARA = 1"
							  " AND COD_PRODUCTO %s %s ", 
							stDat.iCodCiclo,
							stDat.szValOper, 
							stDat.szValParam);
	}
	else if (strcmp(stDat.szCriterio,critCICLOFACT)==0) 
	{
		sprintf(szCadena,  " SELECT DISTINCT COD_CLIENTE "
							 " FROM FA_CICLOCLI"
							" WHERE COD_CICLO = %d"
							 " AND IND_MASCARA = 1", 
							stDat.iCodCiclo   );
	}
	else if (strcmp(stDat.szCriterio,critPAGOAUTOM)==0)  /* Revisar */
	{
		sprintf(szCadena,    " SELECT DISTINCT PAC.COD_CLIENTE"
		 					   " FROM CO_UNIPAC PAC, FA_CICLOCLI FCC"
		 					  " WHERE FCC.COD_CICLO = %d"
		 					    " AND FCC.IND_MASCARA = 1"
		 					    " AND PAC.COD_CLIENTE = FCC.COD_CLIENTE",
							stDat.iCodCiclo   );
	}
	else 
	{
	    vDTrazasLog   (modulo, "<< Criterio Inesperado  ' %s '>>", LOG01, stDat.szCriterio);
	    vDTrazasError (modulo, "<< Criterio Inesperado  ' %s '>>", LOG01, stDat.szCriterio);
	    return FALSE;
	}

    return TRUE;
}


/*******************************************************************************************************/

/*********************************************************************************************/
/*	bfnPreparaCursorClientes() */
/*********************************************************************************************/
BOOL bfnPreparaCursorClientes(char *szCadena)
{
    char modulo[]="bfnPreparaPrimerCursor";
    
    vDTrazasLog ( modulo, "<< Entrando en %s >>", LOG04, modulo);
    
    
    EXEC SQL PREPARE SQL_DINAMICO FROM :szCadena;
    if (SQLCODE)
    {
        vDTrazasLog  (modulo , "<< En PREPARE de la Consulta Dinamica >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
        vDTrazasError(modulo , "<< En PREPARE de la Consulta Dinamica >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
    }

    EXEC SQL DECLARE CursorCLIENTES CURSOR FOR SQL_DINAMICO;
    if (SQLCODE)
    {
        vDTrazasLog  (modulo , "<< En DECLARE del Cursor Clientes >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
        vDTrazasError(modulo , "<< En DECLARE del Cursor Clientes >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
    }

    EXEC SQL OPEN CursorCLIENTES;
    if (SQLCODE)
    {
        vDTrazasLog  (modulo , "<< En OPEN del Cursor Clientes >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
        vDTrazasError(modulo , "<< En OPEN del Cursor Clientes >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
    }
    
    return TRUE;
}

/*******************************************************************************************************/
/**************************************************************************************/
/*  bfnInsertaClientes() */
/**************************************************************************************/

BOOL bfnInsertaClientes(long lCodCliente, REGISTRODATOS *pstDat)
{
	char modulo[]="bfnInsertaClientes";
    EXEC SQL BEGIN DECLARE SECTION;
    	long lhCodCliente       ;
    	 int ihCodFormulario  	;
		 int ihCodBloque		;
		long lhCorrMensaje		;
		 int ihNumLineas		;
		char szhCodOrigen    [3];
		 int ihCodPrioridad		;
    EXEC SQL END DECLARE SECTION;
	
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);

    lhCodCliente		= lCodCliente			 ;
    ihCodFormulario		= pstDat->iCodFormulario ;
	ihCodBloque			= pstDat->iCodBloque	 ;
	lhCorrMensaje		= pstDat->lCorrMensaje	 ;
	ihNumLineas			= pstDat->iNumLineas	 ;
	strcpy( szhCodOrigen, pstDat->szCodOrigen )  ;
	ihCodPrioridad		= pstDat->iCodPrioridad	 ;

	vDTrazasLog  (modulo,"\tInsertando...",LOG05);
	vDTrazasLog  (modulo,"\tCOD_CLIENTE    [%ld]",LOG05,lhCodCliente	);
	vDTrazasLog  (modulo,"\tCOD_FORMULARIO [%d]", LOG05,ihCodFormulario	);
	vDTrazasLog  (modulo,"\tCOD_BLOQUE     [%d]", LOG05,ihCodBloque		);
	vDTrazasLog  (modulo,"\tCORR_MENSAJE   [%ld]",LOG05,lhCorrMensaje	);
	vDTrazasLog  (modulo,"\tNUM_LINEAS     [%d]", LOG05,ihNumLineas		);
	vDTrazasLog  (modulo,"\tCOD_ORIGEN     [%s]", LOG05,szhCodOrigen 	);
	vDTrazasLog  (modulo,"\tCOD_PRIORIDAD  [%d]", LOG05,ihCodPrioridad	);
	vDTrazasLog  (modulo,"\tIND_FACTURADO  [I] ", LOG05				    );
	
	EXEC SQL INSERT INTO FA_MENSCICLO
						(
							COD_CLIENTE		,
							COD_FORMULARIO	,
							COD_BLOQUE		,
							CORR_MENSAJE	,
							NUM_LINEAS		,
							COD_ORIGEN		,
							COD_PRIORIDAD	,
							IND_FACTURADO
						)
					VALUES
						(
							:lhCodCliente		,
							:ihCodFormulario	,
							:ihCodBloque		,
							:lhCorrMensaje		,
							:ihNumLineas		,
							:szhCodOrigen 		,
							:ihCodPrioridad		,
							'N'
						);
	if (SQLCODE)
	{
		vDTrazasLog  (modulo,"<< Al Insertar Cliente %ld>>",LOG01,lCodCliente);
		vDTrazasError(modulo,"<< Al Insertar Cliente %ld>>"
	                     "\n\t\t=> Detalle : %s \n",LOG01,lCodCliente,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
	}                 
	
	return TRUE;	 

}                    
                     
                     
/*********************************************************************************************/
/*	bfnProcesaCriterio() */
/*********************************************************************************************/
BOOL bfnProcesaCriterio(REGISTRODATOS stDat) 	
{
	char modulo[]="bfnProcesaCriterio";
	char szCadenaSQL[1024]=""; 
	char szMotivo[128]="";
	long lContCli;
	BOOL bTerminoOK=TRUE;
	 
    EXEC SQL BEGIN DECLARE SECTION;
    	long lhCodCliente       ;
    EXEC SQL END DECLARE SECTION;

    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);
	
	if(!bfnDeleteMensCiclo(stDat.szCriterio,stDat.iCodFormulario,stDat.iCodBloque,stDat.lCorrMensaje,stDat.szCodOrigen)) /* Nota : hay un commit incluido en la funcion de borrado */
	{
        vDTrazasError(modulo, "No pudo eliminar datos de la FA_MENSCICLO ", LOG01);
        return FALSE;
	}

 	if (!bfnInitSqlDinamico (szCadenaSQL, stDat)) 
 	{
 		return FALSE;
	}
	
    vDTrazasLog ( modulo , "*** Query ***\n\t\t %s",LOG03, szCadenaSQL);
    
    if (!bfnPreparaCursorClientes(szCadenaSQL)) 
    {
    	return FALSE ;
    }
    
    vDTrazasLog  (modulo, "<< Insertando Clientes ... >>", LOG03);
	
	lContCli=0;
	
	while (1) /* ciclo infinito */
	{
    	EXEC SQL FETCH CursorCLIENTES INTO
					:lhCodCliente;
					
		if (SQLCODE == SQLNOTFOUND) 
		{
			bTerminoOK=TRUE;
			break;
		}
		else if (SQLCODE)
		{	
			bTerminoOK=FALSE;
			strcpy(szMotivo,sqlca.sqlerrm.sqlerrmc);
			break;
		}
		else
		{
			if (bfnInsertaClientes(lhCodCliente,&stDat))  
			{    		
				if(!fnOraCommit())
				{
					vDTrazasError(modulo,"ERROR EN COMMIT.  Intentará hacer Rollback\n\t=> Detalle : %s\n", 
		            	         LOG01, sqlca.sqlerrm.sqlerrmc);
					if (!fnOraRollBack())
					{
	    				vDTrazasError(modulo,"ERROR EN ROLLBACK\n\t=>Detalle : %s\n", 
	    	                     LOG01, sqlca.sqlerrm.sqlerrmc);
					}
					bTerminoOK=FALSE;
					strcpy(szMotivo,sqlca.sqlerrm.sqlerrmc);
					break;
				}
				lContCli++; /* Aumenta el contador de los clientes insertados */

			}
			else
			{
				if (!fnOraRollBack())
				{
    				vDTrazasError(modulo,"ERROR EN ROLLBACK\n\t=>Detalle : %s\n", 
    	                     LOG01, sqlca.sqlerrm.sqlerrmc);
				}
				bTerminoOK=FALSE;
				strcpy(szMotivo,sqlca.sqlerrm.sqlerrmc);
				break;
			}
		}	
		vDTrazasLog  (modulo, "<< Continua con el siguiente Cliente >>\n", LOG05);
	}/* endwhile */
	
	vDTrazasLog(modulo,"<< Cerrando Cursor >>", LOG03);
	EXEC SQL CLOSE CursorCLIENTES;

	if (SQLCODE)
	{	
		vDTrazasLog  (modulo,"<< Al Cerrar Cursor Clientes >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		vDTrazasError(modulo,"<< Al Cerrar Cursor Clientes >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
	}


	if (!bTerminoOK)
	{
		vDTrazasError(modulo,"<< Sale por error inesperado  >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,szMotivo);
		return FALSE;
	}

    vDTrazasLog  (modulo, "\n<< Insertados : %ld Clientes >>\n", LOG03, lContCli);
	
	return TRUE;
	
}

/*******************************************************************************************************/

/* ******************************************************************************** */
/* cfnGetTime : Recupera la fecha en el formato deseado (pudiendo ser fecha y hora) */
/* ******************************************************************************** */
/*char *cfnGetTime(int fmto)
{
	char modulo[]="cfnGetTime";

	static time_t timer;
	static size_t nbytes;
	static char szTime[26]="";

	memset(szTime,'\0',26);
	timer = time((time_t *)0);

	switch (fmto)
	{
		case 1 :
				nbytes = strftime(szTime, 26, "[%d-%b-%Y] [%H:%M:%S]", (struct tm *)localtime(&timer));	
				break;
		case 2 :
				nbytes = strftime(szTime, 26, "%Y%m%d", (struct tm *)localtime(&timer));	
				break;
		case 3 :
				nbytes = strftime(szTime, 26, "[%H:%M:%S]", (struct tm *)localtime(&timer));	
				break;
		case 4 :
				nbytes = strftime(szTime, 26, "%H%M%S", (struct tm *)localtime(&timer));	
				break;
		default :
				nbytes = strftime(szTime, 26, "%d/%m/%Y", (struct tm *)localtime(&timer));	
				break;
	}
	
	return szTime;

}

******************************************************************************************/
/* bfnPreparaCursorMensajes() */
/******************************************************************************************/
	
BOOL bfnPreparaCursorMensajes()
{
	char modulo[]="bfnPreparaCursorMensajes";
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);
	
	EXEC SQL DECLARE CursorMENSAJES CURSOR FOR
			 SELECT MEN.ROWID,
					MEN.COD_CLIENTE,
					MEN.COD_FORMULARIO,
					MEN.COD_BLOQUE,
					NVL(MEN.COD_PRIORIDAD,999),
					MEN.NUM_LINEAS,
					PAR.CANT_LINEASMEN
			   FROM FA_MENSCICLO MEN, FA_PARMENSAJE PAR
	          WHERE MEN.COD_CLIENTE > 0
	            AND MEN.COD_FORMULARIO > 0 
	            AND MEN.COD_BLOQUE > 0 		
	          	AND MEN.COD_FORMULARIO = PAR.COD_FORMULARIO /* join entre las tablas */
	            AND MEN.COD_BLOQUE     = PAR.COD_BLOQUE
	       ORDER BY MEN.COD_CLIENTE,MEN.COD_FORMULARIO,MEN.COD_BLOQUE,MEN.COD_PRIORIDAD;

	if(SQLCODE)
	{
		vDTrazasError(modulo , "<< Al declarar el Cursor de los Mensajes >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
	}
	
	EXEC SQL OPEN CursorMENSAJES;
	if(SQLCODE)
	{
		vDTrazasError(modulo , "<< Al Abrir el Cursor de los Mensajes >>"
                               "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
	}
	return TRUE;
}

/***************************************************************************************/
/* bfnPriorizaMensajes()  */
/***************************************************************************************/
BOOL bfnPriorizaMensajes()
{
	char modulo[]="bfnPriorizaMensajes";
	char szMotivo[128]="";
	BOOL bTerminoOK_MSG=FALSE;
	long lCont=0;
	long lClientAnt;
	 int iFormulAnt;
	 int iBloqueAnt;
	 int iPrioriAnt;
	 int iTamMsjAnt;
	 int iTamBlqAnt;				
	 
    EXEC SQL BEGIN DECLARE SECTION;
		char szhRowid     [20]	; EXEC SQL VAR szhRowid IS STRING(20) ;
		long lhCodCliente		;
		 int ihCodFormulario	;
		 int ihCodBloque		;
		 int ihCodPrioridad		;
		 int ihTamMensaje		;  /* Tamaño del mensaje */    
		 int ihTamBloque		;  /* Tamaño del bloque  */
		char szhIndFactur [2]   ;
    EXEC SQL END DECLARE SECTION;
    
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);

/*
    vDTrazasLog  (modulo, "Funcion no definida", LOG01);
    vDTrazasError(modulo, "Funcion no definida", LOG01);	
	return FALSE;
*/
	if (!bfnPreparaCursorMensajes()) return FALSE;

	bTerminoOK_MSG=TRUE;
	lCont=0;
	lClientAnt= -1 ; /* valores ficticios para la primera comparacion */
	iFormulAnt= -1 ;
	iBloqueAnt= -1 ;

    vDTrazasLog (modulo, "Recorriendo Cursor", LOG05);
	while (1)
	{
		memset(szhIndFactur,0,sizeof(szhIndFactur));

		EXEC SQL FETCH CursorMENSAJES
	              INTO :szhRowid,
	           		   :lhCodCliente,
	           		   :ihCodFormulario,
	           		   :ihCodBloque,
	           		   :ihCodPrioridad,
	           		   :ihTamMensaje,
	           		   :ihTamBloque;
	
		if (SQLCODE == SQLNOTFOUND) 
		{
		    vDTrazasLog (modulo, "\t\t** Fin del Cursor **\n", LOG03); 
			bTerminoOK_MSG=TRUE;
			break;
		}
		else if (SQLCODE)
		{	
			bTerminoOK_MSG=FALSE;
			sprintf(szMotivo,"%s",sqlca.sqlerrm.sqlerrmc);
			break;
		}
		else /* SQLOK */
		{												
			lCont++;

			if ((lClientAnt==lhCodCliente)&&(iFormulAnt==ihCodFormulario)&&(iBloqueAnt==ihCodBloque))	
			{
				/* si es el mismo cliente, formulario y bloque que el registro anterior */
				if(ihTamMensaje<=iTamBlqAnt)		/* si el mensaje cabe en lo que queda del bloque */
				{
					iTamBlqAnt -= ihTamMensaje; /* disminuye el espacio restante del bloque */
					szhIndFactur[0]='I';
				}
				else
				{
					szhIndFactur[0]='N';
				}
			}
			else 
			{
				/* Si se trata de un nuevo cliente, o un nuevo formulario o un nuevo bloque, lo trata como el primero */
				lClientAnt=lhCodCliente		;
				iFormulAnt=ihCodFormulario	;
				iBloqueAnt=ihCodBloque		;
				iPrioriAnt=ihCodPrioridad	;
				iTamMsjAnt=ihTamMensaje		;
				iTamBlqAnt=ihTamBloque		;				

				if(ihTamMensaje<=iTamBlqAnt)		/* si el mensaje cabe en el bloque */
				{
					iTamBlqAnt -= ihTamMensaje; /* disminuye el espacio restante del bloque */
					szhIndFactur[0]='I';
				}
				else
				{
					szhIndFactur[0]='N';
				}
			}		
			
			EXEC SQL UPDATE FA_MENSCICLO 
			            SET IND_FACTURADO = :szhIndFactur
			          WHERE ROWID = :szhRowid;

			if (SQLCODE)
			{	
				vDTrazasError(modulo,"<< Al Updatear FA_MENSCICLO >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
				sprintf(szMotivo,"%s",sqlca.sqlerrm.sqlerrmc);
				bTerminoOK_MSG=FALSE;
				break;
			}
			
		}/*SQLOK*/
	} /* endwhile */			

	EXEC SQL CLOSE CursorMENSAJES;
	
	if (SQLCODE)
	{	
		vDTrazasError(modulo,"<< Al Cerrar Cursor de los Mensajes >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		sprintf(szMotivo,"%s",sqlca.sqlerrm.sqlerrmc);
		bTerminoOK_MSG=FALSE;
	}
	
	
	if (!bTerminoOK_MSG)
	{
		vDTrazasLog    (modulo,"<< Cursor de los Mensajes No termino OK >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,szMotivo);
		vDTrazasError  (modulo,"<< Cursor de los Mensajes No termino OK >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,szMotivo);
		return FALSE;
	}
    else
    {
		vDTrazasLog    (modulo,"<< Revisado %ld Registros >>",LOG03,lCont);
		return TRUE;
    }	
}

/******************************************************************************************/

/***********************************************************************************/
/* BOOL bfnCargaDefault()*/
/***********************************************************************************/
BOOL bfnCargaDefault(REGISTRODATOS stDatos)
{
	char modulo[]="bfnCargaDefault";
	EXEC SQL BEGIN DECLARE SECTION;
	  char szhFecEmision[9];
	   int ihCodCiclo;
	EXEC SQL END DECLARE SECTION;
	
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);
	strcpy(szhFecEmision,stDatos.szFecEmision);
	ihCodCiclo = stDatos.iCodCiclo;
	
	EXEC SQL INSERT INTO FA_MENSCICLO      (
							COD_CLIENTE		,
							COD_FORMULARIO	,
							COD_BLOQUE		,
							CORR_MENSAJE	,
							NUM_LINEAS		,
							COD_ORIGEN		,
							COD_PRIORIDAD	,
							IND_FACTURADO	)	
			SELECT DISTINCT CLIE.COD_CLIENTE,
							CLIE.COD_FORMULARIO,
							CLIE.COD_BLOQUE,
							CLIE.CORR_MENSAJE,
							CLIE.NUM_LINEAS,
							CLIE.COD_ORIGEN,
							ORI.COD_PRIORIDAD,
							'N'
					   FROM  FA_MENSCLIENTE CLIE, FA_ORIMENSAJE ORI, FA_CICLOCLI FCC
					  WHERE FCC.COD_CICLO = :ihCodCiclo
					    AND FCC.IND_MASCARA = 1
					    AND FCC.COD_CLIENTE = CLIE.COD_CLIENTE
					    AND CLIE.FEC_DESDE <= TO_DATE(:szhFecEmision,'YYYYMMDD')
					    AND CLIE.FEC_HASTA >= TO_DATE(:szhFecEmision,'YYYYMMDD')
					    AND CLIE.COD_ORIGEN=ORI.COD_ORIGEN;

	if (SQLCODE)
	{
		vDTrazasError(modulo,"<< En el insert de la FA_MENSCICLO >>"
		                     "\n\t\t=> Detalle : %s \n",LOG01,sqlca.sqlerrm.sqlerrmc);
		return FALSE;
	}
	
	return TRUE;
	
}

/********************************************************************************************/
/* bfnCargaMensajesDefault() */
/********************************************************************************************/
BOOL bfnCargaMensajesDefault(long CodCiclFact)
{
	char modulo[]="bfnCargaMensajesDefault";
	 int StsCicl=0;
	 
    vDTrazasLog (modulo, "<< Entrando en %s >>", LOG04, modulo);

 	
    memset(&stDatos,0,sizeof(REGISTRODATOS));	
	stDatos.lCodCiclFact	  = CodCiclFact	;
	strcpy(stDatos.szCriterio , critINICIO );

    vDTrazasLog (modulo, "\t\t stDatos.lCodCiclFact   [%ld]", LOG05,stDatos.lCodCiclFact   );
    vDTrazasLog (modulo, "\t\t stDatos.szCriterio     [%s]" , LOG05,stDatos.szCriterio     );

	StsCicl=ifnValidaCiclo(&stDatos);
	if ( StsCicl < 0 )
 	{
	    vDTrazasLog  (modulo, "\t\t** Fallo Validacion de Ciclo por error Oracle **", LOG01); 
	    vDTrazasError(modulo, "\t\t** Fallo Validacion de Ciclo por error Oracle **", LOG01); 
	    return FALSE;
 	}
	else if (StsCicl > 0)
	{
	    vDTrazasLog  (modulo, "\t\t** Fallo Validacion de Ciclo **", LOG01); 
	    vDTrazasError(modulo, "\t\t** Fallo Validacion de Ciclo **", LOG01); 
	    return FALSE;
 	}
    else /* StsCicl == 0 */
    {
  		if(!bfnDeleteMensCiclo(critINICIO,0,0,0," ")) /* Borrar toda la tabla */
		{
	        vDTrazasError(modulo, "No pudo eliminar datos de la FA_MENSCICLO ", LOG01);
	        return FALSE;
		}
		
		if (!bfnCargaDefault(stDatos)) 
		{
		    vDTrazasLog  (modulo, "\t\t** Fallo Carga de Mensajes por Defecto **", LOG01); 
		    vDTrazasError(modulo, "\t\t** Fallo Carga de Mensajes por Defecto **", LOG01); 
	    	return FALSE;
		}
	}
	
	
	return TRUE;
}


/******************************************************************************************/
/** Información de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisión                                            : */
/**  %PR% */
/** Autor de la Revisión                                : */
/**  %AUTHOR% */
/** Estado de la Revisión ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creación de la Revisión                    : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/

