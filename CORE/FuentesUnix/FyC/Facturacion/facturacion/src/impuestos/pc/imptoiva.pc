/****************************************************************************/
/*  Fichero    : imptoiva.pc                                                */
/*  Descripcion: funciones PROC para el calculo de impuestos                */
/*  Fecha      : 14-nov-96                                                  */
/****************************************************************************/

#define _IMPTOIVA_PC_

#include <imptoiva.h>

EXEC SQL INCLUDE sqlca;

/****************************************************************************/
/*                          Variables globales                              */
/****************************************************************************/
static int    iNImptosT     ;
 

BOOL bfnGetGedParam(char * pszNomParam, char *pszCodModulo, char *pszValParam)
{
    char  modulo[] = "bfnGetGedParam";
    EXEC SQL BEGIN DECLARE SECTION;
      char szhNomParametro[21];
      char szhValParametro[21];
      char szhCodModulo[3];
      int  ihCodProducto;
    EXEC SQL END DECLARE SECTION;

    strcpy(szhNomParametro, pszNomParam);
    strcpy(szhCodModulo, pszCodModulo);
    ihCodProducto = 1;

    EXEC SQL
        SELECT VAL_PARAMETRO
          INTO :szhValParametro
          FROM GED_PARAMETROS
         WHERE NOM_PARAMETRO = :szhNomParametro
           AND COD_MODULO    = :szhCodModulo
           AND COD_PRODUCTO  = :ihCodProducto;

    if(SQLCODE != SQLOK)
    {
        vDTrazasLog  (modulo, "\n\t**Error : En consulta parametro %s \n%s\n",LOG01,pszNomParam,SQLERRM);
        return (FALSE);
    }

    strcpy (pszValParam, szhValParametro);
    return (TRUE);

}

BOOL bAcumulaImporteXAbonado(FAPFACTURA *pFactura, ACUMABONADOS *stAcumFactAbonado){
   int iNumRegs;
   int iExiste;
   int i;
   int iPos = -1;
   BOOL bRes;
   
   vDTrazasLog (szExeName, "\n\t\tEn funcion bAcumulaImporteXAbonado"  , LOG05);
   bRes = TRUE;
   iNumRegs = stAcumFactAbonado->iNumAbonados;
  
    iExiste = 0; 
     vDTrazasLog (szExeName,"\n\t\t* Registros actuales acumulados %ld " , LOG05,  iNumRegs );
    for (i=0;i<iNumRegs;i++)    
    {
	 //  vDTrazasLog (szExeName,"\n\t\t* Se busca abonado %ld en el abonado %ld (indice %ld)"
								  // , LOG05,    pFactura->lNumAbonado, stAcumFactAbonado->stAcumAbonado[i].lNumAbonado , i);
	   if (pFactura->lNumAbonado == stAcumFactAbonado->stAcumAbonado[i].lNumAbonado){
  	      iPos = i;
	 //	  vDTrazasLog (szExeName,"\n\t\t*1 Se acmula importe %f  para el abonado %ld (posicion %ld) "
	 //							   , LOG05,  pFactura->dImpConcepto, pFactura->lNumAbonado, iPos );
		  stAcumFactAbonado->stAcumAbonado[i].dImpTotal += pFactura->dImpConcepto;
		//  stAcumFactAbonado->iNumAbonados += 1;
		  iExiste = 1;
		  break;
	   }
    }
	if (iExiste==0) {
       iPos = 1;
	   if ((stAcumFactAbonado->stAcumAbonado =
                    (ACUMABONADO *)realloc( (ACUMABONADO *)stAcumFactAbonado->stAcumAbonado,
                    (iNumRegs+1)*sizeof(ACUMABONADO) ) ) == (ACUMABONADO *)NULL)
      {
	     iDError (szExeName,ERR005,vInsertarIncidencia,"stAcumFactAbonado->stAcumAbonado");
		 strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria",
											   strlen(stAnomProceso.szObsAnomalia));
		 bRes = FALSE;
      }else
	  {
	   // vDTrazasLog (szExeName,"\n\t\t*2 Se acmula importe %f  para el abonado %ld (posicion %ld) "
		 			//		   , LOG05,  pFactura->dImpConcepto, pFactura->lNumAbonado, iNumRegs );
		 stAcumFactAbonado->stAcumAbonado[iNumRegs ].dImpTotal = 0.0;
	  	 stAcumFactAbonado->iNumAbonados = iNumRegs+1;
         stAcumFactAbonado->stAcumAbonado[iNumRegs ].lNumAbonado = pFactura->lNumAbonado;
	     stAcumFactAbonado->stAcumAbonado[iNumRegs ].dImpTotal += pFactura->dImpConcepto; 
	//	  vDTrazasLog (szExeName,"\n\t\t*2 Se agrego elemento : lNumAbonado %ld importe %f "
		// 						   , LOG05, stAcumFactAbonado->stAcumAbonado[iNumRegs ].lNumAbonado  , stAcumFactAbonado->stAcumAbonado[iNumRegs ].dImpTotal);  
	  }
	}
    return bRes;
}

//P-CSR-12019
BOOL bfnAplicaImptoUmbralNotaCredParcial(int iIndxConcepto,
                                          double dpMontoImpto, char *cpCodMonedaImpto, 
                                         long lNumAbonado,
										 int iTipoFact,
										 ACUMIMPUESTOABONADOS *pAcumImptoAbonado,
										 ACUMABONADO *pAcumAbonado,
										  IMPUESTOS *pImpuesto, ACUMDETIMPTOSTIPO *pAcumImptoTipo)
{
   char  modulo[] = "bfnAplicaImptoUmbralNotaCredParcial";
   double dMtoImpuesto;
   double dMtoBase;     
   double dMtoFacturable = 0.0;
   double dMonto = 0.0;
   double dMontoNCred = 0.0;
   BOOL   bAplicarImpto;
   int    iPos;
   int    i;

    vDTrazasLog (szExeName,"\n\t\t* En funcion %s " , LOG03,modulo );
   bAplicarImpto = FALSE;

    for (i=0 ; i< pAcumImptoTipo->iNumRegs;i++){
          vDTrazasLog (szExeName,"\n\t\t* Concepto [%d] Abonado buscado [%d], Abonado existente [%d] Tip Impto buscado [%d] Tip. Impto Existente [%d]" , 
		      LOG05, pImpuesto->iCodConcGene, lNumAbonado,pAcumImptoTipo->stDetImptosTipo[i].lNumAbonado,pImpuesto->iCodTipImpues, pAcumImptoTipo->stDetImptosTipo[i].iCodTipImpues  );
			
         if (lNumAbonado == pAcumImptoTipo->stDetImptosTipo[i].lNumAbonado &&
	       pAcumImptoTipo->stDetImptosTipo[i].iCodTipImpues == pImpuesto->iCodTipImpues)
	    {
		    dMontoNCred =  pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoOrigen - pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoNCred ;
		    dMonto = pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoOrigen - (pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoNCred + dpMontoImpto) ;
            vDTrazasLog (szExeName,"\n\t\t* Acum Neto Afecto Origen [%f]"
			                       "\n\t\t*, Monto NCred [%f] "
								   "\n\t\t*, Monto neto concepto [%f] "
								   "\n\t\t*, Monto neto origen [%f] "
								   "\n\t\t*, Acum neto NCred [%f] " 
								   , LOG05,  pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoOrigen ,
                                  dMontoNCred	,dpMontoImpto,  pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoOrigen,	pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoNCred 						   );

		    vDTrazasLog (szExeName,"\n\t\t* Monto neto de impuestos [%f], Monto Neto Afecto Origen [%f] Monto Neto Afecto NCred [%f]" , 
			                LOG05, dMonto, pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoOrigen ,pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoNCred  );
			
			pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoNCred += dpMontoImpto;
			
		    if (dMonto <= dMontoNCred) {
		        bAplicarImpto = TRUE;
			    iPos = i;
			    
				if (dMonto < pImpuesto->dImpUmbral )
				    dMonto = dMontoNCred;
			    else
		            dMonto = dMontoNCred - dMonto ;
		        if (!bCalculaMtoImptoNotaCredUmbral (0,              
                             dMonto,
							cpCodMonedaImpto,
                            *pImpuesto, 
                            &pAcumImptoTipo->stDetImptosTipo[i],							
							lNumAbonado, 
                            &dMtoImpuesto, 
                            &dMtoBase,    
							&dMtoFacturable) )
                {
                    return FALSE;
                }
			  break;
		    }
	 	  /*  dMonto = pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoOrigen - (pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoNCred + dMtoFacturable) ;
		    vDTrazasLog (szExeName,"\n\t\t* Monto neto de impuestos [%f], Monto Neto Afecto Origen [%f] " , LOG05, dMonto, pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoOrigen  );
		   if (dMonto <= pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoOrigen ) {
		      bAplicarImpto = TRUE;
			  iPos = i;
			  break;
		   }*/
	   }
    }
    vDTrazasLog (szExeName,"\n\t\t* Monto Impuesto calculado [%f] " , LOG05, dMtoImpuesto );
	vDTrazasLog (szExeName,"\n\t\t* Monto Base calculado [%f] ", LOG05,dMtoBase );
	vDTrazasLog (szExeName,"\n\t\t* Monto Facturable calculado [%f] " , LOG05, dMtoFacturable );
	
    if (bAplicarImpto == TRUE) {
       vDTrazasLog (szExeName,"\n\t\t* Aplica Impuesto" , LOG05 );
       if (!bfnAplicaImptoDocto2( pImpuesto, iIndxConcepto , iTipoFact, dMtoImpuesto, dMtoBase, dMtoFacturable))
       {
             vDTrazasError(modulo,"\n\t** ERROR, en cracion del concepto de Impto. **",LOG01);
             return (FALSE);
       }
	   pAcumImptoTipo->stDetImptosTipo[iPos].dAcumImpuestoNCred += dMtoImpuesto;
	   pAcumImptoTipo->stDetImptosTipo[iPos].dAcumNetoAfectoNCred += dMtoBase;
    } 
    else
       vDTrazasLog (szExeName,"\n\t\t* No Aplica Impuesto" , LOG05 );
   return TRUE;
}
/*****************************************************************************/
/*  FUNCION     : bImtosIvaClienteGeneral                                    */
/*  DESCRIPCION : Funcion que Aplica Impuestos a los Conceptos generados en  */
/*                un ciclo paraun Cliente.                                   */
/*****************************************************************************/
BOOL bImptosIvaClienteGeneral (int iTipoFact)
{
    char  modulo[] = "bImptosIvaClienteGeneral";

    int      iNumRegIni        = 0 ;
    int      iInd              = 0 ;
    int      i                 = 0 ;
    int      iNImptos          = 0 ;
	int      iHayImptoCruzRoja = 0 ;
    int      iNumConceptos     = 0 ;
    int      iCodZonaImpos     = 0 ;
    int      iCodZonaAbon      = 0 ;
    int      iCodZonaAbon_Ant  = -1;
    int      iCodZonaImp       = 0;
    int      iCodGrpServi      = 0 ;
    int      iContadorAux      = -1;
    long     lCodUsuario       = 0 ;
    long     lCodUsuario_Ant   = -1;
    char     szCodRegion    [4]= "";
    char     szCodProvincia [6]= "";
    char     szCodCiudad    [6]= "";
    char     szCodComuna    [6]= "";
    char     szFecZonaImpo [15] = "";
    char     szFuncion     [20] = "";
    IMPTOS   stImpto = {0,(IMPUESTOS *)NULL};
 
    /* Acumula el total de los impuestos para el ajuste */
    TOTIMPTOS stTotImptos={0,(TOTIMPTO *)NULL};

	ACUMABONADOS stAcumFactAbonado={0,(ACUMABONADO *)NULL}; /*P-CSR-12019*/
	
    iNImptosT = 0;

    strcpy (stAnomProceso.szDesProceso, "Impuestos");

    switch (iTipoFact)
    {
        case FACT_CICLO      :
             strcpy (szFuncion,"CICLO")      ;
             break                           ;
        case FACT_CONTADO    :
             strcpy (szFuncion,"CONTADO")    ;
             break                           ;
        case FACT_BAJA       :
             strcpy (szFuncion,"BAJA")       ;
             break                           ;
        case FACT_LIQUIDACION:
             strcpy (szFuncion,"LIQUIDACION");
             break                           ;
        case FACT_RENTAPHONE  :
             strcpy (szFuncion,"RENT PHONE") ;
             break                           ;
        case FACT_COMPRA      :
             strcpy (szFuncion,"COMPRA")     ;
             break                           ;
        case FACT_MISCELAN    :
             strcpy (szFuncion,"MISCELAN")   ;
             break                           ;
        case FACT_ROAMINGVIS  :
             strcpy (szFuncion,"ROAMING VISITANTE");
             break                                 ;
        default               :
             break                           ;
    }
    vDTrazasLog (szExeName,"\n\t\t* IMPUESTOS %s\n\t\t=> Cliente [%ld]"
                          , LOG04,szFuncion
                          , stCliente.lCodCliente);

    /*********************************************************/
    strcpy (szFecZonaImpo, szGetFecZonaImp(stProceso.iCodTipDocum));
    if (strlen (szFecZonaImpo) == 0)
    {
        iDError (modulo,ERR040,vInsertarIncidencia);
        return FALSE;
    }

    if (!bfnEvalZonasImpos (szFecZonaImpo, iTipoFact, &iCodZonaImpos, pstParamGener.iIndZonaImpCic))
    {
        vDTrazasError(modulo,"\n\t** No se pueden evaluar Zonas Impositivas **",LOG01);
        vDTrazasLog  (modulo,"\n\t** No se pueden evaluar Zonas Impositivas **",LOG01);
        return FALSE;
    }
    /* Pasa a la prefactura el valor de la zona impositiva */
    stPreFactura.iCodZonaImpo=iCodZonaImpos;
    /* *************************************************** */

    iNumRegIni = stPreFactura.iNumRegistros;

    for (i=0;i<iNumRegIni;i++)
    { 
 
        if (stPreFactura.A_PFactura[i].iCodTipConce  == ARTICULO ||
            stPreFactura.A_PFactura[i].iCodTipConce  == DESCUENTO )
        {
            if (!bGetGrupoServicios (stPreFactura.A_PFactura[i].iCodConcepto,
                                     &iCodGrpServi, szFecZonaImpo,iTipoFact))
            {
                 return FALSE;
            }
            
            if (iCodGrpServi == ORA_NULL)
            {
                vDTrazasLog(modulo, "\n\t\t* Concepto [%d] NO tiene Grupo Servicios Asociado"
                                  , LOG04,stPreFactura.A_PFactura[i].iCodConcepto);
                continue;
            }
            
            if (iTipoFact == FACT_MISCELAN || 
                stPreFactura.A_PFactura[i].lNumAbonado == 0 || 
                stPreFactura.A_PFactura[i].lNumAbonado == -1)
            {
                iCodZonaAbon=iCodZonaImpos;
            }
            else
            {
            /***************************************************************/
                if (!bfnGetDirAbonado (stPreFactura.A_PFactura[i].lNumAbonado,
                                       szCodRegion, szCodProvincia, szCodCiudad, 
                                       szCodComuna, &lCodUsuario, &iCodZonaImp))
                {
                    return FALSE;
                }
                else
                {
                    /* if cod usuario es igual al anterior, asume zona anterior sino busca nuevamente */
                    /* Obtiene  la zona impositiva del abonado */
                    if (lCodUsuario_Ant==lCodUsuario)
                    {
                        iCodZonaAbon=iCodZonaAbon_Ant;
                    }
                    else
                    {
                        if (!bGetZonaImpositiva (szCodRegion   ,
                                 szCodProvincia,
                                 szCodCiudad   ,
                                 &iCodZonaAbon, szFecZonaImpo, iTipoFact))
                        {
                            vDTrazasError(modulo,"\n\t** No se puede obtener Zona Impositiva Abonado **",LOG01);
                            vDTrazasLog  (modulo,"\n\t** No se puede obtener Zona Impositiva Abonado **",LOG01);
                                return FALSE;
                        }
                        else
                        {
                            iCodZonaAbon_Ant=iCodZonaAbon;
                        }/*if encuentra zonaAbon*/
                    }/* if usuario es el mismo anterior*/
                    lCodUsuario_Ant=lCodUsuario;
                }/* if encuentra direccion de Abonado */
            } /*fact miscelanea*/

            /* *************************************************** */
			/*P-CSR-12019*/
			if (!bGetImpuestosAll (stCliente.iCodCatImpos, iCodZonaImpos, szFecZonaImpo,iCodZonaAbon, iCodGrpServi,
                            &stImpto, iTipoFact))
							
           /* if (!bGetImpuestos (stCliente.iCodCatImpos, iCodZonaImpos,iCodZonaAbon, iCodGrpServi ,
                              szFecZonaImpo,&stImpto, iTipoFact))*/
            {
                vFreeImpuestos(&stImpto);
				vFreeAcumAbonado(&stAcumFactAbonado);
                return FALSE;
            }
            /*FIN P-CSR-12019*/
            vDTrazasLog (modulo, "\n\t\t* Aplica Iva "
                                 "\n\t\t=> Cod.TipConce       [%d]"
                                 "\n\t\t=> Ind.Factur         [%d]"
                                 "\n\t\t=> Zona Impositiva    [%d]"
                                 "\n\t\t=> Grupo Servicios    [%d]"
                                 "\n\t\t=> Numero de Impuestos[%d]"
                                 "\n\t\t=> Concepto           [%d]"
                               , LOG05
                               , stPreFactura.A_PFactura[i].iCodTipConce 
                               , stPreFactura.A_PFactura[i].iIndFactur   
                               , iCodZonaImpos, iCodGrpServi, stImpto.iNumImpuestos
                               , stPreFactura.A_PFactura[i].iCodConcepto);
                               
            iContadorAux = -1;
            iHayImptoCruzRoja = 0;
            for (iInd=0;iInd<stImpto.iNumImpuestos;iInd++)
            {
                iNumConceptos = stPreFactura.iNumRegistros;
                 if (stImpto.pImpuestos[iInd].iCodTipImpues == pstFadParam.iCodTipImptoDocto)
				 {   iHayImptoCruzRoja=1;
				     continue;
				 }
                if (!bfnAplicaImpto(i, &stImpto.pImpuestos[iInd], iTipoFact))
                {
                    vDTrazasError(modulo,"\n\t** ERROR, en creacion del concepto de Impto. **",LOG01);
                    vFreeImpuestos(&stImpto);
					vFreeAcumAbonado(&stAcumFactAbonado);
                    return (FALSE);
                }

                if (!bCalculaImptos (i,&stImpto.pImpuestos[iInd], iNumConceptos))
                {
                    vFreeImpuestos(&stImpto);
					vFreeAcumAbonado(&stAcumFactAbonado);
                    return FALSE;
                }

                stPreFactura.A_PFactura[iNumConceptos].iCodZonaAbon=iCodZonaAbon;
                
                vDTrazasLog (modulo, "\n\t\t SUMATORIA IMP_FACT_CON_IVA \n"
                                       "\t\t ========================== \n"
                                       "\t\t (i)                           => [%d]\n"
                                       "\t\t dImpFactConIva (i)            => [%f]\n"
                                       "\t\t (iNumConceptos)               => [%d]\n"
                                       "\t\t dImpFacturable (i)            => [%f]\n"
                                       "\t\t dImpConcepto (i)              => [%f]\n"                                       
                                       "\t\t dImpFacturable (iNumConceptos)=> [%f]\n"
                                   , LOG06
                                   , i                                
                                   , stPreFactura.A_PFactura[i].dImpFactConIva
                                   , iNumConceptos
                                   , stPreFactura.A_PFactura[i].dImpFacturable
                                   , stPreFactura.A_PFactura[i].dImpConcepto  /* P-MIX-09003 77 */    
                                   , stPreFactura.A_PFactura[iNumConceptos].dImpFacturable ); /* P-MIX-09003 77 */                                  
                
                if (iContadorAux == -1)
                {
                    stPreFactura.A_PFactura[i].dImpFactConIva = stPreFactura.A_PFactura[i].dImpFacturable + 
                                                                stPreFactura.A_PFactura[iNumConceptos].dImpFacturable; /* P-MIX-09003 77 */
                    iContadorAux = i;                                                                
                }
                else
                {
                    if (iContadorAux == i)
                    {
                        stPreFactura.A_PFactura[i].dImpFactConIva = stPreFactura.A_PFactura[i].dImpFactConIva + 
                                                                    stPreFactura.A_PFactura[iNumConceptos].dImpFacturable; /* P-MIX-09003 77 */                     
                    }                    
                }
                                                            
                vDTrazasLog (modulo, "\n\t\t SUMA IMP_FACT_CON_IVA \n"
                                       "\t\t ========================== \n"
                                       "\t\t dImpFactConIva (i) => [%f]\n"
                                   , LOG06
                                   , stPreFactura.A_PFactura[i].dImpFactConIva ); /* P-MIX-09003 77 */                                                            

                if (!bfnAcumTotImptos (&stTotImptos
                        ,stPreFactura.A_PFactura[i].iCodConcepto
                        ,stPreFactura.A_PFactura[iNumConceptos].iCodConcepto
                        ,stPreFactura.A_PFactura[i].dImpFacturable
                        ,stPreFactura.A_PFactura[iNumConceptos].dImpFacturable
                        ,stPreFactura.A_PFactura[iNumConceptos].fPrcImpuesto
                        ,stImpto.pImpuestos[iInd].iTipMonto))
                {
                    vDTrazasError(modulo,"\n\t**  Error en acumulacion de Impuestos **",LOG01);
                    vFreeTotImpuestos(&stTotImptos);
                    vFreeImpuestos(&stImpto);
					vFreeAcumAbonado(&stAcumFactAbonado);
                    return (FALSE);
                }
                iNImptos++;

                if (stPreFactura.A_PFactura[i].iIndCuota == IND_CUOTA &&
                        iTipoFact == FACT_CONTADO)
                {
                    if (stPreFactura.A_PFactura[i].iCodTipConce == ARTICULO)
                    {
                        if(!bGeneraCuotas(stPreFactura.A_PFactura[i].lNumCargo ,
                                      stPreFactura.A_PFactura[i].szCodCuota    ,
                                      stImpto.pImpuestos[iInd].fPrcImpuesto    ,
                                      stPreFactura.A_PFactura[i].iCodConcepto ))
                        {
                            vFreeTotImpuestos(&stTotImptos);
                            vFreeImpuestos(&stImpto);
							vFreeAcumAbonado(&stAcumFactAbonado);
                            return FALSE;
                        }
                    }
                }

            }/* fin for->iInd */ 

			vDTrazasLog (modulo, "\n\t\tConcepto %d del cliente %ld. Hay Impto Cruz Roja %d .\n", LOG04,stPreFactura.A_PFactura[i].iCodConcepto,  stPreFactura.A_PFactura[i].lCodCliente, iHayImptoCruzRoja);
			if (iHayImptoCruzRoja==1){
				/*P-CSR-12019*/
				vDTrazasLog (modulo, "\n\t\tConcepto %d del cliente %ld tiene impuesto cruz roja. Se procede a acumular el monto del concepto.\n"
                               , LOG04,stPreFactura.A_PFactura[i].iCodConcepto,  stPreFactura.A_PFactura[i].lCodCliente);
		        if (!bAcumulaImporteXAbonado(&stPreFactura.A_PFactura[i], &stAcumFactAbonado) ){
				    vFreeTotImpuestos(&stTotImptos);
                    vFreeImpuestos(&stImpto);
					vFreeAcumAbonado(&stAcumFactAbonado);
		            return FALSE;
		       }
		       /* FIN P-CSR-12019*/
			}
            vDTrazasLog (modulo, "\n\t\tImpuestos aplicados al concepto %d del cliente %ld\n"
                               , LOG04,stPreFactura.A_PFactura[i].iCodConcepto
                               , stPreFactura.A_PFactura[i].lCodCliente );
            vFreeImpuestos(&stImpto);
            
            iNImptosT += iNImptos;

        }/* fin if Imptos y Carrier */
    }/* fin for i<iNumRegIni */

/******************************************************/
/* Codigo para guardar Zona Impositiva del Abonado     */
/******************************************************/
    if(stPreFactura.iNumRegistros > 0)
    {
        if (!bfnRegZonaAbon(iNumRegIni))
        {   vFreeAcumAbonado(&stAcumFactAbonado);
            vDTrazasError(modulo,"\n\t**  Error en proceso bfnRegZonaAbon **",LOG01);
            return (FALSE);
        }
    }
/******************************************************/

/******************************************************/
/* Codigo para realizacion de ajuste de Impuestos     */
/******************************************************/
    vDTrazasLog (modulo,"\n\t\t# stPreFactura.iNumRegistros [%d] entrada a bfnAjusteImptos\n",LOG04,stPreFactura.iNumRegistros);
    if(stPreFactura.iNumRegistros > 0)
    {
        if (!bfnAjusteImptos(&stTotImptos))
        {
            vDTrazasError(modulo,"\n\t**  Error en proceso de Ajuste de Impuestos **",LOG01);
            vFreeTotImpuestos(&stTotImptos);
			vFreeAcumAbonado(&stAcumFactAbonado);
            return (FALSE);
        }
    }

    vDTrazasLog (modulo,"\n\t\t# Cliente [%ld] => Impuestos Aplicados [%d]\n",
                LOG03,stCliente.lCodCliente,iNImptos);


/******************************************************
 * Impuesto al documento (Maicao)
 ******************************************************/
    if (pstImptoDctos.iNumImptosDctos)
    {
        if (!bfnProcImptoMaicao (iTipoFact, szFecZonaImpo))
        {
            vDTrazasError(modulo,"\n\t** Error Aplicacion de Impuesto Maicao. **",LOG01);
            vFreeTotImpuestos(&stTotImptos);
			vFreeAcumAbonado(&stAcumFactAbonado);
            return (FALSE);
        }
    }
/**********************************¡***************************
 * Impuesto al documento con rango Umbral y Maximo (Cruz Roja)
 *************************************************************/
 vDTrazasLog (modulo, "\n\t\tCantidad de abonados acumulados para impuesto Cruz Roja %d .\n", LOG04,stAcumFactAbonado.iNumAbonados);
			
    if (pstFadParam.iCodTipImptoDocto)
    { if (stAcumFactAbonado.iNumAbonados > 0) {
        if (!bImptosDoctoUmbral (iTipoFact, szFecZonaImpo, iCodZonaImpos, &stAcumFactAbonado))
        {
            vDTrazasError(modulo,"\n\t** Error Aplicacion de Impuestos Documentos con rangos **",LOG01);
            vFreeTotImpuestos(&stTotImptos);
			vFreeAcumAbonado(&stAcumFactAbonado);
            return (FALSE);
        }
	  }
    }
/******************************************************/
    vFreeTotImpuestos(&stTotImptos);
    vFreeAcumAbonado(&stAcumFactAbonado);
 return TRUE;
}/************************** Final bImptosIvaClienteGeneral ****************************/

/*P-CSR-12019*/
BOOL bfnAplicaImptoDoctoNotasCred (int iCodConcepto ,char *szDesConcepto,float fPrcImpuesto, double pdMtoImpto, double pdMtoBase,
                                   long iIdxOri, int iTipoFact, int iCodTipConce )
{
    int iIdxFin;
    
    iIdxFin = stPreFactura.iNumRegistros;
 
    memcpy (&stPreFactura.A_PFactura[iIdxFin], &stPreFactura.A_PFactura[iIdxOri], sizeof (FAPFACTURA));

    if (!bGetMaxColPreFa(iCodConcepto, &stPreFactura.A_PFactura[iIdxFin].lColumna ))
        return FALSE;
    
    stPreFactura.A_PFactura[iIdxFin].iCodConcepto = iCodConcepto ;

    strcpy (stPreFactura.A_PFactura[iIdxFin].szDesConcepto, szDesConcepto);
    stPreFactura.A_PFactura[iIdxFin].fPrcImpuesto = fPrcImpuesto;

    stPreFactura.A_PFactura[iIdxFin].dImpConcepto  = pdMtoImpto;
    stPreFactura.A_PFactura[iIdxFin].dImpMontoBase = pdMtoBase;
    stPreFactura.A_PFactura[iIdxFin].dImpFacturable = fnCnvDouble (pdMtoImpto,0);

    vDTrazasLog (szExeName, "\n\t\t* Calculo Impuesto Docto:"
                            "\n\t\t=> iNumReg        [%d]"
                            "\n\t\t=> Mto. Impuesto  [%f]"
                            "\n\t\t=> Mto. Base      [%f]"
                            "\n\t\t=> Monto Neto     [%f]"
                            "\n\t\t=> Monto Facturable [%f]"
                          , LOG05
                          , iIdxFin, pdMtoImpto, pdMtoBase
                          , stPreFactura.A_PFactura[iIdxFin].dImpConcepto
                          , stPreFactura.A_PFactura[iIdxFin].dImpFacturable);

    stPreFactura.A_PFactura[iIdxFin].bOptImpuesto = TRUE;
                                    
    switch (iTipoFact)
    {
        case FACT_CICLO      :
        case FACT_BAJA       :
            strcpy (stPreFactura.A_PFactura[iIdxFin].szFecValor , stCiclo.szFecEmision);
            break;
        case FACT_CONTADO    :
        case FACT_COMPRA     :
        case FACT_MISCELAN   :
        case FACT_LIQUIDACION:
        case FACT_RENTAPHONE :
        case FACT_ROAMINGVIS :
            strcpy (stPreFactura.A_PFactura[iIdxFin].szFecValor, szSysDate);
            break;
        default              :
            break;
    }

    strcpy(stPreFactura.A_PFactura[iIdxFin].szFecEfectividad, stPreFactura.A_PFactura[iIdxOri].szFecValor );
    stPreFactura.A_PFactura[iIdxFin].iIndEstado    = EST_NORMAL;
    stPreFactura.A_PFactura[iIdxOri].iIndEstado    = EST_IMPTO ;
    stPreFactura.A_PFactura[iIdxFin].iCodTipConce  = IMPUESTO  ;
    stPreFactura.A_PFactura[iIdxFin].lNumUnidades  = 1;
    stPreFactura.A_PFactura[iIdxFin].lCodCiclFact  = stCiclo.lCodCiclFact;
    stPreFactura.A_Ind[iIdxFin].i_lCodCiclFact     = (stCiclo.lCodCiclFact == ORA_NULL)?ORA_NULL:SQLOK;
    stPreFactura.A_PFactura[iIdxFin].iCodConceRel  = stPreFactura.A_PFactura[iIdxOri].iCodConcepto;
    stPreFactura.A_PFactura[iIdxFin].lColumnaRel   = stPreFactura.A_PFactura[iIdxOri].lColumna ;
    stPreFactura.A_PFactura[iIdxFin].lNumAbonado   = stPreFactura.A_PFactura[iIdxOri].lNumAbonado;
    stPreFactura.A_Ind[iIdxFin].i_lNumAbonado      = (stPreFactura.A_PFactura[iIdxOri].lNumAbonado == ORA_NULL)?-1:0 ;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szNumTerminal , "" );
    stPreFactura.A_Ind[iIdxFin].i_szNumTerminal    =  -1;
    stPreFactura.A_Ind[iIdxFin].i_lCapCode         =  (stPreFactura.A_PFactura[iIdxOri].lCapCode   == ORA_NULL)?-1:0    ;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szNumSerieMec , "" );
    stPreFactura.A_Ind[iIdxFin].i_szNumSerieMec    = -1;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szNumSerieLe  , "" );
    stPreFactura.A_Ind[iIdxFin].i_szNumSerieLe     = -1;
    stPreFactura.A_PFactura[iIdxFin].iFlagImpues   = 0 ;
    stPreFactura.A_PFactura[iIdxOri].iFlagImpues   = 1 ;
    stPreFactura.A_PFactura[iIdxFin].iFlagDto      = 0 ;
    stPreFactura.A_PFactura[iIdxFin].iFlagDto      = 0 ;
    stPreFactura.A_PFactura[iIdxFin].dValDto       = -1;
    stPreFactura.A_Ind[iIdxFin].i_dValDto          = -1;
    stPreFactura.A_PFactura[iIdxFin].iTipDto       = -1;
    stPreFactura.A_Ind[iIdxFin].i_iTipDto          = -1;
    stPreFactura.A_PFactura[iIdxFin].lNumVenta     = -1;
    stPreFactura.A_Ind[iIdxFin].i_lNumVenta        = -1;

    stPreFactura.A_PFactura[iIdxFin].lNumTransaccion = -1 ;
    stPreFactura.A_Ind[iIdxFin].i_lNumTransaccion    = -1;
    stPreFactura.A_PFactura[iIdxFin].iMesGarantia   = 0;
    stPreFactura.A_PFactura[iIdxFin].iIndAlta       = 1;
    stPreFactura.A_PFactura[iIdxFin].iIndSuperTel   = 0;
    stPreFactura.A_PFactura[iIdxFin].iNumPaquete    =-1;
    stPreFactura.A_Ind[iIdxFin].i_iNumPaquete       =-1;
    stPreFactura.A_PFactura[iIdxFin].iIndCuota      = 0;
    stPreFactura.A_PFactura[iIdxFin].iNumCuotas     = 0;
    stPreFactura.A_PFactura[iIdxFin].iOrdCuota      = 0;

    /* stPreFactura.iNumRegistros++; */
    if(bfnIncrementarIndicePreFactura()==FALSE) 
    {
        vDTrazasLog  (szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        vDTrazasError(szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        return FALSE;
    }

    return(TRUE);
}
BOOL bfnTotalizaImptoNCred (int iCodTipImpues, long lpNumAbonado,  double dpMontoImpt, double dpMontoBase,int ipTipoFact, ACUMDETIMPTOSTIPO *pAcumImptoTipo)
{ char  modulo[] = "bfnTotalizaImptoNCred";
  int i;
  BOOL bExiste=FALSE;
  int iCodGrpServi;
  int iCodZonaAbon;
  char szFecEmision[15];
//  int iCodTipImpues;
    
/*	strcpy(szFecEmision,stNota.szFecEmision);
     if (!bGetGrupoServicios (ipCodConcepto, &iCodGrpServi,szFecEmision,ipTipoFact))
         return FALSE;

    if (iCodGrpServi == ORA_NULL)
    {
        vDTrazasLog (modulo,
                      "\n\t\t* Concepto [%d] NO tiene Grupo Servicios Asociado",
                      LOG03,stPreFactura.A_PFactura[i].iCodConcepto);
        return FALSE;
    }
		 
	 EXEC SQL SELECT I.COD_TIPIMPUES
	        INTO iCodTipImpues
            FROM   GE_IMPUESTOS I
            WHERE  I.COD_CATIMPOS = :stNota.iCodCatImpos
              AND  I.COD_ZONAIMPO =:stNota.iCodZonaImpo
              AND I.COD_ZONAABON = :stNota.iCodZonaImpo
              AND I.COD_GRPSERVI = :iCodGrpServi
              AND  I.FEC_DESDE   <= TO_DATE (:szFecEmision,'YYYYMMDDHH24MISS')
              AND  I.FEC_HASTA   >= TO_DATE (:szFecEmision,'YYYYMMDDHH24MISS');
    if (SQLCODE)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"GE_IMPUESOS",
                         szfnORAerror()) ;
        vDTrazasError(szExeName,"\n\t**  Error en SQL-OPEN CURSOR Cur_ConcDesc **"
                                "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return FALSE;
    }
	*/
    for (i=0; i<pAcumImptoTipo->iNumRegs;i++)
  {
      if (pAcumImptoTipo->stDetImptosTipo[i].lNumAbonado==lpNumAbonado &&
	      pAcumImptoTipo->stDetImptosTipo[i].iCodTipImpues==iCodTipImpues )
	  {
	     pAcumImptoTipo->stDetImptosTipo[i].dAcumImpuestoNCred=pAcumImptoTipo->stDetImptosTipo[i].dAcumImpuestoNCred + dpMontoImpt;
		 pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoNCred= 0;
		 pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoNCred=pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoNCred + dpMontoBase;
		 bExiste=TRUE;
		 exit;
	  }

  }
  return bExiste; 
}
BOOL bCargaAcumImptosNCredito (long lpNumFolio, char *spPrefPlaza, ACUMDETIMPTOSTIPO *pAcumImptoTipo)
{   char  modulo[] = "bCargaAcumImptosNCredito";
    int iNumReg=0;
	BOOL bRes=TRUE;
	//ACUMDETIMPTOSTIPO pAcumImptoTipo={0,(DETIMPTOSTIPO *)NULL};

    EXEC SQL BEGIN DECLARE SECTION;
        static long lhNumFolio;
	    static char shPrefPlaza[26]; EXEC SQL VAR shPrefPlaza IS STRING(26) ;
        static long lhCodCliente;
        static long lhNumAbonado;
        static int ihCodTipImpues;
        static double dhAcumImpuestoOrig;
        static double dhAcumNetoOrigen;
        static double dhAcumNetoAfecto;
        static double dhAcumImpuestoNCred;
        static double dhAcumNetoNCred;
        static double dhAcumNetoAfectoNCred;
    EXEC SQL END DECLARE SECTION   ;
 	
	lhNumFolio = lpNumFolio;
	strcpy(shPrefPlaza, spPrefPlaza);
	
    EXEC SQL DECLARE Cur_AcumImptos CURSOR FOR
            SELECT  NUM_FOLIO,PREF_PLAZA,COD_CLIENTE,NUM_ABONADO,COD_TIPIMPUES,
                    ACUM_IMPUESTO_ORIG,ACUM_NETO_ORIGEN,
					ACUM_NETO_AFECTO_ORIGEN,NVL(ACUM_IMPUESTO_NCRED,0),
					NVL(ACUM_NETO_NCRED,0),NVL(ACUM_NETO_AFECTO_NCRED,0)
            FROM FA_DETIMPTOSTIPO_TO
            WHERE  NUM_FOLIO = :lhNumFolio
            AND PREF_PLAZA = :shPrefPlaza
			ORDER BY COD_CLIENTE, NUM_ABONADO, COD_TIPIMPUES;
			
	EXEC SQL OPEN Cur_AcumImptos;
	
	if (SQLCODE != SQLOK)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Open->FA_DETIMPTOSTIPO_TO",
                   szfnORAerror());
        bRes = FALSE;
    }
    iNumReg = 0;
    while (bRes && SQLCODE == SQLOK)
    {
         EXEC SQL FETCH Cur_AcumImptos INTO :lhNumFolio,
			                                    :shPrefPlaza,
												:lhCodCliente,
												:lhNumAbonado,
												:ihCodTipImpues,
												:dhAcumImpuestoOrig,
												:dhAcumNetoOrigen,
												:dhAcumNetoAfecto,
												:dhAcumImpuestoNCred,
												:dhAcumNetoNCred,
												:dhAcumNetoAfectoNCred;
                                               
        if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
        {
             iDError (szExeName,ERR000,vInsertarIncidencia, "Fetch->Ge_Impuestos",szfnORAerror());
			 bRes = FALSE;
        }
		if (SQLCODE == SQLOK)
        {
             if ((pAcumImptoTipo->stDetImptosTipo =
                    (DETIMPTOSTIPO *)realloc( (DETIMPTOSTIPO *)pAcumImptoTipo->stDetImptosTipo,
                    (iNumReg+1)*sizeof(DETIMPTOSTIPO) ) ) == (DETIMPTOSTIPO *)NULL)
            {
                iDError (szExeName,ERR005,vInsertarIncidencia,"pAcumImptoTipo->stDetImptosTipo");
                strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria",
                                                       strlen(stAnomProceso.szObsAnomalia));
                bRes = FALSE;
            }
            else
            {
		        pAcumImptoTipo->stDetImptosTipo[iNumReg].lNumAbonado = lhNumAbonado;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].lCodCliente =lhCodCliente;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].lNumfolio =lhNumFolio;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].iCodTipImpues = ihCodTipImpues;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].dAcumImpuestoOrig = dhAcumImpuestoOrig;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].dAcumNetoOrigen = dhAcumNetoOrigen;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].dAcumNetoAfectoOrigen = dhAcumNetoAfecto;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].dAcumImpuestoNCred = dhAcumImpuestoNCred;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].dAcumNetoNCred = dhAcumNetoNCred;
				pAcumImptoTipo->stDetImptosTipo[iNumReg].dAcumNetoAfectoNCred = dhAcumNetoAfectoNCred;
				strcpy(pAcumImptoTipo->stDetImptosTipo[iNumReg].sPrefPlaza,shPrefPlaza);
				iNumReg++;
				pAcumImptoTipo->iNumRegs=iNumReg;
			}
 
        }
    }
	 EXEC SQL CLOSE Cur_AcumImptos;
    if (SQLCODE)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia
                            , "Close->Cur_AcumImptos",szfnORAerror());
        bRes = FALSE;
    }
    return bRes;	
}

BOOL bActualizAcumImptosNCredito ( ACUMDETIMPTOSTIPO *pAcumImptoTipo)
{   char  modulo[] = "bActualizAcumImptosNCredito";
    int iNumReg=0;
	int i;
	EXEC SQL BEGIN DECLARE SECTION;
	    static char shPrefPlaza[26]; EXEC SQL VAR shPrefPlaza IS STRING(26) ;
    EXEC SQL END DECLARE SECTION;
	vDTrazasLog (modulo, "\n\t\t* En funcion bActualizAcumImptosNCredito",  LOG03);
	
 	for (i=0;i<pAcumImptoTipo->iNumRegs;i++)
	{
	     vDTrazasLog (modulo, "\n\t\t* Actualizando registro en FA_DETIMPTOSTIP_TO (iteracion [%d])",  LOG05,i);
		 vDTrazasLog (modulo, "\n\t\t\t Valores actualizacion: ACUM_IMPUESTO_NCRED    : %f",  LOG05,pAcumImptoTipo->stDetImptosTipo[i].dAcumImpuestoNCred);
		 vDTrazasLog (modulo, "\n\t\t\t                        ACUM_NETO_NCRED        : %f",  LOG05,pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoNCred);
		 vDTrazasLog (modulo, "\n\t\t\t                        ACUM_NETO_AFECTO_NCRED : %f",  LOG05,pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoNCred);
		 vDTrazasLog (modulo, "\n\t\t\t Del registro : NUM_FOLIO     %d",  LOG05,pAcumImptoTipo->stDetImptosTipo[i].lNumfolio);
		 vDTrazasLog (modulo, "\n\t\t\t                PREF_PLAZA    %s",  LOG05,shPrefPlaza);
		 vDTrazasLog (modulo, "\n\t\t\t                COD_CLIENTE   %d",  LOG05,pAcumImptoTipo->stDetImptosTipo[i].lCodCliente);
		 vDTrazasLog (modulo, "\n\t\t\t                NUM_ABONADO   %d",  LOG05,pAcumImptoTipo->stDetImptosTipo[i].lNumAbonado);
		 vDTrazasLog (modulo, "\n\t\t\t                COD_TIPIMPUES %d",  LOG05,pAcumImptoTipo->stDetImptosTipo[i].iCodTipImpues);
		 
	     strcpy(shPrefPlaza, pAcumImptoTipo->stDetImptosTipo[i].sPrefPlaza);
		 
		 EXEC SQL UPDATE FA_DETIMPTOSTIPO_TO
		         SET  ACUM_IMPUESTO_NCRED = :pAcumImptoTipo->stDetImptosTipo[i].dAcumImpuestoNCred
					 ,ACUM_NETO_NCRED = :pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoNCred 
					 ,ACUM_NETO_AFECTO_NCRED = :pAcumImptoTipo->stDetImptosTipo[i].dAcumNetoAfectoNCred
				WHERE NUM_FOLIO = :pAcumImptoTipo->stDetImptosTipo[i].lNumfolio
				AND PREF_PLAZA = :shPrefPlaza
				AND COD_CLIENTE =:pAcumImptoTipo->stDetImptosTipo[i].lCodCliente
				AND NUM_ABONADO = :pAcumImptoTipo->stDetImptosTipo[i].lNumAbonado
				AND COD_TIPIMPUES =:pAcumImptoTipo->stDetImptosTipo[i].iCodTipImpues ;
	    if (SQLCODE != SQLOK)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,"Update->FA_DETIMPTOSTIPO_TO", szfnORAerror());
            return FALSE;
        }
	}
   
    return TRUE;	
}
BOOL bImptosNotasTotal (int iTipoFact , BOOL bDocOrigenCiclo,  ACUMDETIMPTOSTIPO *pAcumImptoTipo )
{
  char  modulo[] = "bImptosNotasTotal";
  char szNomTabla[50]="";
  static    char    szSql[8192]=""  ;
  int  iNumRegIni    = 0;
  int  i             = 0;
  long lIndOrdenTotal=0;
  long lNumAbonado=0;
  long lCodConcepto=0;
  long lColumna=0;
  int  iCodZonaImpos = 0;
  int  iCodZonaAbon  = 0;
  int  iCodGrpServi  = 0;

  static ENLACEHIST stEnlaceHist;
  EXEC SQL BEGIN DECLARE SECTION;
      static long lhNumAbonado;
	  static int  ihCodConcepto;
	  static int  ihCodTipImpuesto;
      static char   szhCodMoneda      [4];  EXEC SQL VAR szhCodMoneda      IS STRING(4) ;
      static int  ihCodTipConce;
      static double dhImpConcepto;
      static double dhImpMontoBase;
      static double dhImpFacturable;
      static char   szhDesConcepto   [61];  EXEC SQL VAR szhDesConcepto    IS STRING(61); 
	  	static char   szFecEmision[15]; EXEC SQL VAR szFecEmision IS STRING(15);
      static float fhPrcImpuesto ;

  EXEC SQL END DECLARE SECTION   ;
  
  IMPTOS   stImpto = {0,(IMPUESTOS *)NULL};
  char     szFecZonaImpo [15]=""          ;

    /* Acumula el total de los impuestos para el ajuste */
    TOTIMPTOS stTotImptos={0,(TOTIMPTO *)NULL};

    if (iTipoFact == FACT_NOTACRED)
        vDTrazasLog (szExeName,"\n\t\t* IMPUESTOS NOTA CREDITO\n"
                               "\t\t=> Cliente [%ld]\n",LOG04,
                               stCliente.lCodCliente);
    else if (iTipoFact == FACT_NOTADEBI)
        vDTrazasLog (szExeName,"\n\t\t* IMPUESTOS NOTA DEBITO \n"
                               "\t\t=> Cliente [%ld]\n",LOG04,
                               stCliente.lCodCliente);
    vDTrazasLog(szExeName, "\n\t\t* Categoria Impositiva del Cliente [%d]"
                         , LOG04,stCliente.iCodCatImpos);
 
    iNumRegIni = stPreFactura.iNumRegistros;
    if (bDocOrigenCiclo==TRUE)
    {   memset(&stEnlaceHist,0,sizeof(ENLACEHIST));
	    stEnlaceHist.lCodCiclFact = stNota.lCodCiclFact;
        if (!bGetEnlaceHist(&stEnlaceHist))
		    return FALSE;
        strcpy(szNomTabla,stEnlaceHist.szDetConceptos);
    }
    else
    {
        strcpy(szNomTabla,"FA_FACTCONC_NOCICLO");
    }

	iCodZonaImpos= stNota.iCodZonaImpo; //inc 
    for (i=0;i<iNumRegIni;i++)
    {
        if (stPreFactura.A_PFactura[i].iFlagImpues   == 1        &&
             stPreFactura.A_PFactura[i].iCodTipConce  != IMPUESTO && stPreFactura.A_PFactura[i].iCodTipConce  != DESCUENTO  &&
            stPreFactura.A_PFactura[i].iIndCuota     <= 0  )
        { 

			/* sprintf(szSql,  "SELECT DISTINCT NUM_ABONADO,  i.COD_TIPIMPUES,"
			                "COD_CONCEPTO, "
							"COD_MONEDA, "
                            "COD_TIPCONCE, " 
                            "IMP_CONCEPTO , " 
                            "IMP_MONTOBASE , "
                            "IMP_FACTURABLE , " 
                            "DES_CONCEPTO, "
                            "a.PRC_IMPUESTO "
                             "FROM (SELECT NUM_ABONADO, "
			                               "COD_CONCEPTO, "
			                               "COD_MONEDA, "
			                               "COD_TIPCONCE, " 
			                               "SUM( IMP_CONCEPTO   )IMP_CONCEPTO, " 
			                               "SUM( IMP_MONTOBASE) IMP_MONTOBASE, "
			                               "SUM(   IMP_FACTURABLE  ) IMP_FACTURABLE, " 
			                               "DES_CONCEPTO, "
			                               " PRC_IMPUESTO "							
			                        "FROM ( SELECT DISTINCT NUM_ABONADO, COD_CONCEPTO, COD_MONEDA, COD_TIPCONCE, IMP_CONCEPTO, IMP_MONTOBASE,"
                                                   "IMP_FACTURABLE, DES_CONCEPTO, PRC_IMPUESTO "
                                            "FROM %s " 
                                            "WHERE IND_ORDENTOTAL = :lIndOrdenTotal "
                                             "AND NUM_ABONADO = :lNumAbonado "
                                            "AND COD_TIPCONCE = 1 "
                                            "START WITH COD_CONCEPTO = :lCodConcepto "
                                            "AND COLUMNA=:iColumna "
                                            "CONNECT BY PRIOR COD_CONCEPTO = COD_CONCEREL  AND PRIOR COLUMNA = COLUMNA_REL) "
									"GROUP BY  NUM_ABONADO, COD_CONCEPTO, COD_MONEDA, COD_TIPCONCE, DES_CONCEPTO, PRC_IMPUESTO) a , GE_IMPUESTOS i "		
							"WHERE a.COD_CONCEPTO = i.COD_CONCGENE "
							"AND i.FEC_DESDE   <= TO_DATE (:szFecEmision,'YYYYMMDDHH24MISS') "
                            "AND i.FEC_HASTA   >= TO_DATE (:szFecEmision,'YYYYMMDDHH24MISS') " ,szNomTabla);
                */
			sprintf(szSql,  "SELECT NUM_ABONADO, COD_CONCEPTO, COD_MONEDA, COD_TIPCONCE, sum( IMP_CONCEPTO), sum(IMP_MONTOBASE) ,sum(IMP_FACTURABLE), DES_CONCEPTO, PRC_IMPUESTO"
                             " FROM (  SELECT  NUM_ABONADO, COD_CONCEPTO, COD_MONEDA, COD_TIPCONCE, IMP_CONCEPTO, IMP_MONTOBASE,IMP_FACTURABLE, DES_CONCEPTO, PRC_IMPUESTO"
                                     " FROM %s "
                                     " WHERE IND_ORDENTOTAL =:lIndOrdenTotal "
                                     " AND NUM_ABONADO =  :lNumAbonado "
                                     " AND COD_TIPCONCE = 1 "
                                     " AND COD_CONCEREL =  :lCodConcepto"
                                     " AND COLUMNA_REL = :iColumna "
									 " UNION ALL"
                                     " SELECT  b.NUM_ABONADO, b.COD_CONCEPTO, b.COD_MONEDA, b.COD_TIPCONCE, b.IMP_CONCEPTO, b.IMP_MONTOBASE,b.IMP_FACTURABLE, b.DES_CONCEPTO, b.PRC_IMPUESTO"
                                     " FROM %s a , %s b"
									 " WHERE a.IND_ORDENTOTAL =:lIndOrdenTotal_a "
                                     " AND a.IND_ORDENTOTAL = b.IND_ORDENTOTAL"
									 " AND a.NUM_ABONADO =  :lNumAbonado_a"
                                     " AND a.NUM_ABONADO = b.NUM_ABONADO "
                                     " AND a.COD_TIPCONCE = 2" 
									 " AND b.COD_TIPCONCE = 1" 
                                     " AND a.COD_CONCEREL = :lCodConcepto_a" 
                                     " AND b.cod_concerel = a.cod_concepto"
                                     " AND a.COLUMNA_REL =  :iColumna_a"
                                     " AND b.COLUMNA_REL = A.COLUMNA"
                                ") GROUP BY NUM_ABONADO, COD_CONCEPTO, COD_MONEDA, DES_CONCEPTO, PRC_IMPUESTO, COD_TIPCONCE" ,szNomTabla, szNomTabla, szNomTabla);
								
            vDTrazasLog (szExeName,"\n\t\t* bImptosIvaNotasTotal - PREPARE query:[%s] \n" ,LOG05, szSql);
            EXEC SQL PREPARE sql_detfact_not FROM :szSql;
            if (SQLCODE)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,"PREPARE sql_detfact_not",szfnORAerror ());
                vDTrazasError(szExeName,"\n\t**  Error en SQL-PREPARE sql_detfact_not **"
                                "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
                return  (FALSE);
            }
		
		    EXEC SQL DECLARE Cur_ConcDesc CURSOR FOR sql_detfact_not;
            if (SQLCODE)
            {
               iDError (szExeName,ERR000,vInsertarIncidencia,"DECLARE Cur_ConcDesc",szfnORAerror ());
               vDTrazasError(szExeName,"\n\t**  Error en SQL-DECLARE Cur_ConcDesc **"
                                "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
               return  (FALSE);
            }
            lIndOrdenTotal = atol( stNota.szIndOrdenTotal);
			lNumAbonado = stPreFactura.A_PFactura[i].lNumAbonado;
			lCodConcepto =stPreFactura.A_PFactura[i].iCodConcepto ;
			lColumna = stPreFactura.A_PFactura[i].lColumna;
			strcpy(szFecEmision,stNota.szFecEmision);
			vDTrazasLog (szExeName,"\n\t\t* bImptosIvaNotasTotal - OPEN query" 
			                       "\n\t\t* Ind. Orden Total [%d]" 
			                       "\n\t\t* Num. Abonado     [%d]" 
								   "\n\t\t* Cod. Concepto    [%d]" 
								   "\n\t\t* Columna    [%d]"
								   "\n\t\t* Fecha Emision    [%s]\n"  ,LOG05, lIndOrdenTotal, lNumAbonado, lCodConcepto,lColumna,szFecEmision);
            //EXEC SQL OPEN Cur_ConcDesc USING :lIndOrdenTotal ,:lNumAbonado, :lCodConcepto, :lColumna, :szFecEmision;
			EXEC SQL OPEN Cur_ConcDesc USING :lIndOrdenTotal ,:lNumAbonado, :lCodConcepto, :lColumna, :lIndOrdenTotal ,:lNumAbonado, :lCodConcepto, :lColumna;
            if (SQLCODE)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,"OPEN Cur_ConcDesc",szfnORAerror ());
                vDTrazasError(szExeName,"\n\t**  Error en SQL-OPEN CURSOR Cur_ConcDesc **"
                                "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
                return  (FALSE);
            }
			
			while (SQLCODE == SQLOK)
            {
                 EXEC SQL FETCH Cur_ConcDesc INTO :lhNumAbonado                  ,
				                                  :ihCodConcepto                 ,
                                                  :szhCodMoneda                  ,
                                                  :ihCodTipConce                 ,
                                                  :dhImpConcepto                 ,
                                                  :dhImpMontoBase                ,
                                                  :dhImpFacturable               ,
                                                  :szhDesConcepto                ,
                                                  :fhPrcImpuesto   ;

                if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
                {
                    iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=>Cur_ConcDesc", szfnORAerror ());
                }
				if (SQLCODE == SQLOK) 
				{    
				     /* if (!bfnAplicaImptoDoctoNotasCred(ihCodConcepto, szhDesConcepto,fhPrcImpuesto,dhImpConcepto,dhImpMontoBase, i ,iTipoFact, ihCodTipConce )) */
				     if (!bfnAplicaImptoDoctoNotasCred(ihCodConcepto, szhDesConcepto,fhPrcImpuesto,dhImpFacturable,dhImpMontoBase, i ,iTipoFact, ihCodTipConce ))  /* PGG -  3-01-2014 - 200287 - Usamos el Importe Facturable*/
				     {
				          vDTrazasError(modulo,"\n\t** ERROR, en creacion del concepto de Imptos Nota Credito Total **",LOG01);
 	                      return (FALSE);
				     }
					  //INC
					if (!bGetGrupoServicios (stPreFactura.A_PFactura[i].iCodConcepto,
                                     &iCodGrpServi,szFecEmision,iTipoFact))
                        return FALSE;

                    if (iCodGrpServi == ORA_NULL)
                    {
                        vDTrazasLog (modulo, "\n\t\t* Concepto [%d] NO tiene Grupo Servicios Asociado", LOG03,stPreFactura.A_PFactura[i].iCodConcepto);
                        return FALSE;
                    }
			        if (stPreFactura.A_PFactura[i].iCodZonaAbon == -1)
                       iCodZonaAbon = iCodZonaImpos;
                    else
                       /* Se considera para los conceptos con abonado 0 la zona impositiva del Cliente. */
                       /* iCodZonaAbon = stPreFactura.A_PFactura.iCodZonaAbon[i]; */
                       if (stPreFactura.A_PFactura[i].lNumAbonado  == 0 && stPreFactura.A_PFactura[i].iCodZonaAbon == 0)
                          iCodZonaAbon = iCodZonaImpos;
                      else
                         iCodZonaAbon = stPreFactura.A_PFactura[i].iCodZonaAbon;
			       //fin inc
		            vDTrazasLog (szExeName,"\n\t\t* bImptosIvaNotasTotal - OPEN GE_IMPUESTOS" 
			                       "\n\t\t* Cod Cat. Impos [%d]" 
								   "\n\t\t* Zona Impos     [%d]"
                                   "\n\t\t* Zona Abon      [%d]"  								   
								   "\n\t\t* Grp Servicio   [%d]"
								   "\n\t\t* Cod Concepto   [%d]"
								   "\n\t\t* Fecha Emision    [%s]\n"  ,LOG05, stNota.iCodCatImpos, iCodZonaImpos, iCodZonaAbon,iCodGrpServi,ihCodConcepto,szFecEmision);
	                EXEC SQL SELECT I.COD_TIPIMPUES
	                INTO ihCodTipImpuesto
                    FROM   GE_IMPUESTOS I
                    WHERE  I.COD_CATIMPOS = :stNota.iCodCatImpos
                    AND  I.COD_ZONAIMPO = :iCodZonaImpos
                    AND I.COD_ZONAABON = :iCodZonaAbon
                    AND I.COD_GRPSERVI = :iCodGrpServi
					AND I.COD_CONCGENE = :ihCodConcepto
                    AND  I.FEC_DESDE   <= TO_DATE (:szFecEmision,'YYYYMMDDHH24MISS')
                    AND  I.FEC_HASTA   >= TO_DATE (:szFecEmision,'YYYYMMDDHH24MISS');
                    if (SQLCODE)
                    {
                        iDError (szExeName,ERR000,vInsertarIncidencia,"GE_IMPUESOS",
                         szfnORAerror()) ;
                       vDTrazasError(szExeName,"\n\t**  Error en GE_IMPUESTOS **"
                                        "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
                       return FALSE;
                    }
					 if (!bfnTotalizaImptoNCred(ihCodTipImpuesto,lhNumAbonado, dhImpConcepto, dhImpMontoBase, iTipoFact, pAcumImptoTipo))
					 {
				          vDTrazasError(modulo,"\n\t** ERROR, acumular impuestos por tipo **",LOG01);
 	                      return (FALSE);
					 }
				}
           }
	}
    }

    
    return TRUE;
}
BOOL bImptosNotasCredParcial (int iTipoFact,ACUMDETIMPTOSTIPO  *pAcumImptoTipo)
{
char  modulo[] = "bImptosNotasCredParcial";

  int  iNumRegIni    = 0;
  int  iInd          = 0;
  int  i             = 0;
  int  iNumConceptos = 0;
  int  iNImptos      = 0;
  int  iCodZonaImpos = 0;
  int  iCodZonaAbon  = 0;
  int  iCodGrpServi  = 0;
  int x = 0;
  
  IMPTOS   stImpto = {0,(IMPUESTOS *)NULL};
  ACUMABONADOS stAcumFactAbonado={0,(ACUMABONADO *)NULL};  
  ACUMIMPUESTOABONADOS   stImptoAcum  = {0,(ACUMIMPUESTO *)NULL};
  char     szFecZonaImpo [15]=""          ;

    /* Acumula el total de los impuestos para el ajuste */
    TOTIMPTOS stTotImptos={0,(TOTIMPTO *)NULL};
    
	vDTrazasLog (szExeName,"\n\t\t* En funcion %s\n",LOG02, modulo);
	
    if (iTipoFact == FACT_NOTACRED)
        vDTrazasLog (szExeName,"\n\t\t* IMPUESTOS NOTA CREDITO\n"
                               "\t\t=> Cliente [%ld]\n",LOG04,
                               stCliente.lCodCliente);
    else if (iTipoFact == FACT_NOTADEBI)
        vDTrazasLog (szExeName,"\n\t\t* IMPUESTOS NOTA DEBITO \n"
                               "\t\t=> Cliente [%ld]\n",LOG04,
                               stCliente.lCodCliente);
    vDTrazasLog(szExeName, "\n\t\t* Categoria Impositiva del Cliente [%d]"
                         , LOG04,stCliente.iCodCatImpos);

    /* Obtiene parametro de minimo ajustable */

    strcpy (szFecZonaImpo,stNota.szFecEmision);
    iCodZonaImpos= stNota.iCodZonaImpo;
    stPreFactura.iCodZonaImpo=iCodZonaImpos;

    vDTrazasLog (modulo,  "\t\t* Zona Impositiva [%d] "
                        "\n\t\t* Fecha Zona Impositiva [%s] "
                        ,LOG06, iCodZonaImpos, szFecZonaImpo);

    iNumRegIni = stPreFactura.iNumRegistros;

    for (i=0;i<iNumRegIni;i++)
    {
        if (stPreFactura.A_PFactura[i].iFlagImpues   == 1        &&
            stPreFactura.A_PFactura[i].iCodTipConce  != IMPUESTO &&
            stPreFactura.A_PFactura[i].iIndCuota     <= 0 )
        {

            if (!bGetGrupoServicios (stPreFactura.A_PFactura[i].iCodConcepto,
                                     &iCodGrpServi,szFecZonaImpo,iTipoFact))
                return FALSE;

            if (iCodGrpServi == ORA_NULL)
            {
                vDTrazasLog (modulo,
                      "\n\t\t* Concepto [%d] NO tiene Grupo Servicios Asociado",
                      LOG03,stPreFactura.A_PFactura[i].iCodConcepto);
                return FALSE;
            }

            if (stPreFactura.A_PFactura[i].iCodZonaAbon == -1)
                iCodZonaAbon = iCodZonaImpos;
            else
                /* Se considera para los conceptos con abonado 0 la zona impositiva del Cliente. */
                /* iCodZonaAbon = stPreFactura.A_PFactura.iCodZonaAbon[i]; */
                if (stPreFactura.A_PFactura[i].lNumAbonado  == 0 && stPreFactura.A_PFactura[i].iCodZonaAbon == 0)
                   iCodZonaAbon = iCodZonaImpos;
                else
                    iCodZonaAbon = stPreFactura.A_PFactura[i].iCodZonaAbon;

            vDTrazasLog (modulo, "\n\t\t* Cod.ZonaAbon [%i]\n",LOG06, iCodZonaAbon);

            if (!bGetImpuestosAll (stCliente.iCodCatImpos, iCodZonaImpos, szFecZonaImpo,iCodZonaAbon, iCodGrpServi,
                            &stImpto, iTipoFact))
            {
                vFreeImpuestos(&stImpto);
                return FALSE;
            }
            vDTrazasLog (modulo,"\n\t\t* Grupo Servicios [%d]"
                                "\n\t\t* Numero de Impuestos = [%d]",LOG06
                                ,iCodGrpServi,stImpto.iNumImpuestos);

            for (iInd=0;iInd<stImpto.iNumImpuestos;iInd++)
            {
			     vDTrazasLog (modulo,"\n\t\t* Procesando concepto impuesto [%d] itereacion [%i]",LOG05, stImpto.pImpuestos[iInd].iCodConcGene, iInd);
				 
				iNumConceptos = stPreFactura.iNumRegistros;
				
				vDTrazasLog (modulo,"\n\t\t* Impuesto con Umbral [%f] y Monto Maximo [%f]",LOG05,stImpto.pImpuestos[iInd].dImpUmbral , stImpto.pImpuestos[iInd].dImpMaximo );
				if (stImpto.pImpuestos[iInd].dImpUmbral  == 0 || stImpto.pImpuestos[iInd].dImpMaximo == 0) {
				   if (!bfnAplicaImpto(i, &stImpto.pImpuestos[iInd], iTipoFact))
                   {
                       vFreeImpuestos(&stImpto);
                       vDTrazasError(modulo,"\n\t** ERROR, en cracion del concepto de Impto. **",LOG01);
                       return (FALSE);
                   }
                   if (!bCalculaImptos (i,&stImpto.pImpuestos[iInd], iNumConceptos))
                   {
                       vFreeImpuestos(&stImpto);
                       return FALSE;
                   }

				   for (x=0 ; x< pAcumImptoTipo->iNumRegs;x++)
				   {
	                   if (stPreFactura.A_PFactura[i].lNumAbonado == pAcumImptoTipo->stDetImptosTipo[x].lNumAbonado &&
	                      pAcumImptoTipo->stDetImptosTipo[x].iCodTipImpues == stImpto.pImpuestos[iInd].iCodTipImpues)
	                  {
					        pAcumImptoTipo->stDetImptosTipo[x].dAcumImpuestoNCred += stPreFactura.A_PFactura[iNumConceptos].dImpConcepto ;
	                        pAcumImptoTipo->stDetImptosTipo[x].dAcumNetoAfectoNCred += stPreFactura.A_PFactura[iNumConceptos].dImpFacturable ;
							pAcumImptoTipo->stDetImptosTipo[x].dAcumNetoNCred +=  stPreFactura.A_PFactura[iNumConceptos].dImpFacturable;
							break;
		        	  }
				    }
	    		}
                else
				{
				    if (!bfnAplicaImptoUmbralNotaCredParcial(i,stPreFactura.A_PFactura[i].dImpConcepto,
					                                         stPreFactura.A_PFactura[i].szCodMoneda, 
															 stPreFactura.A_PFactura[i].lNumAbonado,
															 iTipoFact,
															 &stImptoAcum,
															 &stAcumFactAbonado.stAcumAbonado[0],
										                     &stImpto.pImpuestos[iInd], 
															 pAcumImptoTipo))
                    {  vFreeAcumImpuestoAbonado(&stImptoAcum);
					  vFreeAcumAbonado(&stAcumFactAbonado);
                       return FALSE;					
					}
				}
                strcpy(stPreFactura.A_PFactura[iNumConceptos].szFecEfectividad,
                       stPreFactura.A_PFactura[i].szFecValor );

               // iNImptos++                  ;
            }/* fin for->iInd */
        } /* fin if Condiciones ... */

       // vDTrazasLog (modulo,"\n\t\t[%d]Impuestos aplicados al concepto [%d] del cliente [%ld]\n",
       //             LOG06,iNImptos,stPreFactura.A_PFactura[i].iCodConcepto, stPreFactura.A_PFactura[i].lCodCliente );
        vFreeImpuestos(&stImpto);
        iNImptosT += iNImptos;

    }/* fin for i<iNumRegIni */
	
/******************************************************/
/* Codigo para guardar Zona Impositiva del Abonado     */
/******************************************************/
    if(stPreFactura.iNumRegistros > 0)
    {
        if (!bfnRegZonaAbon(iNumRegIni))
        {
            vDTrazasError(modulo,"\n\t**  Error en proceso bfnRegZonaAbon **",LOG01);
            return (FALSE);
        }
    }
 
    vDTrazasLog (szExeName,"\n\t\t* Cliente [%ld] => Impuestos Aplicados [%d]\n",
               LOG03,stCliente.lCodCliente,iNImptosT);
    vFreeTotImpuestos(&stTotImptos);
	vFreeAcumImpuestoAbonado(&stImptoAcum);
    return TRUE;
}
/*****************************************************************************/
/*                             funcion : bImptosIvaNotas                     */
/* -Funcion que Aplica Impuestos (recogidos en la tabla Fa_HistConc que son  */
/*  en este caso los conceptos Impuestos que se aplicaron a los Conceptos de */
/*  la factura modificada por la Nota que Emitimos. Todos estos Conceptos Im-*/
/*  puestos estan recogidos en la estructura stNota.A_HistConc y los Concep- */
/*  tos sobre los que se aplican se recogen en stPreFactura.A_PFactura.      */
/* -Observacion :                                                            */
/*            * Dos formas de Aplicar Impuestos :                            */
/*              1.- Apartir del fPrcImpuesto de stNota.A_HistConc            */
/*              2.- Apartir de la Categoria Impositiva del Cliente           */
/*            * Hay que tener en cuenta que el Concepto no sea una Cuota a la*/
/*              cual no se le aplican Impuestos, y ademas que el Concepto so-*/
/*              bre el cual se aplica el Impuesto, en el momento de generar  */
/*              la factura que se modifica con la nota se le aplicaron im-   */
/*              puesto (esto viene indicado por el Campo FlagImpuesto = 1).  */
/*                                                                           */
/* -Valores Retorno : Error->FALSE, !Error->TRUE                             */
/*****************************************************************************/
BOOL bImptosIvaNotas (int iTipoFact)
{
char  modulo[] = "bImptosIvaNotas";

  int  iNumRegIni    = 0;
  int  iInd          = 0;
  int  i             = 0;
  int  iNumConceptos = 0;
  int  iNImptos      = 0;
  int  iCodZonaImpos = 0;
  int  iCodZonaAbon  = 0;
  int  iCodGrpServi  = 0;

  IMPTOS   stImpto = {0,(IMPUESTOS *)NULL};
  char     szFecZonaImpo [15]=""          ;

    /* Acumula el total de los impuestos para el ajuste */
    TOTIMPTOS stTotImptos={0,(TOTIMPTO *)NULL};

    if (iTipoFact == FACT_NOTACRED)
        vDTrazasLog (szExeName,"\n\t\t* IMPUESTOS NOTA CREDITO\n"
                               "\t\t=> Cliente [%ld]\n",LOG04,
                               stCliente.lCodCliente);
    else if (iTipoFact == FACT_NOTADEBI)
        vDTrazasLog (szExeName,"\n\t\t* IMPUESTOS NOTA DEBITO \n"
                               "\t\t=> Cliente [%ld]\n",LOG04,
                               stCliente.lCodCliente);
    vDTrazasLog(szExeName, "\n\t\t* Categoria Impositiva del Cliente [%d]"
                         , LOG04,stCliente.iCodCatImpos);

    /* Obtiene parametro de minimo ajustable */

    strcpy (szFecZonaImpo,stNota.szFecEmision);
    iCodZonaImpos= stNota.iCodZonaImpo;
    stPreFactura.iCodZonaImpo=iCodZonaImpos;

    vDTrazasLog (modulo,  "\t\t* Zona Impositiva [%d] "
                        "\n\t\t* Fecha Zona Impositiva [%s] "
                        ,LOG06, iCodZonaImpos, szFecZonaImpo);

    iNumRegIni = stPreFactura.iNumRegistros;

    for (i=0;i<iNumRegIni;i++)
    {
        if (stPreFactura.A_PFactura[i].iFlagImpues   == 1        &&
            stPreFactura.A_PFactura[i].iCodTipConce  != IMPUESTO &&
            stPreFactura.A_PFactura[i].iIndCuota     <= 0 )
        {

            if (!bGetGrupoServicios (stPreFactura.A_PFactura[i].iCodConcepto,
                                     &iCodGrpServi,szFecZonaImpo,iTipoFact))
                return FALSE;

            if (iCodGrpServi == ORA_NULL)
            {
                vDTrazasLog (modulo,
                      "\n\t\t* Concepto [%d] NO tiene Grupo Servicios Asociado",
                      LOG03,stPreFactura.A_PFactura[i].iCodConcepto);
                return FALSE;
            }

            if (stPreFactura.A_PFactura[i].iCodZonaAbon == -1)
                iCodZonaAbon = iCodZonaImpos;
            else
                /* Se considera para los conceptos con abonado 0 la zona impositiva del Cliente. */
                /* iCodZonaAbon = stPreFactura.A_PFactura.iCodZonaAbon[i]; */
                if (stPreFactura.A_PFactura[i].lNumAbonado  == 0 && stPreFactura.A_PFactura[i].iCodZonaAbon == 0)
                   iCodZonaAbon = iCodZonaImpos;
                else
                    iCodZonaAbon = stPreFactura.A_PFactura[i].iCodZonaAbon;

            vDTrazasLog (modulo, "\n\t\t* Cod.ZonaAbon [%i]\n",LOG06, iCodZonaAbon);

            if (!bGetImpuestos (stCliente.iCodCatImpos, iCodZonaImpos,iCodZonaAbon, iCodGrpServi,
                            szFecZonaImpo,&stImpto, iTipoFact))
            {
                vFreeImpuestos(&stImpto);
                return FALSE;
            }
            vDTrazasLog (modulo,"\n\t\t* Grupo Servicios [%d]"
                                "\n\t\t* Numero de Impuestos = [%d]",LOG06
                                ,iCodGrpServi,stImpto.iNumImpuestos);

            for (iInd=0;iInd<stImpto.iNumImpuestos;iInd++)
            {
                iNumConceptos = stPreFactura.iNumRegistros;

                if (!bfnAplicaImpto(i, &stImpto.pImpuestos[iInd], iTipoFact))
                {
                    vFreeImpuestos(&stImpto);
                    vDTrazasError(modulo,"\n\t** ERROR, en cracion del concepto de Impto. **",LOG01);
                    return (FALSE);
                }

                if (!bCalculaImptos (i,&stImpto.pImpuestos[iInd], iNumConceptos))
                {
                     vFreeImpuestos(&stImpto);
                     return FALSE;
                }

                strcpy(stPreFactura.A_PFactura[iNumConceptos].szFecEfectividad,
                       stPreFactura.A_PFactura[i].szFecValor );

                if (!bfnAcumTotImptos (&stTotImptos
                            ,stPreFactura.A_PFactura[i].iCodConcepto
                            ,stPreFactura.A_PFactura[iNumConceptos].iCodConcepto
                            ,stPreFactura.A_PFactura[i].dImpFacturable
                            ,stPreFactura.A_PFactura[iNumConceptos].dImpFacturable
                            ,stPreFactura.A_PFactura[iNumConceptos].fPrcImpuesto
                            ,stImpto.pImpuestos[iInd].iTipMonto))
                {
                    vDTrazasError(modulo,"\n\t**  Error en acumulacion de Impuestos **",LOG01);
                    vFreeImpuestos(&stImpto);
                    vFreeTotImpuestos(&stTotImptos);
                    return (FALSE);
                }
                iNImptos++                  ;
            }/* fin for->iInd */
        } /* fin if Condiciones ... */

        vDTrazasLog (modulo,"\n\t\t[%d]Impuestos aplicados al concepto [%d] del cliente [%ld]\n",
                    LOG06,iNImptos,stPreFactura.A_PFactura[i].iCodConcepto, stPreFactura.A_PFactura[i].lCodCliente );
        vFreeImpuestos(&stImpto);
        iNImptosT += iNImptos;

    }/* fin for i<iNumRegIni */
/******************************************************/
/* Codigo para guardar Zona Impositiva del Abonado     */
/******************************************************/
    if(stPreFactura.iNumRegistros > 0)
    {
        if (!bfnRegZonaAbon(iNumRegIni))
        {
            vDTrazasError(modulo,"\n\t**  Error en proceso bfnRegZonaAbon **",LOG01);
            return (FALSE);
        }
    }
/******************************************************/
/******************************************************/
/* Codigo para realizacion de ajuste de IVA.          */
/******************************************************/
    if(stPreFactura.iNumRegistros > 0)
    {
        if (!bfnAjusteImptos(&stTotImptos))
        {
            vDTrazasError(modulo,"\n\t**  Error en proceso de Ajuste de Impuestos **",LOG01);
            vFreeTotImpuestos(&stTotImptos);
            return (FALSE);
        }
    }
/******************************************************/

/******************************************************/
/* Aplicacion de impuesto al documento Maicao         */
/******************************************************/
    if (pstImptoDctos.iNumImptosDctos)
    {
        if (!bfnProcImptoMaicao (iTipoFact, szFecZonaImpo))
        {
            vDTrazasError(modulo,"\n\t** Error Aplicacion de Impuesto Maicao. **",LOG01);
            vFreeTotImpuestos(&stTotImptos);
            return (FALSE);
        }
    }

/******************************************************/
/* Aplicacion de impuesto al documento Maicao         */
/******************************************************/
    if (pstFadParam.iCodTipImptoDocto)
    {
	/* JHJ Se hace modificacion de codigo  y se cambia por if (!bImptosDocto (iTipoFact, stNota.szFecEmision, stNota.iCodZonaImpo))desde aqui
        Beta por Incidencia 180153 03-02-2012 JHJ.
		solicitaron eliminar el impuesto a la cruz roja
		segun audio con Negretti se pide lo siguiente :
		Se debe eliminar la logica de calculo de impuesto de la cruz roja de la funcionalidad de facturación de las notas de crédito
		if (!bImptosDoctoNotas (iTipoFact))  
		{      
            vDTrazasError(modulo,"\n\t** Error Aplicacion de Impuestos Documentos por rangos. **",LOG01);
            vFreeTotImpuestos(&stTotImptos);
            return (FALSE);
        }hasta acà JHJ*/
		
		if (!bImptosDocto (iTipoFact, stNota.szFecEmision, stNota.iCodZonaImpo ))
        {
            vDTrazasError(modulo,"\n\t** Error Aplicacion de Impuestos Documentos con rangos **",LOG01);
            vFreeTotImpuestos(&stTotImptos);
            return (FALSE);
        }
    }
    vDTrazasLog (szExeName,"\n\t\t* Cliente [%ld] => Impuestos Aplicados [%d]\n",
               LOG03,stCliente.lCodCliente,iNImptosT);
    vFreeTotImpuestos(&stTotImptos);
    return TRUE;
}/**************************** Final bImptosIvaNotas *************************/


/*****************************************************************************/
/*                          funcion : bGetZonaImpositiva                     */
/* -Busca la Zona Impositiva (iCodZonaimpo) en memoria (ZONACIUDAD *),que es */
/*  cargada en el modulo con los reg. de la tabla GE_ZONACIUDAD              */
/* -Entrada szCodMunicipio, piCodZonaimpo, szFecZonaimpo                     */
/* -Salida Error->FALSE, !Error->TRUE                                        */
/*****************************************************************************/
BOOL bGetZonaImpositiva ( char *szCodRegion   ,
                          char *szCodProvincia,
                          char *szCodCiudad   ,
                          int  *piCodZonaImpo ,
                          char *szFecZonaImpo ,
                          int  iTipoFact)
{
    ZONACIUDAD stZonaCiudad;
    BOOL bRes = TRUE       ;

    EXEC SQL BEGIN DECLARE SECTION;
         static char  szhCodRegion    [4]; EXEC SQL VAR szhCodRegion    IS STRING(4) ;
         static char  szhCodProvincia [6]; EXEC SQL VAR szhCodProvincia IS STRING(6) ;
         static char  szhCodCiudad    [6]; EXEC SQL VAR szhCodCiudad    IS STRING(6) ;
         static int    ihCodZonaImpo  ;
   EXEC SQL END DECLARE SECTION  ;

   memset (&stZonaCiudad,0,sizeof(ZONACIUDAD));

   vDTrazasLog (szExeName, "\n\t\t* Parametros Entrada bGetZonaImpositiva\n"
                           "\t\t=>Cod.Region   [%s]\n"
                           "\t\t=>Cod.Provincia[%s]\n"
                           "\t\t=>Cod.Ciudad   [%s]\n"
                           "\t\t=>Fecha        [%s]\n"
                         , LOG05,szCodRegion,szCodProvincia,szCodCiudad,szFecZonaImpo);

   if (iTipoFact == FACT_CICLO)
   {
       strcpy (stZonaCiudad.szCodRegion   ,szCodRegion)   ;
       strcpy (stZonaCiudad.szCodProvincia,szCodProvincia);
       strcpy (stZonaCiudad.szCodCiudad   ,szCodCiudad)   ;

       if (!bFindZonaCiudad (szCodRegion,szCodProvincia,
                             szCodCiudad,szFecZonaImpo,piCodZonaImpo))
       {
            /* Si no lo encontramos en memoria buscamos en tabla */
            EXEC SQL SELECT /*+ index (GE_ZONACIUDAD PK_GE_ZONACIUDAD) */
                            COD_ZONAIMPO
                     INTO   :ihCodZonaImpo
                     FROM   GE_ZONACIUDAD
                     WHERE  COD_REGION    = :szCodRegion
                       AND  COD_PROVINCIA = :szCodProvincia
                       AND  COD_CIUDAD    = :szCodCiudad
                       AND  FEC_DESDE    <= TO_DATE(:szFecZonaImpo,'YYYYMMDDHH24MISS')
                       AND  FEC_HASTA    >= TO_DATE(:szFecZonaImpo,'YYYYMMDDHH24MISS');
                       
            if (SQLCODE)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,"Ge_ZonaCiudad",
                         szfnORAerror())               ;
                strncpy (stAnomProceso.szObsAnomalia,
                         "No se encontraron Datos en"\
                         " Ge_ZonaCiudad ",sizeof(stAnomProceso.szObsAnomalia));
                bRes = FALSE;
            }
            else
            {
                strcpy (stZonaCiudad.szCodRegion    ,szhCodRegion   );
                strcpy (stZonaCiudad.szCodProvincia ,szhCodProvincia);
                strcpy (stZonaCiudad.szCodCiudad    ,szhCodCiudad   );

                *piCodZonaImpo = ihCodZonaImpo           ;
                stZonaCiudad.iCodZonaImpo = ihCodZonaImpo;

                if (!bAddZonaCiudad (&stZonaCiudad))
                     bRes = FALSE;
            }
        }
    }
    else
    {
        EXEC SQL SELECT /*+ index (GE_ZONACIUDAD PK_GE_ZONACIUDAD) */
                        COD_ZONAIMPO
                   INTO :ihCodZonaImpo
                   FROM GE_ZONACIUDAD
                  WHERE COD_REGION    = :szCodRegion
                    AND COD_PROVINCIA = :szCodProvincia
                    AND COD_CIUDAD    = :szCodCiudad
                    AND FEC_DESDE <=TO_DATE(:szFecZonaImpo,'YYYYMMDDHH24MISS')
                    AND FEC_HASTA >=TO_DATE(:szFecZonaImpo,'YYYYMMDDHH24MISS');
        if (SQLCODE)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia,"Ge_ZonaCiudad",
                     szfnORAerror())               ;
            strncpy (stAnomProceso.szObsAnomalia,
                         "No se encontraron Datos en"\
                         " Ge_ZonaCiudad ",sizeof(stAnomProceso.szObsAnomalia));
            bRes = FALSE;
        }
        else
        {
            *piCodZonaImpo = ihCodZonaImpo;
        }
   }
   return (bRes);
}/************************** Final bGetZonaImpositiva ************************/

/*****************************************************************************/
/*                           funcion : bAddZonaCiudad                        */
/* -Funcion que inserta en memoria (ZONACIUDAD* pstZonaCiudad)reg. y aumenta */
/*  en uno el numero de reg. cargados de GE_ZONACIUDAD en (NUM_ZONACIUDAD+1) */
/*  ambos datos son globales al modulo                                       */
/* -Salida Error->FALSE, !Error->TRUE                                        */
/*****************************************************************************/
static BOOL bAddZonaCiudad (ZONACIUDAD* pZona)
{
  BOOL bRes = TRUE;

  if (NUM_ZONACIUDAD >= MAX_ZONACIUDAD)
  {
      vDTrazasLog (szExeName,"\n\t*** Imposible Anadir reg. en pstZonaCiudad"\
                   "=>Desbordamiento (Dimension Actual %d) ***",LOG01,
                   MAX_ZONACIUDAD);
      bRes = FALSE;
  }
  else
  {
      pstZonaCiudad[NUM_ZONACIUDAD].iCodZonaImpo = pZona->iCodZonaImpo      ;

      strcpy (pstZonaCiudad [NUM_ZONACIUDAD].szCodRegion,pZona->szCodRegion);
      strcpy (pstZonaCiudad [NUM_ZONACIUDAD].szCodProvincia,
                                                      pZona->szCodProvincia);
      strcpy (pstZonaCiudad [NUM_ZONACIUDAD].szCodCiudad,pZona->szCodCiudad);
      strcpy (pstZonaCiudad [NUM_ZONACIUDAD].szFecDesde, pZona->szFecDesde) ;
      strcpy (pstZonaCiudad [NUM_ZONACIUDAD].szFecHasta, pZona->szFecHasta) ;

      NUM_ZONACIUDAD += 1;
            
      qsort (pstZonaCiudad,sizeof(ZONACIUDAD),NUM_ZONACIUDAD,iCmpZonaCiudad); 

  }
  return (bRes);

}/************************* Final bAddZonaCiudad *****************************/


/*****************************************************************************/
/*                          funcion : bGetGrupoServicios                     */
/* -Funcion que devuelve el Grupo de Servicios (iCodGrpServi), a partir del  */
/*  concepto (long iCodConcepto) y la Fecha (szFecGrp)                       */
/* -Salida Error->FALSE, !Error->TRUE                                        */
/*****************************************************************************/
static BOOL bGetGrupoServicios (int iCodConcepto,
                                int* piCodGrpServi,char *szFecGrp,
                                int  iTipoFact)
{
  GRPSERCONC stGrpSerConc;
  BOOL       bRes = TRUE ;

  EXEC SQL BEGIN DECLARE SECTION;
  static int    ihCodConcepto;
  static char*  szhSysDate   ; EXEC SQL VAR szhSysDate    IS STRING(15);
  static int    ihCodGrpServi;
  EXEC SQL END DECLARE SECTION  ;

    szhSysDate    = szFecGrp    ;
    ihCodConcepto = iCodConcepto;

    vDTrazasLog (szExeName, "\n\t\t* Parametros Entrada Grupo Servicios\n"
                            "\t\t=> Cod.Concepto  [%d]\n"
                            "\t\t=> Tipo Factura  [%d]\n"
                            "\t\t=> Fecha         [%s]\n",LOG05,
                            iCodConcepto,iTipoFact,szFecGrp);
    if (iTipoFact == FACT_CICLO)
    {
        if (!bFindGrpSerConc (iCodConcepto,&stGrpSerConc))
        {
            /* No se encuentran en memoria se buscan en la tabla */
            EXEC SQL SELECT /*+ index (FA_GRPSERCONC PK_FA_GRPSERCONC) */
                            COD_GRPSERVI                            
                     INTO   :ihCodGrpServi                            
                     FROM   FA_GRPSERCONC
                     WHERE  COD_CONCEPTO = :ihCodConcepto
                       AND  FEC_DESDE <=TO_DATE (:szhSysDate,'YYYYMMDDHH24MISS')
                       AND  FEC_HASTA >=TO_DATE (:szhSysDate,'YYYYMMDDHH24MISS');

            if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
            {
                iDError (szExeName,ERR000,vInsertarIncidencia,
                                "Select->Fa_GrpSerConc",szfnORAerror());
                bRes = FALSE;
            }
            else
            {
                if (SQLCODE == SQLOK)
                {
                    stGrpSerConc.iCodConcepto = ihCodConcepto;
                    stGrpSerConc.iCodGrpServi = ihCodGrpServi;

                    if (!bAddGrpSerConc (&stGrpSerConc))
                        bRes = FALSE;
                }
                else
                {
                    stGrpSerConc.iCodGrpServi = ORA_NULL;
                    iDError (szExeName,ERR000,vInsertarIncidencia,"Select->Fa_GrpSerConc",szfnORAerror());
                    bRes = FALSE;
                }
            }
        }
    }
    else
    {
        EXEC SQL SELECT /*+ index (FA_GRPSERCONC PK_FA_GRPSERCONC) */
                        COD_GRPSERVI
                   INTO :ihCodGrpServi
                   FROM FA_GRPSERCONC
                  WHERE COD_CONCEPTO = :ihCodConcepto
                    AND FEC_DESDE <=TO_DATE (:szhSysDate,'YYYYMMDDHH24MISS')
                    AND FEC_HASTA >=TO_DATE (:szhSysDate,'YYYYMMDDHH24MISS');

        if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
        {
            iDError (szExeName,ERR000,vInsertarIncidencia
                                     ,"Select->Fa_GrpSerConc",szfnORAerror());
            bRes = FALSE;
        }
        stGrpSerConc.iCodGrpServi = ihCodGrpServi;
    }
    if (bRes)
        *piCodGrpServi = stGrpSerConc.iCodGrpServi;
    else
        *piCodGrpServi = ORA_NULL                 ;

    return (bRes);

}/************************ Final bGetGrupoServicios **************************/

/*****************************************************************************/
/*                         funcion : bAddGrpSerConc                          */
/* -Entrada es un reg. de la tabla FA_GRPSERCONC que introducimos en memoria */
/*  en una estructura global (GRPSERCONC* pstGrpSerConc) y aumentamos el con-*/
/*  tador de reg. (NUM_GRPSERCONC) global al modulo.                         */
/* -Salida Error->FALSE, !Error->TRUE                                        */
/*****************************************************************************/
static BOOL bAddGrpSerConc (GRPSERCONC *pGrp)
{
  BOOL bRes = TRUE;

  if (NUM_GRPSERCONC >= MAX_GRPSERCONC)
  {
      vDTrazasLog (szExeName,"\n\t*** Imposible Anadir reg. en pstGrpSerConc"\
                   "=>Desbordamiento (Dimension Actual %d) ***",LOG01,
                   MAX_GRPSERCONC);
      bRes = FALSE;
  }
  else
  {
      pstGrpSerConc [NUM_GRPSERCONC].iCodConcepto = pGrp->iCodConcepto    ;
      pstGrpSerConc [NUM_GRPSERCONC].iCodGrpServi = pGrp->iCodGrpServi    ;

      strcpy (pstGrpSerConc [NUM_GRPSERCONC].szFecDesde, pGrp->szFecDesde);
      strcpy (pstGrpSerConc [NUM_GRPSERCONC].szFecHasta, pGrp->szFecHasta);

      NUM_GRPSERCONC += 1;
            
      qsort (pstGrpSerConc,NUM_GRPSERCONC,sizeof(GRPSERCONC),iCmpGrpSerConc);      
  }
  return (bRes);
}/************************ Final bAddGrpSerConc ******************************/



/*****************************************************************************/
/*                         funcion : bCalculaImptos                          */
/* -Funcion que Calcula el Impuesto Aplicado a un Conceptos cargado en la es-*/
/*  tructura stPreFactura.A_PFactura.%[iInd], donde iInd el orden del regis- */
/*  al cual se le aplica el Impuesto.                                        */
/* -Valores Retorno : Error->FALSE, !Error->TRUE                             */
/*****************************************************************************/
static BOOL bCalculaImptos (int       iInd,/* Reg sobre el que Aplico Impto*/
                            IMPUESTOS *pImpuesto, int iNumReg)
{
    BOOL bRes    = TRUE;

    if ( pImpuesto->iTipMonto == PORCENTUAL )
    {
         stPreFactura.A_PFactura[iNumReg].dImpConcepto  =
               (double)(pImpuesto->fPrcImpuesto * stPreFactura.A_PFactura[iInd].dImpConcepto)/100;
    }
    else
    {
         stPreFactura.A_PFactura[iNumReg].dImpConcepto  = (double)(pImpuesto->fPrcImpuesto) ;
    }

    stPreFactura.A_PFactura[iNumReg].dImpMontoBase = stPreFactura.A_PFactura[iInd].dImpConcepto;
    stPreFactura.A_PFactura[iNumReg].dImpFacturable  = fnCnvDouble(stPreFactura.A_PFactura[iNumReg].dImpConcepto,0);
    
    vDTrazasLog (szExeName, "\n\t\t* Calculo del IVA:\n"
                            "\t\t=> iNumReg        [%d]\n"
                            "\t\t=> iInd           [%d]\n"
                            "\t\t=> Impto. IVA     [%f]\n"
                            "\t\t=> Valor IVA      [%f]\n"
                            "\t\t=> Monto Neto     [%f]\n"
                            "\t\t=> Monto Neto impfact [%f]\n"
                          , LOG05
                          , iNumReg, iInd, pImpuesto->fPrcImpuesto/100
                          , stPreFactura.A_PFactura[iNumReg].dImpConcepto
                          , stPreFactura.A_PFactura[iInd].dImpConcepto
                          , stPreFactura.A_PFactura[iInd].dImpFacturable);

    if (!bConversionMoneda (stCliente.lCodCliente                          ,
                            stPreFactura.A_PFactura[iInd].szCodMoneda      ,
                            stDatosGener.szCodMoneFact                     ,
                            szSysDate                                      ,
                           &stPreFactura.A_PFactura[iNumReg].dImpFacturable))
    {
        return FALSE;
    } /* P-MIX-09003 4 */

    stPreFactura.A_PFactura[iNumReg].dImpFacturable = fnCnvDouble (stPreFactura.A_PFactura[iNumReg].dImpFacturable,0);
  
    vDTrazasLog (szExeName, "\t\t* Importes despues del redondeo:\n"
                            "\t\t=> Monto Base:    [%f]\n"
                            "\t\t=> Valor IVA :    [%f]\n"
                            "\t\t=> Valor IVA impfact: [%f]\n"
                          , LOG05
                          , stPreFactura.A_PFactura[iNumReg].dImpMontoBase 
                          , stPreFactura.A_PFactura[iNumReg].dImpConcepto  
                          , stPreFactura.A_PFactura[iNumReg].dImpFacturable);
  return (bRes);
}/**************************  Final bCalculaImptos ***************************/


/*****************************************************************************/
/*                           funcion : bGetImpuestos                         */
/* -Busca en memoria pstImpuesto  (global al modulo) los impuestos para una  */
/*  un mismo iCodCatImpos, iCodZonaimpos, iCodGrpServi, Fecha                */
/*  y iCodZonaimposAbon     -- COL-50001 Indra-jpena   20/05/2005            */
/*  y los carga en IMPTOS                                                    */
/* -Valores de Retorno : Error->FALSE, !Error->TRUE                          */
/*****************************************************************************/
BOOL bGetImpuestos (int iCodCatImpos, int  iCodZonaImpo, int iCodZonaAbon,
                    int iCodGrpServi, char *szFecVenc ,
                    IMPTOS* pImpto  , int  iTipoFact)
{
    int  iCount    = 0   ;
    int  iNumImpto = 0   ;
    int  iInd      = 0   ;
    BOOL bRes      = TRUE;
    BOOL bExiste   = FALSE;

    EXEC SQL BEGIN DECLARE SECTION;
         static int   ihCodCatImpos  ;
         static int   ihCodZonaImpo  ;
         static int   ihCodZonaAbon  ;
         static int   ihCodTipImpues ;
         static int   ihCodGrpServi  ;
         static char* szhFecVencimie ; EXEC SQL VAR szhFecVencimie IS STRING(15);
         static int   ihCodConcGene  ;
         static float fhPrcImpuesto  ;
         static int   ihTipMonto     ;
         static int   ihCodTipImptDcto;
    EXEC SQL END DECLARE SECTION;

    vDTrazasLog (szExeName, "\n\t\t* Parametros entrada Ge_Impuestos\n"
                            "\t\t=> Cod.CatImpos   [%d]\n"
                            "\t\t=> Cod.ZonaImpos  [%d]\n"
                            "\t\t=> Cod.ZonaAbon   [%d]\n"
                            "\t\t=> Cod.Grupo Sev. [%d]\n"
                            "\t\t=> Fec.Vencimie.  [%s]\n"
                          , LOG05
                          , iCodCatImpos,iCodZonaImpo,iCodZonaAbon,iCodGrpServi,szFecVenc);

    if (iTipoFact == FACT_CICLO)
    {
        while (bRes && iCount<NUM_IMPUESTOS)
        {
               if (pstImpuestos[iCount].iCodCatImpos == iCodCatImpos       &&
                   pstImpuestos[iCount].iCodGrpServi == iCodGrpServi       &&
                  (pstImpuestos[iCount].iCodZonaImpo == iCodZonaImpo ||
                   pstImpuestos[iCount].iCodZonaImpo == 0                ) &&
                  (pstImpuestos[iCount].iCodZonaAbon == iCodZonaAbon ||
                   pstImpuestos[iCount].iCodZonaAbon == 0                ) &&
                  (strcmp (pstImpuestos[iCount].szFecDesde,szFecVenc)<= 0) &&
                  (strcmp (pstImpuestos[iCount].szFecHasta,szFecVenc)>= 0) &&
                  pstImpuestos[iCount].fPrcImpuesto  != 0.0                &&
                  pstImpuestos[iCount].iCodTipImpues != pstFadParam.iCodTipImptoDocto /* impuesto al documento */
                  )       
               {
                  /* BUSCA SI YA APLICO ESTE IMPUESTO (escenario en que se aplica con una u (OR) otra condicion)*/
                  bExiste=FALSE;
                  for (iInd=0; iInd<iNumImpto; iInd++)
                  {
                       if ( (pImpto->pImpuestos[iInd].iCodConcGene  == pstImpuestos[iCount].iCodConcGene) &&
                            (pImpto->pImpuestos[iInd].fPrcImpuesto == pstImpuestos[iCount].fPrcImpuesto) )
                       {
                             bExiste=TRUE;
                             break;
                       }
                  }
                  
                  /* valida si ya aplico el mismo impuesto para no duplicarlo - ver como optimizar este codigo */
                  if (!bExiste )
                  {
                      if ((pImpto->pImpuestos =
                          (IMPUESTOS*)realloc((IMPUESTOS*)pImpto->pImpuestos,
                          (iNumImpto+1)*sizeof(IMPUESTOS)))==(IMPUESTOS*)NULL)
                      {
                          iDError (szExeName,ERR005,vInsertarIncidencia,"bGetImpuesto->pImpto");
                          strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria"
                                                              , strlen(stAnomProceso.szObsAnomalia));
                          bRes = FALSE;
                      }
                      else
                      {
                          memcpy (&pImpto->pImpuestos[iNumImpto],&pstImpuestos[iCount],sizeof(IMPUESTOS));
                          iNumImpto++;
                      }
                  } /* fin if ya aplico este impuesto */
               }
               
               if ( bRes )
               {
                   iCount++;
               }
        }/* fin While NUM_IMPUESTOS */
    }
    else
    {
       ihCodCatImpos = iCodCatImpos ;
       ihCodZonaImpo = iCodZonaImpo ;
       ihCodZonaAbon = iCodZonaAbon ;
       ihCodGrpServi = iCodGrpServi ;
       szhFecVencimie= szFecVenc    ;

       ihCodTipImptDcto = pstFadParam.iCodTipImptoDocto;

       EXEC SQL DECLARE Cur_Impuestos CURSOR FOR
            SELECT /*+ index (GE_IMPUESTOS PK_GE_IMPUESTOS) */
                   I.COD_CONCGENE                          ,
                   I.PRC_IMPUESTO,
                   T.TIP_MONTO
            FROM   GE_IMPUESTOS I, GE_TIPIMPUES T
            WHERE  I.COD_TIPIMPUES= T.COD_TIPIMPUE
              AND  I.COD_CATIMPOS = :ihCodCatImpos
              AND  I.COD_ZONAIMPO = DECODE(I.COD_ZONAIMPO,0,0,:ihCodZonaImpo)
              AND  I.COD_ZONAABON = DECODE(I.COD_ZONAABON,0,0,:ihCodZonaAbon)
              AND  I.COD_GRPSERVI = :ihCodGrpServi
              AND  I.FEC_DESDE   <= TO_DATE (:szhFecVencimie,'YYYYMMDDHH24MISS')
              AND  I.FEC_HASTA   >= TO_DATE (:szhFecVencimie,'YYYYMMDDHH24MISS')
              AND  I.PRC_IMPUESTO != 0.0 
              AND  T.COD_TIPIMPUE != :ihCodTipImptDcto /*  IMPUESTOS NORMALES */
            ORDER BY COD_CONCGENE,PRC_IMPUESTO;

      EXEC SQL OPEN Cur_Impuestos;

      if (SQLCODE != SQLOK)
      {
          iDError (szExeName,ERR000,vInsertarIncidencia,"Open->Ge_Impuestos",
                   szfnORAerror());
          bRes = FALSE;
      }
      iNumImpto = 0;
      while (bRes && SQLCODE == SQLOK)
      {
             EXEC SQL FETCH Cur_Impuestos INTO :ihCodConcGene,
                                               :fhPrcImpuesto,
                                               :ihTipMonto;
                                               
             if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
             {
                 iDError (szExeName,ERR000,vInsertarIncidencia, "Fetch->Ge_Impuestos",szfnORAerror());
             }
                
             if (SQLCODE == SQLOK)
             {
                 if ((pImpto->pImpuestos =
                    (IMPUESTOS *)realloc( (IMPUESTOS *)pImpto->pImpuestos,
                    (iNumImpto+1)*sizeof(IMPUESTOS) ) ) == (IMPUESTOS *)NULL)
                 {
                     iDError (szExeName,ERR005,vInsertarIncidencia,"bGetImpuesto->pImpto");
                     strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria",
                                                           strlen(stAnomProceso.szObsAnomalia));
                     bRes = FALSE;
                 }
                 else
                 {
                    /* BUSCA SI YA APLICO ESTE IMPUESTO (escenario en que se aplica con una u (OR) otra condicion)*/
                     bExiste=FALSE;
                     for (iInd=0; iInd<iNumImpto; iInd++)
                     {
                          if ( (pImpto->pImpuestos[iInd].iCodConcGene  == ihCodConcGene) &&
                               (pImpto->pImpuestos[iInd].fPrcImpuesto == fhPrcImpuesto) )
                          {
                                bExiste=TRUE;
                                break;
                          }
                     }
                     /* valida si ya aplico el mismo impuesto para no duplicarlo *** ver como optimizar este codigo */
                     if ( !bExiste )
                     {
                          pImpto->pImpuestos[iNumImpto].iCodConcGene =ihCodConcGene;
                          pImpto->pImpuestos[iNumImpto].iCodCatImpos =ihCodCatImpos;
                          pImpto->pImpuestos[iNumImpto].iCodZonaImpo =ihCodZonaImpo;
                          pImpto->pImpuestos[iNumImpto].iCodZonaAbon =ihCodZonaAbon;
                          pImpto->pImpuestos[iNumImpto].iCodTipImpues=ihCodTipImpues;
                          pImpto->pImpuestos[iNumImpto].fPrcImpuesto =fhPrcImpuesto;
                          pImpto->pImpuestos[iNumImpto].iCodGrpServi =ihCodGrpServi;
                          pImpto->pImpuestos[iNumImpto].iTipMonto    =ihTipMonto;
                          iNumImpto++;
                     }
                 }
             }/* fin SQLCODE == SQLOK */
      }/* While sqlcode == sqlok */
      
      if (bRes && SQLCODE != SQLNOTFOUND)
      {
          bRes = FALSE;
      }
      else
      {
         EXEC SQL CLOSE Cur_Impuestos;
         if (SQLCODE)
         {
             iDError (szExeName,ERR000,vInsertarIncidencia, "Close->Ge_Impuestos",szfnORAerror());
             bRes = FALSE;
         }
      }
   }
   if (bRes)
   {
       pImpto->iNumImpuestos = iNumImpto;
       vPrintImpuestos (pImpto)         ;
   }
   
   return (bRes);
}/************************** Final bGetImpuestos *****************************/

/*****************************************************************************/
/*                          funcion : vPrintImpuestos                        */
/*****************************************************************************/
void vPrintImpuestos (IMPTOS* pImpto)
{
    int i = 0;

    if (stStatus.LogNivel >= LOG05)
    {
        vDTrazasLog (szExeName,"\n\t\t*** Impuestos Cargado ***",LOG05);
    
        for (i=0;i<pImpto->iNumImpuestos;i++)
        {
             vDTrazasLog (szExeName, "\n\t\tCodCatimpos [%d]"
                                     "\n\t\tCodZonaimp. [%d]"
                                     "\n\t\tCodTipimpues[%d]"
                                     "\n\t\tCodGrpServi [%d]"
                                     "\n\t\tCodConcGene [%d]"
                                     "\n\t\tPrcImpuesto [%f]"
									 "\n\t\tCodZonaAbon [%d]"
                                   , LOG05
                                   , pImpto->pImpuestos[i].iCodCatImpos
                                   , pImpto->pImpuestos[i].iCodZonaImpo 
                                   , pImpto->pImpuestos[i].iCodTipImpues
                                   , pImpto->pImpuestos[i].iCodGrpServi 
                                   , pImpto->pImpuestos[i].iCodConcGene 
                                   , pImpto->pImpuestos[i].fPrcImpuesto
								   , pImpto->pImpuestos[i].iCodZonaAbon);
        }/* fin for i */
    }
}/************************** Final vPrintImpuestos ***************************/

void vFreeAcumImpuestoTipos (ACUMDETIMPTOSTIPO* pAcumImptoTipo)
{
    if (pAcumImptoTipo->stDetImptosTipo != NULL)
    {
        pAcumImptoTipo->iNumRegs = 0             ;
        free (pAcumImptoTipo->stDetImptosTipo)             ;
        pAcumImptoTipo->stDetImptosTipo = (DETIMPTOSTIPO *)NULL;
    }
}
void vFreeAcumImpuestoAbonado (ACUMIMPUESTOABONADOS* pEstructura)
{
    if (pEstructura->stAcumImpto != NULL)
    {
        pEstructura->iNumAbonados = 0             ;
        free (pEstructura->stAcumImpto)             ;
        pEstructura->stAcumImpto = (ACUMIMPUESTO *)NULL;
    }
}
void vFreeAcumAbonado (ACUMABONADOS* pEstructura)
{
    if (pEstructura->stAcumAbonado != NULL)
    {
        pEstructura->iNumAbonados = 0             ;
        free (pEstructura->stAcumAbonado)             ;
        pEstructura->stAcumAbonado = (ACUMABONADO *)NULL;
    }
}
/*****************************************************************************/
/*                           funcion : vFreeImpuestos                        */
/* -Libera memoria de la estructura stImptos                                 */
/*****************************************************************************/
void vFreeImpuestos (IMPTOS* pImpto)
{
    if (pImpto->pImpuestos != NULL)
    {
        pImpto->iNumImpuestos = 0             ;
        free (pImpto->pImpuestos)             ;
        pImpto->pImpuestos = (IMPUESTOS *)NULL;
    }
}/************************** Final vFreeImpuestos ****************************/

void vFreeTotImpuestos (TOTIMPTOS* pTotImpto)
{
    if (pTotImpto->stTotImptos != NULL)
    {
        pTotImpto->iNumTotImptos=0;
        free (pTotImpto->stTotImptos)             ;
    }
}/************************** Final vFreeTotImpuestos **************************/


/*****************************************************************************/
/*                     funcion : bGeneraCuotas                               */
/* -Funcion que llama al package fa_pac_cuota.p_main_cuota                   */
/* -Valores Retorno : Error->FALSE,!Error->TRUE                              */
/*****************************************************************************/
static BOOL bGeneraCuotas (long  lNumCargo , char *szCodCuota,
                           float fPrcImpues, int   iCodConcepto)
{
  EXEC SQL BEGIN DECLARE SECTION;
  static long  lhNumCargo      ;
  static char* szhCodCuota     ; EXEC SQL VAR szhCodCuota IS STRING (3);
  static float fhPrcImpuesto   ;
  static int   ihCodConcepto   ;
  EXEC SQL END DECLARE SECTION;

  lhNumCargo       = lNumCargo      ;
  szhCodCuota      = szCodCuota     ;
  fhPrcImpuesto    = fPrcImpues     ;
  ihCodConcepto    = iCodConcepto   ;

  vDTrazasLog (szExeName,"\n\t\t*** Generando Cuotas ***\n"
               "\t\tNum.Cargo     [%ld]\n"
               "\t\tCod.Cuota     [%s]\n"
               "\t\tPrc.Impuesto  [%f]\n"
               "\t\tCod.Concepto  [%d]\n",LOG04,
               lhNumCargo,szCodCuota,fPrcImpues,ihCodConcepto);
  EXEC SQL EXECUTE
  BEGIN
      fa_pac_cuota.p_main_cuota(:lhNumCargo   ,:szhCodCuota,
                                :fhPrcImpuesto,:ihCodConcepto);
  END;
  END-EXEC;
  if (SQLCODE)
      iDError (szExeName,ERR000,vInsertarIncidencia,
               "\t\tCod.Cuota     [%s]\n"
               "\t\tPrc.Impuesto  [%f]\n"
               "\t\tCod.Concepto  [%d]\n",LOG04,
               szCodCuota,fPrcImpues,ihCodConcepto);

  return (SQLCODE != 0)?FALSE:TRUE;
}/********************** Final bGeneraCuotas *********************************/


static BOOL bfnAcumTotImptos (  TOTIMPTOS *pstTotImptos ,
                                int     iCodConcBase    ,
                                int     iCodConcepto    ,
                                double  dImpMontoBase   ,
                                double  dImpConcepto    ,
                                float   fPrcImpuesto,
                                int     iTipMonto)
{
    int i;
    BOOL bExist=FALSE;

    vDTrazasLog (szExeName, "\t\t*** Entrada en %s ***\n"
                            "\t\tiCodConcepto  [%d]\n"
                            "\t\tdImpMontoBase [%f]\n"
                            "\t\tdImpConcepto  [%f]\n"
                            "\t\tfPrcImpuesto  [%f]\n",LOG04, "bfnAcumTotImptos",
                            iCodConcepto,dImpMontoBase,dImpConcepto ,fPrcImpuesto);

    for (i=0;i<MAX_FACTCARRIERS;i++) /* Busqueda del concepto en los conceptos de carrier */
    {
        if (pstFactCarriers[i].iCodConcFact == iCodConcBase )
        {
            vDTrazasLog (szExeName, "\n\t\t* Concepto de Carrier %d no se acumula para el ajuste * "
                        ,LOG05, iCodConcepto);
            return (TRUE);
        }
    }

    for (i=0;i<pstTotImptos->iNumTotImptos;i++)
    {
        if (pstTotImptos->stTotImptos[i].iCodImpto == iCodConcepto &&
            pstTotImptos->stTotImptos[i].fPorcent == fPrcImpuesto )
        {
            bExist = TRUE;
            break;
        }
    }

    if (bExist)
    {
        vDTrazasLog (szExeName, "\n\t\t=>[%d] += dImpMontoBase [%f]"
                                "\n\t\t=>[%d] += dImpConcepto  [%f]", LOG05
                                ,i,dImpMontoBase, i, dImpConcepto);
        if ( pstTotImptos->stTotImptos[i].iTipMonto == PORCENTUAL )
        { 
            pstTotImptos->stTotImptos[i].dTotMBase+=dImpMontoBase;
        }
        else {
          pstTotImptos->stTotImptos[i].dTotMBase+=1; /* cantiad de  imp. monto fijo */
        }
        pstTotImptos->stTotImptos[i].dTotImpto+=dImpConcepto;
    }
    else
    {
        vDTrazasLog (szExeName, "\n\t\t=>** Se crea nuevo registro de Tot.impuestos **"
                                "\n\t\t=>[%d] += iCodImpto [%d]"
                                "\n\t\t=>[%d] += fPorcent  [%f]"
                                "\n\t\t=>[%d] += dTotMBase [%f]"
                                "\n\t\t=>[%d] += dTotImpto [%f]"
                                , LOG05,i,iCodConcepto
                                ,i,fPrcImpuesto,i,dImpMontoBase, i, dImpConcepto);

        if ((pstTotImptos->stTotImptos =
            (TOTIMPTO*)realloc((TOTIMPTO*)pstTotImptos->stTotImptos,
                               (pstTotImptos->iNumTotImptos+1)*sizeof(TOTIMPTO)))
            ==(TOTIMPTO*)NULL)
        {
            iDError (szExeName,ERR005,vInsertarIncidencia,
                             "pstTotImptos->stTotImptos");
        }

        pstTotImptos->stTotImptos[pstTotImptos->iNumTotImptos].iCodImpto=   iCodConcepto;
        pstTotImptos->stTotImptos[pstTotImptos->iNumTotImptos].fPorcent =   fPrcImpuesto;
        pstTotImptos->stTotImptos[pstTotImptos->iNumTotImptos].dTotMBase=   dImpMontoBase;
        pstTotImptos->stTotImptos[pstTotImptos->iNumTotImptos].dTotImpto=   dImpConcepto;
        pstTotImptos->stTotImptos[pstTotImptos->iNumTotImptos].iTipMonto=   iTipMonto;
        pstTotImptos->iNumTotImptos++;

    }
    return (TRUE);
}/****************************** Fin bfnAcumTotImptos ****************************/

/**********************************************************/
/* FUNCION : bfnAjusteImptos                              */
/**********************************************************/
static BOOL bfnAjusteImptos (TOTIMPTOS *pstTotImptos)
{
    /* Estuctura para acumular los totales por abonado */
    TOTABON stTotalesAbon;
    int     i,x;
    double  dMontoAjuste  = 0.0;
    int     iCont=0;
    int     iFlagAjuste   =   0;
    double  dIvaAcumBase  = 0.0;
    BOOL    bExiste=FALSE      ;
    double  dAcuFacturable= 0.0;
    double  dAcuConceptos = 0.0;

    vDTrazasLog (szExeName,"\n\t\t*** Entrada en bfnAjusteImptos ***"
                           "\n\t\tNum.Registros = %d  iNumTotImptos=%d"
                            ,LOG04,stPreFactura.iNumRegistros
                            ,pstTotImptos->iNumTotImptos);

    /*****************************************************************************/
    /*  Rutina para calcular los saldos X abonado para realizar el ajuste        */
    /*****************************************************************************/
    memset (&stTotalesAbon,0,sizeof (TOTABON));
    iCont = stPreFactura.iNumRegistros - 1;

    for (i =0; i<=iCont; i++)
    {
        dAcuFacturable  = dAcuFacturable + stPreFactura.A_PFactura[i].dImpFacturable;
        dAcuConceptos   = dAcuConceptos + stPreFactura.A_PFactura [i].dImpConcepto   ;
    }

    if (fnCnvDouble(dAcuConceptos, USOFACT) == dAcuFacturable)
    {
        return (TRUE);
    }

    vDTrazasLog (szExeName,"\n\t\t*** Entrada 2 en bfnAjusteImptos ***"
                           "\n\t\tCont = %d NumAbonados =%d",LOG04,iCont
                           ,stTotalesAbon.iNumAbonados);
    for (i=0;i<=iCont;i++)
    {
        bExiste=FALSE;
        for (x=0;x<stTotalesAbon.iNumAbonados;x++)
        {
            if (stTotalesAbon.stAbon[x].lNumAbonado == stPreFactura.A_PFactura[i].lNumAbonado)
            {
                stTotalesAbon.stAbon[x].dTotFactur  += stPreFactura.A_PFactura[i].dImpFacturable;
                bExiste=TRUE;
                break;
            }
        }
        if (!bExiste)
        {
            x =stTotalesAbon.iNumAbonados;
            stTotalesAbon.stAbon[x].lNumAbonado  = stPreFactura.A_PFactura[i].lNumAbonado;
            stTotalesAbon.stAbon[x].dTotFactur  += stPreFactura.A_PFactura[i].dImpFacturable;
            stTotalesAbon.iNumAbonados++;


            if (stTotalesAbon.iNumAbonados > NUM_ABONADOS_CLIENTE)
            {
                vDTrazasError(szExeName,"\n\t**  Sobrepasado NUM_ABONADOS_CLIENTE **",LOG01);
                vDTrazasLog  (szExeName,"\n\t**  Sobrepasado NUM_ABONADOS_CLIENTE **",LOG01);
                return (FALSE);
            }
        }
    }
    /****************************************************************************/

    for (i=0;i<pstTotImptos->iNumTotImptos;i++) /* Recorre los impuestos */
    {
        if ( pstTotImptos->stTotImptos[i].iTipMonto == PORCENTUAL )
        {        dIvaAcumBase = pstTotImptos->stTotImptos[i].dTotMBase * (double)pstTotImptos->stTotImptos[i].fPorcent / 100 ;
        }
        else {  dIvaAcumBase =  pstTotImptos->stTotImptos[i].dTotMBase * (double)pstTotImptos->stTotImptos[i].fPorcent;
        }
        dIvaAcumBase = fnCnvDouble(dIvaAcumBase,USOFACT);
        dMontoAjuste = dIvaAcumBase - pstTotImptos->stTotImptos[i].dTotImpto;

        vDTrazasLog (szExeName, "\n\t\t* MONTO DEL AJUSTE [%f]", LOG04, dMontoAjuste);

        if (dMontoAjuste != 0.0 && (abs(dMontoAjuste) >= pstParamGener.iMtoMinAjuste))
        {
            iFlagAjuste=0;
            vDTrazasLog (szExeName, "\n\t\t* AJUSTE DE IVA "
                                    "\n\t\t=> iCont            : [%d]"
                                    "\n\t\t=> Num. Registros   : [%d]"
                                    "\n\t\t=> Num. Impuestos   : [%d]"
                                    "\n\t\t=> Total Ajuste     : [%f]"
                                  , LOG04, iCont
                                  , stPreFactura.iNumRegistros
                                  , iNImptosT,dMontoAjuste);

            while((iCont >= 0) && (iFlagAjuste != 1))
            {
                if ((stPreFactura.A_PFactura[iCont].iCodConcepto    == pstTotImptos->stTotImptos[i].iCodImpto)  &&
                    (stPreFactura.A_PFactura[iCont].fPrcImpuesto    == pstTotImptos->stTotImptos[i].fPorcent )  &&
                    (stPreFactura.A_PFactura[iCont].dImpConcepto    != 0.0                                  )  &&
                    ( ( stPreFactura.A_PFactura[iCont].dImpConcepto > 0 && dMontoAjuste < 0 && (stPreFactura.A_PFactura[iCont].dImpConcepto + dMontoAjuste) >= 0 ) ||
                      ( stPreFactura.A_PFactura[iCont].dImpConcepto < 0 && dMontoAjuste > 0 && (stPreFactura.A_PFactura[iCont].dImpConcepto + dMontoAjuste) <= 0 ) ||
                      ( stPreFactura.A_PFactura[iCont].dImpConcepto > 0 && dMontoAjuste > 0 ) ||
                      ( stPreFactura.A_PFactura[iCont].dImpConcepto < 0 && dMontoAjuste > 0 )))
                {
                    if((stPreFactura.A_PFactura[iCont].iCodConceRel != stDatosGener.iCodAbonoCel)   &&
                       (stPreFactura.A_PFactura[iCont].iCodConceRel != stDatosGener.iCodAbonoBeep))
                    {

                        vDTrazasLog (szExeName, "\n\t\t* Haciendo ajuste del IVA "
                                                "\n\t\t=> Registro            : [%d]"
                                                "\n\t\t=> Concepto            : [%d]"
                                                "\n\t\t=> Descrip. Concepto   : [%s]"
                                                "\n\t\t=> Producto            : [%d]"
                                                "\n\t\t=> Importe Concepto    : [%f]"
                                                "\n\t\t=> Concepto Relacion.  : [%d]"
                                                "\n\t\t=> Importe Facturable  : [%f]", LOG05,iCont,
                                                stPreFactura.A_PFactura[iCont].iCodConcepto  ,
                                                stPreFactura.A_PFactura[iCont].szDesConcepto ,
                                                stPreFactura.A_PFactura[iCont].iCodProducto  ,
                                                stPreFactura.A_PFactura[iCont].dImpConcepto  ,
                                                stPreFactura.A_PFactura[iCont].iCodConceRel  ,
                                                stPreFactura.A_PFactura[iCont].dImpFacturable);
                        /*** RAO: Valida que el total del abonado sea >0 */
                        for (x=0;x<stTotalesAbon.iNumAbonados;x++)
                        {
                            if (stTotalesAbon.stAbon[x].lNumAbonado == stPreFactura.A_PFactura[iCont].lNumAbonado)
                                break;
                        }

                        if (stTotalesAbon.stAbon[x].dTotFactur + dMontoAjuste >= 0 )
                        {
                            vDTrazasLog (szExeName,"\n\t\t* Abonado [%ld] total [%f] ajuste [%f]"
                                        ,LOG05,stTotalesAbon.stAbon[x].lNumAbonado
                                        ,stTotalesAbon.stAbon[x].dTotFactur, dMontoAjuste);
                            stPreFactura.A_PFactura[iCont].dImpConcepto += dMontoAjuste;

                            stPreFactura.A_PFactura[iCont].dImpFacturable = fnCnvDouble(stPreFactura.A_PFactura[iCont].dImpConcepto,0);
                                                            
                            iFlagAjuste = 1;
                            vDTrazasLog (szExeName, "\n\t\t* Monto del ajuste        : [%f]"
                                                    "\n\t\t* Nuevo importe Concepto  : [%f]"
                                                    "\n\t\t* Nuevo importe Facturable: [%f]", LOG05,
                                                    dMontoAjuste, stPreFactura.A_PFactura[iCont].dImpConcepto,
                                                    stPreFactura.A_PFactura[iCont].dImpFacturable);
                        }
                        else
                        {       
                            /* RAO : Se aplica como ajuste el remanente de saldo del abonado */
                            stPreFactura.A_PFactura[iCont].dImpConcepto += (stTotalesAbon.stAbon[x].dTotFactur>0)?stTotalesAbon.stAbon[x].dTotFactur:0;

                            stPreFactura.A_PFactura[iCont].dImpFacturable = fnCnvDouble(stPreFactura.A_PFactura[iCont].dImpConcepto,0);
                            
                            dMontoAjuste -= (stTotalesAbon.stAbon[x].dTotFactur>0)?stTotalesAbon.stAbon[x].dTotFactur:0;

                            vDTrazasLog (szExeName, "\n\t\t*** Ajuste Especial, Total Factura < Ajuste ****"
                                                    "\n\t\t* Total Abonado           : [%f]"
                                                    "\n\t\t* Nuevo importe Concepto  : [%f]"
                                                    "\n\t\t* Nuevo importe facturable: [%f]"
                                                    "\n\t\t* Remanente Ajuste        : [%f]", LOG03,
                                                    stTotalesAbon.stAbon[x].dTotFactur,
                                                    stPreFactura.A_PFactura[iCont].dImpFacturable,
                                                    stPreFactura.A_PFactura[iCont].dImpFacturable,
                                                    dMontoAjuste);
                        }

                    }
                    else    /* El concepto es de cargo basico */
                    {
                        iCont--;
                    }
                } /* Fin if concepto = concepto Impto */
                if(iFlagAjuste != 1)
                    iCont--;
            }   /* Fin while */

            if(iFlagAjuste !=1)
            {
                vDTrazasLog (szExeName, "\n\t\t* No se hizo ajuste de IVA\n", LOG03);
            }
        }   /* Fin if(dMontoAjuste...) */

    } /* Fin For pstTotImptos->iNumTotImptos */

    return(TRUE);

}/************************* Final bfnAjusteImptos ****************************/
/*****************************************************************************/
/*                           funcion : bfnRegZonaAbon                    */
/*    Carga estructura con relacion de abonados con su zona impositiva       */
/*    Retur True -> Ok False, si no.                                         */
/*****************************************************************************/
static BOOL bfnRegZonaAbon  (int iNumRegIni)
{
    /* Estuctura para acumular los totales por abonado */
    int     i,x;
    int     iCont=0;
    BOOL    bExiste=FALSE       ;

    vDTrazasLog (szExeName,"\n\t\t*** Entrada en [%s] ***\niNumRegistros=[%d]  NumAbonados=[%d] "
                          ,LOG04, "bfnRegZonaAbon",stPreFactura.iNumRegistros,stZonaAbon.iNumAbonados);

    /*****************************************************************************/
    /*  Rutina para calcular los saldos X abonado para realizar el ajuste        */
    /*****************************************************************************/
    memset (&stZonaAbon,0,sizeof (TOTZABON));
    iCont = stPreFactura.iNumRegistros - 1;

    stZonaAbon.iNumAbonados = 0;

    for (i=iNumRegIni;i<=iCont;i++)
    {
        if (stPreFactura.A_PFactura[i].iCodZonaAbon != 0)
        {
            bExiste=FALSE;

            for (x=0;x<stZonaAbon.iNumAbonados;x++)
            {
                if ((stZonaAbon.stAbon[x].lNumAbonado == stPreFactura.A_PFactura[i].lNumAbonado))
                {
                    bExiste=TRUE;
                    break;
                }
            }

            if (!bExiste)
            {
                x =stZonaAbon.iNumAbonados;
                stZonaAbon.stAbon[x].lNumAbonado  = stPreFactura.A_PFactura[i].lNumAbonado ;
                stZonaAbon.stAbon[x].iCodZonaAbon = stPreFactura.A_PFactura[i].iCodZonaAbon;
                stZonaAbon.iNumAbonados++;
            }
        }
    }

    /****************************************************************************/

    return(TRUE);

}/************************* Final bfnRegZonaAbon ****************************/

/*****************************************************************************/
/*                           funcion : bfnAplicaImpto                        */
/*  Aplica los campos al nuevo concepto de impuesto                          */
/*****************************************************************************/
BOOL bfnAplicaImpto (int iIdxOri, IMPUESTOS* pImpto,int iTipoFact)
{
    CONCEPTO stConcepto;
    long iIdxFin;

    memset (&stConcepto,0,sizeof(CONCEPTO));

    if (!bFindConcepto (pImpto->iCodConcGene, &stConcepto))
    {
        vDTrazasLog  (szExeName,">> ERROR: buscando detalle concepto  <<",LOG01);
        vDTrazasError(szExeName,">> ERROR:  buscando detalle concepto <<",LOG01);
        return FALSE;
    }

    iIdxFin = stPreFactura.iNumRegistros;

    // rao prueba de copiar completo el concepto 
    memcpy (&stPreFactura.A_PFactura[iIdxFin], &stPreFactura.A_PFactura[iIdxOri], sizeof (FAPFACTURA));
    // 

    strcpy (stPreFactura.A_PFactura[iIdxFin].szDesConcepto,stConcepto.szDesConcepto);
    stPreFactura.A_PFactura[iIdxFin].iCodConcepto = pImpto->iCodConcGene;
    stPreFactura.A_PFactura[iIdxFin].fPrcImpuesto = pImpto->fPrcImpuesto;

    stPreFactura.A_PFactura[iIdxFin].bOptImpuesto = TRUE;
                                    
    if (!bGetMaxColPreFa(stPreFactura.A_PFactura[iIdxFin].iCodConcepto, &stPreFactura.A_PFactura[iIdxFin].lColumna ))
        return FALSE;

    switch (iTipoFact)
    {
        case FACT_CICLO      :
        case FACT_BAJA       :
            strcpy (stPreFactura.A_PFactura[iIdxFin].szFecValor , stCiclo.szFecEmision);
            break;
        case FACT_CONTADO    :
        case FACT_COMPRA     :
        case FACT_MISCELAN   :
        case FACT_LIQUIDACION:
        case FACT_RENTAPHONE :
        case FACT_ROAMINGVIS :
            strcpy (stPreFactura.A_PFactura[iIdxFin].szFecValor, szSysDate);
            break;
        default              :
            break;
    }

    strcpy(stPreFactura.A_PFactura[iIdxFin].szFecEfectividad, szSysDate);
    stPreFactura.A_PFactura[iIdxFin].iIndEstado    = EST_NORMAL;
    stPreFactura.A_PFactura[iIdxOri].iIndEstado    = EST_IMPTO ;
    stPreFactura.A_PFactura[iIdxFin].iCodTipConce  = IMPUESTO  ;
    stPreFactura.A_PFactura[iIdxFin].lCodCiclFact  = stCiclo.lCodCiclFact;
    stPreFactura.A_Ind[iIdxFin].i_lCodCiclFact     = (stCiclo.lCodCiclFact == ORA_NULL)?ORA_NULL:SQLOK;
    stPreFactura.A_PFactura[iIdxFin].iCodConceRel  = stPreFactura.A_PFactura[iIdxOri].iCodConcepto;
    stPreFactura.A_PFactura[iIdxFin].lColumnaRel   = stPreFactura.A_PFactura[iIdxOri].lColumna    ;
    stPreFactura.A_Ind[iIdxFin].i_lNumAbonado      = (stPreFactura.A_PFactura[iIdxOri].lNumAbonado == ORA_NULL)?-1:0   ;
    stPreFactura.A_Ind[iIdxFin].i_szNumTerminal    = (strcmp(stPreFactura.A_PFactura[iIdxOri].szNumTerminal,"")==0)?-1:0;
    stPreFactura.A_Ind[iIdxFin].i_lCapCode         = (stPreFactura.A_PFactura[iIdxOri].lCapCode    == ORA_NULL)?-1:0    ;
    stPreFactura.A_Ind[iIdxFin].i_szNumSerieMec    = (strcmp(stPreFactura.A_PFactura[iIdxOri].szNumSerieMec,"")==0)?-1:0;
    stPreFactura.A_Ind[iIdxFin].i_szNumSerieLe     = (strcmp(stPreFactura.A_PFactura[iIdxOri].szNumSerieLe ,"")==0)?-1:0;
    stPreFactura.A_PFactura[iIdxFin].iFlagImpues   = 0  ;
    stPreFactura.A_PFactura[iIdxOri].iFlagImpues   = 1  ;
    stPreFactura.A_PFactura[iIdxFin].iFlagDto      = 0  ;
    stPreFactura.A_PFactura[iIdxFin].iFlagDto      = 0  ;
    stPreFactura.A_PFactura[iIdxFin].dValDto       = -1 ;
    stPreFactura.A_Ind[iIdxFin].i_dValDto          = -1 ;
    stPreFactura.A_PFactura[iIdxFin].iTipDto       = -1 ;
    stPreFactura.A_Ind[iIdxFin].i_iTipDto          = -1 ;
    stPreFactura.A_Ind[iIdxFin].i_lNumVenta        =  (stPreFactura.A_PFactura[iIdxOri].lNumVenta    == ORA_NULL)?-1:0;
    stPreFactura.A_Ind[iIdxFin].i_lNumTransaccion  = (stPreFactura.A_PFactura[iIdxOri].lNumTransaccion==ORA_NULL)?-1:0;
    stPreFactura.A_PFactura[iIdxFin].iMesGarantia  = 0;
    stPreFactura.A_PFactura[iIdxFin].iIndAlta      = 1;
    stPreFactura.A_PFactura[iIdxFin].iIndSuperTel  = 0;
    stPreFactura.A_PFactura[iIdxFin].iNumPaquete   =-1;
    stPreFactura.A_Ind[iIdxFin].i_iNumPaquete      =-1;
    stPreFactura.A_PFactura[iIdxFin].iIndCuota     = 0;
    stPreFactura.A_PFactura[iIdxFin].iNumCuotas    = 0;
    stPreFactura.A_PFactura[iIdxFin].iOrdCuota     = 0;

    stPreFactura.A_PFactura[iIdxFin].dhImpConversion  =  stPreFactura.A_PFactura[0].dhImpConversion;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szhCodMonedaImp  , stPreFactura.A_PFactura[0].szhCodMonedaImp);

    /* stPreFactura.iNumRegistros++; */
    if(bfnIncrementarIndicePreFactura()==FALSE)
    {
        vDTrazasLog  (szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        vDTrazasError(szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        return FALSE;
    }

    return(TRUE);
}


/*****************************************************************************/
/*                           funcion : bfnEvalZonasImpos                     */
/*    Evalua las zonas impositivas del cliente y la oficina si estas son     */
/*    diferentes se asume la parametrizada en la tabla GED_PARAMETROS con    */
/*    el codigo 5.                                                           */
/*    Obs: piIndZonaImpCic -> obtenido desde la tabla ged_parametros         */
/*****************************************************************************/
BOOL bfnEvalZonasImpos (char *pszFecZonaImpo, int piTipoFact, int *iCodZonaImpo,
                        int piIndZonaImpCic)
{
char  szCodRegion    [4]="";
char  szCodProvincia [6]="";
char  szCodCiudad    [6]="";
int   iCodZonaImpoCli;
int   iCodZonaImpoOfi;
char  modulo[] = "bfnEvalZonasImpos";
char  pszCodOficina  [3]="";

    vDTrazasLog(modulo,"\n* Parametros Entrada %s "
                       "\n\t** stProceso.szCodOficina [%s] "
                       "\n\t** stCliente.szCodOficina [%s] "
                       "\n\t** Tipo documento         [%d] "
                       "\n\t** Ind. Tip Zona Impto.   [%d] "
                       ,LOG03,modulo, stProceso.szCodOficina,stCliente.szCodOficina, piTipoFact, piIndZonaImpCic);


    if (piTipoFact == FACT_CICLO && piIndZonaImpCic == ZICXOFICLIE)
    {
        strcpy(pszCodOficina,stCliente.szCodOficina);
        strcpy(stProceso.szCodOficina,pszCodOficina);
        if (bfnGetDirOficina (pszCodOficina, szCodRegion, szCodProvincia, szCodCiudad))
        {
            if (bGetZonaImpositiva(szCodRegion   ,
                                   szCodProvincia,
                                   szCodCiudad   ,
                                   &iCodZonaImpoCli, pszFecZonaImpo, piTipoFact))
            {
                *iCodZonaImpo = iCodZonaImpoCli;
            }
            else
            {
                vDTrazasError(modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                vDTrazasLog  (modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                return FALSE;
            }
        }
        else
        {
            vDTrazasError(modulo,"\n\t** En direccion de la oficina **",LOG01);
            vDTrazasLog  (modulo,"\n\t** En direccion de la oficina **",LOG01);
            return FALSE;
        }
        vDTrazasLog  (modulo,"\n\t** => Codigo de oficina [%s] **"
                             "\n\t** => Zona Impositiva   [%d] **"
                             ,LOG05,pszCodOficina,*iCodZonaImpo);
    }
    else
    {
        if(piTipoFact == FACT_CICLO && piIndZonaImpCic != ZICXOFICLIE)
        {
            if (bGetZonaImpositiva(stCliente.szCodRegion   ,
                                   stCliente.szCodProvincia,
                                   stCliente.szCodCiudad   ,
                                   &iCodZonaImpoCli, pszFecZonaImpo, piTipoFact))
            {
                vDTrazasLog  (modulo,"\n\t** => iCodZonaImpoCli [%d] **",LOG05,iCodZonaImpoCli);
                *iCodZonaImpo = iCodZonaImpoCli;
            }
            else
            {
                vDTrazasError(modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                vDTrazasLog  (modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                return FALSE;
            }
        }
        else
        {
            if (piTipoFact == FACT_MISCELAN)
            {
                if (!bfnGetDirOfiVend (stProceso.lCodVendedorAgente, pszCodOficina))
                {
                    vDTrazasError(modulo,"\n\t** ERROR, al obtener la oficina del vendedor **",LOG01);
                    vDTrazasLog  (modulo,"\n\t** ERROR, al obtener la oficina del vendedor **",LOG01);
                    return FALSE;
                }

                strcpy(stProceso.szCodOficina,pszCodOficina);


                vDTrazasLog  (modulo,"\n\t** Se asume zona impositiva del cliente  [%s] **", LOG05, pszCodOficina);

                if (bGetZonaImpositiva(stCliente.szCodRegion   ,
                                       stCliente.szCodProvincia,
                                       stCliente.szCodCiudad   ,
                                       &iCodZonaImpoCli, pszFecZonaImpo, piTipoFact))
                {
                    *iCodZonaImpo = iCodZonaImpoCli;
                }
                else
                {
                    vDTrazasError(modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                    vDTrazasLog  (modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                    return FALSE;
                }
                vDTrazasLog  (modulo,"\n\t** Zona Impositiva del cliente  [%d] **", LOG05, iCodZonaImpoCli);

            }
            else
            {
                strcpy(pszCodOficina,stProceso.szCodOficina);
                vDTrazasLog  (modulo,"\n\t** Codigo de oficina [%s] **", LOG05, pszCodOficina);

                if (bfnGetDirOficina (pszCodOficina, szCodRegion, szCodProvincia, szCodCiudad))
                {
                    vDTrazasLog  (modulo,"\n\t** => stProceso.szCodOficina [%s], szCodRegion [%s], szCodProvincia [%s], szCodCiudad [%s]**"
                                        ,LOG05,stProceso.szCodOficina, szCodRegion, szCodProvincia, szCodCiudad);
                    if (bGetZonaImpositiva(szCodRegion   , szCodProvincia, szCodCiudad ,
                                           &iCodZonaImpoOfi, pszFecZonaImpo, piTipoFact))
                    {
                        if (bGetZonaImpositiva(stCliente.szCodRegion   ,
                                               stCliente.szCodProvincia,
                                               stCliente.szCodCiudad   ,
                                               &iCodZonaImpoCli, pszFecZonaImpo, piTipoFact))
                        {
                            vDTrazasLog  (modulo,"\n\t** => iCodZonaImpoCli [%d] **",LOG05,iCodZonaImpoCli);
                            if (iCodZonaImpoCli != iCodZonaImpoOfi)
                            {
                                vDTrazasLog  (modulo,"\n\t** diferentes Zonas impositivas se toma la por defento [%d]**"
                                             ,LOG04,pstParamGener.iZonaImpoDefec);
                                *iCodZonaImpo = pstParamGener.iZonaImpoDefec;
                            }
                            else
                            {
                                *iCodZonaImpo = iCodZonaImpoCli;
                            }
                        }
                        else
                        {
                            vDTrazasError(modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                            vDTrazasLog  (modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                            return FALSE;
                        }
                    }
                    else
                    {
                        vDTrazasError(modulo,"\n\t** En Zona impositiva de la oficina **",LOG01);
                        vDTrazasLog  (modulo,"\n\t** En Zona impositiva de la oficina **",LOG01);
                        return FALSE;
                    }
                }
                else
                {
                    vDTrazasError(modulo,"\n\t** En direccion de la oficina **",LOG01);
                    vDTrazasLog  (modulo,"\n\t** En direccion de la oficina **",LOG01);
                    return FALSE;
                }
            }
        }
    }

    vDTrazasLog  (modulo,"\n\t** => ZonaImpoCli [%d] **",LOG05, *iCodZonaImpo);

    return TRUE;
}/*************************** Final bfnEvalZonasImpos ************************/


/*****************************************************************************/
/*                           funcion : bfnGetZonaAbon                        */
/*    Obtiene la zona impositiva del Abonado, evalueando el parametro        */
/*    que indica el tipo de Facturacion                                       */
/*                                                                   */
/*****************************************************************************/
BOOL bfnGetZonaAbon (char *pszFecZonaImpo, int piTipoFact, int *iCodZonaImpo,
                        int piIndZonaImpCic)
{
char  szCodRegion    [4]="";
char  szCodProvincia [6]="";
char  szCodCiudad    [6]="";
int   iCodZonaImpoCli;
int   iCodZonaImpoOfi;
char  modulo[] = "bfnGetZonaAbon";
char  pszCodOficina  [3]="";


    vDTrazasLog(modulo,"\n**bfnGetZonaAbon \t** stProceso.szCodOficina [%s] stCliente.szCodOficina[%s]**"
                       "\n\t** Tipo documento [%d]\n **"
                       ,LOG05,stProceso.szCodOficina,stCliente.szCodOficina, piTipoFact);

    if (piTipoFact == FACT_CICLO && piIndZonaImpCic == ZICXOFICLIE)
    {
        strcpy(pszCodOficina,stCliente.szCodOficina);
        strcpy(stProceso.szCodOficina,pszCodOficina);
        if (bfnGetDirOficina (pszCodOficina, szCodRegion, szCodProvincia, szCodCiudad))
        {
            if (bGetZonaImpositiva(szCodRegion   ,
                                   szCodProvincia,
                                   szCodCiudad   ,
                                   &iCodZonaImpoCli, pszFecZonaImpo, piTipoFact))
            {
                *iCodZonaImpo = iCodZonaImpoCli;
            }
            else
            {
                vDTrazasError(modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                vDTrazasLog  (modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                return FALSE;
            }
        }
        else
        {
            vDTrazasError(modulo,"\n\t** En direccion de la oficina **",LOG01);
            vDTrazasLog  (modulo,"\n\t** En direccion de la oficina **",LOG01);
            return FALSE;
        }
        vDTrazasLog  (modulo,"\n\t** => Codigo de oficina [%s] **"
                             "\n\t** => Zona Impositiva   [%d] **"
                             ,LOG05,pszCodOficina,*iCodZonaImpo);
    }
    else
    {
        if (piTipoFact == FACT_MISCELAN)
        {
            if (!bfnGetDirOfiVend (stProceso.lCodVendedorAgente, pszCodOficina))
            {
                vDTrazasError(modulo,"\n\t** ERROR, al obtener la oficina del vendedor **",LOG01);
                vDTrazasLog  (modulo,"\n\t** ERROR, al obtener la oficina del vendedor **",LOG01);
                return FALSE;
            }
        }
        else
        {
            strcpy(pszCodOficina,stProceso.szCodOficina);
        }

        strcpy(stProceso.szCodOficina,pszCodOficina);

        vDTrazasLog  (modulo,"\n\t** Codigo de oficina [%s] **", LOG05, pszCodOficina);

        if (bfnGetDirOficina (pszCodOficina, szCodRegion, szCodProvincia, szCodCiudad))
        {
            vDTrazasLog  (modulo,"\n\t** => stProceso.szCodOficina [%s], szCodRegion [%s], szCodProvincia [%s], szCodCiudad [%s]**"
                                ,LOG05,stProceso.szCodOficina, szCodRegion, szCodProvincia, szCodCiudad);
            if (bGetZonaImpositiva(szCodRegion   , szCodProvincia, szCodCiudad ,
                                   &iCodZonaImpoOfi, pszFecZonaImpo, piTipoFact))
            {
                if (piTipoFact == FACT_MISCELAN)
                /* TM-200403170575. Si es MISCELANEA entonces se considera la zona impositiva de la oficina del vendedor*/
                {
                  *iCodZonaImpo = iCodZonaImpoOfi;
                }
                else
                {
                    if (bGetZonaImpositiva(stCliente.szCodRegion   ,
                                           stCliente.szCodProvincia,
                                           stCliente.szCodCiudad   ,
                                           &iCodZonaImpoCli, pszFecZonaImpo, piTipoFact))
                    {
                        vDTrazasLog  (modulo,"\n\t** => iCodZonaImpoCli [%d] **",LOG05,iCodZonaImpoCli);
                        if (iCodZonaImpoCli != iCodZonaImpoOfi)
                        {
                            vDTrazasLog  (modulo,"\n\t** diferentes Zonas impositivas se toma la por defento [%d]**"
                                         ,LOG04,pstParamGener.iZonaImpoDefec);
                            *iCodZonaImpo = pstParamGener.iZonaImpoDefec;
                        }
                        else
                        {
                            *iCodZonaImpo = iCodZonaImpoCli;
                        }
                    }
                    else
                    {
                        vDTrazasError(modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                        vDTrazasLog  (modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
                        return FALSE;
                    }
                }
            }
            else
            {
                vDTrazasError(modulo,"\n\t** En Zona impositiva de la oficina **",LOG01);
                vDTrazasLog  (modulo,"\n\t** En Zona impositiva de la oficina **",LOG01);
                return FALSE;
            }
        }
        else
        {
            vDTrazasError(modulo,"\n\t** En direccion de la oficina **",LOG01);
            vDTrazasLog  (modulo,"\n\t** En direccion de la oficina **",LOG01);
            return FALSE;
        }
    }

    vDTrazasLog(modulo,"\n**bfnGetZonaAbon\t** stProceso.szCodOficina [%s] stCliente.szCodOficina[%s]**\n"
                                                    ,LOG05,stProceso.szCodOficina,stCliente.szCodOficina);
        return TRUE;
}/*************************** Final bfnGetZonaAbon ************************/




/*****************************************************************************/
/*                           funcion : bfnGetOficina                         */
/*    Obtiene la region, provinci y ciudad de la oficina pasada              */
/*****************************************************************************/
BOOL bfnGetDirOficina (char *pszCodOficina, char *szCodRegion
                     , char *szCodProvincia, char *szCodCiudad    )
{
char   modulo[] = "bfnGetOficina";

    OFICINA pstOficina;

    vDTrazasLog (modulo, "\n\t\t Cod Oficina: [%s] \n",LOG05,pszCodOficina);

    if (!bfnFindOficina (pszCodOficina, &pstOficina ))
    {
        vDTrazasLog (modulo, "\n\t\t Error Obtener oficina : [%s] \n",LOG01,pszCodOficina);
        return FALSE;
    }

    strcpy(szCodRegion   , pstOficina.szCodRegion);
    strcpy(szCodProvincia, pstOficina.szCodProvincia);
    strcpy(szCodCiudad   , pstOficina.szCodCiudad);

    return (TRUE);
}/*************************** Final bfnGetOficina ****************************/

/*****************************************************************************/
/*                           funcion : bfnGetDirAbonado                      */
/*    Obtiene la region, provincia y ciudad del usuario asociado al Abonado  */
/*    Adicionalmente, se rescata la zona impositiva del abonado              */
/*****************************************************************************/
BOOL bfnGetDirAbonado (long lNumAbonado, char *szCodRegion, char *szCodProvincia
                      , char *szCodCiudad , char *szCodComuna, long *lCodUsuario
                      , int *iCodZonaImpAbon )
{
char   modulo[] = "bfnGetDirAbonado";

    EXEC SQL BEGIN DECLARE SECTION;
        static long  lhNumAbonado = 0L;
        int  ihCodZonaImpAbon     = 0;
        char szhCodRegion    [4];EXEC SQL VAR szhCodRegion    IS STRING(4);
        char szhCodProvincia [6];EXEC SQL VAR szhCodProvincia IS STRING(6);
        char szhCodCiudad    [6];EXEC SQL VAR szhCodCiudad    IS STRING(6);
        char szhCodComuna    [6];EXEC SQL VAR szhCodComuna    IS STRING(6);
        static long lhCodUsuario;
        char szhCodTipDirec  [2];EXEC SQL VAR szhCodTipDirec  IS STRING(2);
    EXEC SQL END DECLARE SECTION;

    vDTrazasLog (modulo, "\n\t\t Num Abonado: [%ld] \n",LOG05,lNumAbonado);

    lhNumAbonado= lNumAbonado;

    sprintf(szhCodTipDirec, "2\0");

    EXEC SQL
        SELECT B.COD_REGION, B.COD_PROVINCIA, B.COD_CIUDAD, B.COD_COMUNA, C.COD_USUARIO, E.COD_ZONAIMPO
          INTO :szhCodRegion, :szhCodProvincia,:szhCodCiudad, :szhCodComuna, :lhCodUsuario, :ihCodZonaImpAbon
          FROM GE_DIRECCIONES B ,GA_DIRECUSUAR C, GA_ABOCEL D, GE_ZONACIUDAD E
         WHERE D.NUM_ABONADO      = :lhNumAbonado
           AND C.COD_USUARIO      = D.COD_USUARIO
           AND C.COD_TIPDIRECCION = :szhCodTipDirec
           AND C.COD_DIRECCION    = B.COD_DIRECCION
           AND E.COD_REGION       = B.COD_REGION
           AND E.COD_PROVINCIA    = B.COD_PROVINCIA
           AND E.COD_CIUDAD       = B.COD_CIUDAD;

    if (SQLCODE)
    {
       iDError (szExeName,ERR000,vInsertarIncidencia,"Open=> Dir Usuario Abonado",
                 szfnORAerror ());
       return FALSE;
    }
    else
    {
        strcpy (szCodRegion , szhCodRegion  );
        strcpy (szCodProvincia  , szhCodProvincia);
        strcpy (szCodCiudad , szhCodCiudad  );
        strcpy (szCodComuna , szhCodComuna  );
        *lCodUsuario=lhCodUsuario;
        *iCodZonaImpAbon= ihCodZonaImpAbon;
    }

    return (TRUE);

}/*************************** Final bfnGetDirAbonado ****************************/



/*****************************************************************************/
/*                           funcion : bfnGetDirOfiVend                      */
/*    Obtiene la region, provinci y ciudad de la oficina pasada              */
/*****************************************************************************/
BOOL bfnGetDirOfiVend (long lCodVendedor, char *szCodOficina )
{

    EXEC SQL BEGIN DECLARE SECTION;
        static long  lhCodVendedor;
        static char  szhCodOficina   [3]; EXEC SQL VAR szhCodOficina   IS STRING(3) ;
    EXEC SQL END DECLARE SECTION;

    lhCodVendedor=lCodVendedor;

    EXEC SQL
        SELECT  COD_OFICINA
          INTO  :szhCodOficina
          FROM  VE_VENDEDORES
         WHERE  COD_VENDEDOR = :lhCodVendedor;

    if (SQLCODE)
        return FALSE;

    strcpy(szCodOficina,szhCodOficina);

    return (TRUE);

}/************************** Final bfnGetDirOfiVend **************************/


/** Desde aqui impuesto Maicao **/
/*
 * Funcion      : bfnProcImptoMaicao
 * Descripcion  : Funcion de procesamiento impuesto Maicao.
 */
BOOL bfnProcImptoMaicao(int iTipoFact, char *pszFecZonaImp)
{

    char    *modulo            = "bfnProcImptoMaicao";
    int     iCodGrpServi      = 0;
    register int i          = 0;
    register int j          = 0;
    int     iNumRegistros   = 0;
    int     iNumConcRev     = 0;
    double  dSumConcNetos   = 0.0;
    long    *lConcRevisados = NULL;
    BOOL    bExisteConc     = FALSE;
    BOOL    bRebajaConcepto = FALSE;
    BOOL    bConcVigente    = FALSE;

    GRPSERCONC     stGrpSerConc;
    COD_IMPTODCTOS stCodZonas;

    vDTrazasLog  (modulo,"\n\t** Dentro de la funcion bfnProcImptoMaicao() **"
                         "\n\t** iTipoFact     [%d] **"
                         "\n\t** pszFecZonaImp [%s] **"
                        ,LOG05
                        ,iTipoFact
                        ,pszFecZonaImp);


    memset (&stGrpSerConc,0,sizeof(GRPSERCONC));
    memset (&stCodZonas  ,0,sizeof(COD_IMPTODCTOS));


    /* Sumar Conceptos netos */
    dSumConcNetos = dfnSumarConceptosNetos();

    vDTrazasLog  (modulo,"\n\t** (bfnProcImptoMaicao) stPreFactura.iNumRegistros :[%d] **"
                        , LOG06
                        , stPreFactura.iNumRegistros);

    iNumRegistros = stPreFactura.iNumRegistros;

    /* Recorrer la estructura stPreFactura */
    for(i=0; i < iNumRegistros; i++)
    {
        if (stPreFactura.A_PFactura[i].dImpConcepto > 0.0)
        {
            vDTrazasLog  (modulo,"\n\t** (bfnProcImptoMaicao) En for(i)-stPreFactura, i:[%d], CodCliente:[%ld] **"
                                , LOG06, i
                                , stCliente.lCodCliente);

            /* Obtener codigos de zona para su validacion posterior */
            if(!bfnCargarCodigosZona(&stCodZonas, pszFecZonaImp, stPreFactura.A_PFactura[i].lNumAbonado, iTipoFact))
            {
                vDTrazasLog  (modulo, "\n\t\t* En funcion bfnCargarCodigosZona().", LOG01);
                vDTrazasError(modulo, "\n\t\t* En funcion bfnCargarCodigosZona().", LOG01);
                return FALSE;
            }

            /* Obtencion del codigo de grupo de servicio del concepto */
            if (!bGetGrupoServicios (stPreFactura.A_PFactura[i].iCodConcepto, &iCodGrpServi,pszFecZonaImp,iTipoFact))
            {
                vDTrazasLog  (modulo, "\n\t\t* No se encuentra Codigo de grupo de servicio.", LOG01);
                vDTrazasError(modulo, "\n\t\t* No se encuentra Codigo de grupo de servicio.", LOG01);
                return FALSE;
            }
            /* Busqueda del grupo de servicio en la estructura de impuestos a los documentos */
            j=0;
            while(j < pstImptoDctos.iNumImptosDctos)
            {
                vDTrazasLog  (modulo, "\n\t\t* (bfnProcImptoMaicao) Dentro de while(j)..."
                                      "\n\t\t* j                                         :[%d] "
                                      "\n\t\t* pstImptoDctos.stImptoDcto[j].lCodGprservi :[%ld] "
                                      "\n\t\t* (long)iCodGrpServi                        :[%ld] "
                                    , LOG06
                                    , j
                                    , pstImptoDctos.stImptoDcto[j].lCodGprservi
                                    , (long)iCodGrpServi);

                bExisteConc  = bfnExisteConcRev(pstImptoDctos.stImptoDcto[j].lCodConcepto,lConcRevisados, iNumConcRev);
                bConcVigente = bfnVerificarVigConc(pstImptoDctos.stImptoDcto[j], pszFecZonaImp);

                vDTrazasLog  (modulo, "\n\t\t* bExisteConc  :[%d]"
                                      "\n\t\t* bConcVigente :[%d]"
                                    , LOG06
                                    , bExisteConc
                                    , bConcVigente);

                /* Es el codigo de grupo de servicio de impuesto igual al de concepto de prefactura ? */
                /* y ademas el concepto de impuesto no esta entre los ya generados?                   */
                /* y el concepto de impuestos esta vigente? */
                if( (pstImptoDctos.stImptoDcto[j].lCodGprservi == (long)iCodGrpServi)
                        && (bExisteConc  == FALSE)
                        && (bConcVigente == TRUE ) )
                {
                    /* De acuerdo al tipo de facturacion que se este realizando    */
                    /* Se comprueba validacion de rebaja total de concepto para NC */
                    if(iTipoFact == FACT_NOTACRED || iTipoFact == FACT_NOTADEBI)
                        bRebajaConcepto = bfnValidarRebImptosDctos(pstImptoDctos.stImptoDcto[j], pszFecZonaImp);
                    else
                        bRebajaConcepto = TRUE;

                    /* Validar internamente direcciones y, en el caso de NC rebaja total del concepto */
                    /* XO-200607241178 FAAR 20060725 Se agrega validación de iCodCatImpos */
                    if( bfnValidarZonaDeCargo(pstImptoDctos.stImptoDcto[j], stCodZonas) &&
                                              pstImptoDctos.stImptoDcto[j].iCodCatImpos == stCliente.iCodCatImpos &&
                                              bRebajaConcepto == TRUE)
                    {
                        /* generar Impuesto al documento */
                        bfnGenerarImptoAlDcto(iTipoFact, pstImptoDctos.stImptoDcto[j], stCodZonas, dSumConcNetos);
                        /* Marcar este concepto como revisado */
                        iNumConcRev++;
                        lConcRevisados = (long*) realloc (lConcRevisados, iNumConcRev * sizeof(long));
                        if (lConcRevisados == NULL)
                        {
                            vDTrazasLog  (modulo, "\n\t\t* Al asignar memoria para conceptos revisados.", LOG01);
                            vDTrazasError(modulo, "\n\t\t* Al asignar memoria para conceptos revisados.", LOG01);
                        }
                        lConcRevisados[iNumConcRev-1] = pstImptoDctos.stImptoDcto[j].lCodConcepto;

                        /* Ir al siguiente concepto de impuestos de la estructura*/
                        vDTrazasLog  (modulo,"\n\t** j antes de entrar a funcion ifnBuscarSgteConceptoImpto()  :[%d] **",LOG06,j);
                        j = ifnBuscarSgteConceptoImpto(j);
                        vDTrazasLog  (modulo,"\n\t** j despues de entrar a funcion ifnBuscarSgteConceptoImpto():[%d] **",LOG06,j);

                    }
                    else
                    {
                        /* Avanzar al siguiente registro */
                        j++;
                    }

                }
                else
                {
                    /* Avanzar al siguiente registro */
                    j++;
                }

            }/* fin while(j < pstImptoDctos.iNumImptosDctos) */

        }/* fin for(i=0;i<stPreFactura.iNumRegistros;i++) */
    }

    free(lConcRevisados);
    vDTrazasLog  (modulo,"\n\t** Saliendo de la funcion bfnProcImptoMaicao() **",LOG05);

    return TRUE;

}

/*
 * Funcion      : bfnValidarZonaDeCargo
 * Descripcion  : Realizar validacion de datos para verificar si se debe generar un impuesto al documento.
 */
BOOL bfnValidarZonaDeCargo(IMPTODCTO stImptoDcto, COD_IMPTODCTOS stCodZonas)
{

    char    *modulo = "bfnValidarZonaDeCargo";

    vDTrazasLog  (modulo,"\n\t** Dentro de la funcion [%s] **",LOG05, modulo);

    vDTrazasLog  (modulo,"\n\t** Parametros de comparacion :      **"
                         "\n\t** stImptoDcto.iTipZonacargo  : [%d]**"
                         "\n\t** stImptoDcto.iTipEvaluacion : [%d]**"
                         "\n\t** stImptoDcto.szCodZonacargo:  [%s]**"
                         "\n\t** stImptoDcto.szCodRegion    : [%s]**"
                         "\n\t** stImptoDcto.szCodProvincia : [%s]**"
                        ,LOG06
                        ,stImptoDcto.iTipZonacargo
                        ,stImptoDcto.iTipEvaluacion
                        ,stImptoDcto.szCodZonacargo
                        ,stImptoDcto.szCodRegion
                        ,stImptoDcto.szCodProvincia);


    /* Tipo de zona de cargo: zona impositiva de la direccion */
    if(stImptoDcto.iTipZonacargo == giCodZonaImpDir)
    {
        /* Ninguna validacion */
        if( stImptoDcto.iTipEvaluacion== giNoEvaluar )
            return TRUE;

        /* Validacion de cliente y abonado */
        if( stImptoDcto.iTipEvaluacion == giEvalClieAbon)
        {
            if( (stCodZonas.iCodZonaImpCliente == atoi(stImptoDcto.szCodZonacargo))
                    && (stCodZonas.iCodZonaImpAbon == atoi(stImptoDcto.szCodZonacargo)) )
                return TRUE;
        }
        /* Validacion de cliente */
        else if( stImptoDcto.iTipEvaluacion == giEvalCliente)
        {
            if( stCodZonas.iCodZonaImpCliente == atoi(stImptoDcto.szCodZonacargo) )
                return TRUE;

        }
        /* Validacion de abonado */
        else if( stImptoDcto.iTipEvaluacion == giEvalAbonado )
        {
            if( stCodZonas.iCodZonaImpAbon == atoi(stImptoDcto.szCodZonacargo))
                return TRUE;
        }
    }
    /* Tipo de zona de cargo: Codigo de provincia */
    else if( stImptoDcto.iTipZonacargo == giCodProvincia)
    {
        /* Ninguna validacion */
        if( stImptoDcto.iTipEvaluacion == giNoEvaluar)
            return TRUE;

        /* Validacion de cliente y abonado */
        if( stImptoDcto.iTipEvaluacion == giEvalClieAbon )
        {
            if( !strcmp(stCodZonas.szCodProvCliente,stImptoDcto.szCodZonacargo)
                    && !strcmp(stCodZonas.szCodProvAbon, stImptoDcto.szCodZonacargo)
                    && !strcmp(stCodZonas.szCodRegionCliente,stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodRegionAbon, stImptoDcto.szCodRegion))
                return TRUE;
        }
        /* Validacion de cliente */
        else if( stImptoDcto.iTipEvaluacion == giEvalCliente )
        {
            if( !strcmp(stCodZonas.szCodProvCliente,stImptoDcto.szCodZonacargo)
                    && !strcmp(stCodZonas.szCodRegionCliente,stImptoDcto.szCodRegion) )
                return TRUE;
        }
        /* Validacion de abonado */
        else if( stImptoDcto.iTipEvaluacion == giEvalAbonado )
        {
            if( !strcmp(stCodZonas.szCodProvAbon, stImptoDcto.szCodZonacargo)
                    && !strcmp(stCodZonas.szCodRegionAbon, stImptoDcto.szCodRegion))
                return TRUE;
        }
    }
    /* Tipo de zona de cargo: Codigo de region */
    else if( stImptoDcto.iTipZonacargo == giCodRegion)
    {
        /* Ninguna validacion */
        if( stImptoDcto.iTipEvaluacion == giNoEvaluar)
            return TRUE;

        /* Validacion de cliente y abonado */
        if( stImptoDcto.iTipEvaluacion == giEvalClieAbon)
        {
            if( !strcmp(stCodZonas.szCodRegionCliente,stImptoDcto.szCodZonacargo)
                    && !strcmp(stCodZonas.szCodRegionAbon, stImptoDcto.szCodZonacargo) )
                return TRUE;
        }
        /* Validacion de cliente */
        else if( stImptoDcto.iTipEvaluacion == giEvalCliente)
        {
            if( !strcmp(stCodZonas.szCodRegionCliente,stImptoDcto.szCodZonacargo) )
                return TRUE;

        }
        /* Validacion de abonado */
        else if( stImptoDcto.iTipEvaluacion == giEvalAbonado)
        {
            if( !strcmp(stCodZonas.szCodRegionAbon, stImptoDcto.szCodZonacargo))
                return TRUE;
        }
    }
    /* Tipo de zona de cargo: Codigo de Ciudad */
    else if( stImptoDcto.iTipZonacargo == giCodCiudad)
    {
        /* Ninguna validacion */
        if( stImptoDcto.iTipEvaluacion == giNoEvaluar)
            return TRUE;

        /* Validacion de cliente y abonado */
        if( stImptoDcto.iTipEvaluacion == giEvalClieAbon)
        {
            if( !strcmp(stCodZonas.szCodCiudadCliente,stImptoDcto.szCodZonacargo)
                    && !strcmp(stCodZonas.szCodCiudadAbon, stImptoDcto.szCodZonacargo)
                    &&!strcmp(stCodZonas.szCodRegionCliente,stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodRegionAbon, stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodProvCliente,stImptoDcto.szCodProvincia)
                    && !strcmp(stCodZonas.szCodProvAbon,  stImptoDcto.szCodProvincia) )
                return TRUE;
        }
        /* Validacion de cliente */
        else if( stImptoDcto.iTipEvaluacion == giEvalCliente )
        {
            if( !strcmp(stCodZonas.szCodCiudadCliente,stImptoDcto.szCodZonacargo)
                    &&!strcmp(stCodZonas.szCodRegionCliente,stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodProvCliente,stImptoDcto.szCodProvincia) )
                return TRUE;
        }
        /* Validacion de abonado */
        else if( stImptoDcto.iTipEvaluacion == giEvalAbonado)
        {
            if( !strcmp(stCodZonas.szCodCiudadAbon, stImptoDcto.szCodZonacargo)
                    &&!strcmp(stCodZonas.szCodRegionAbon,stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodProvAbon,stImptoDcto.szCodProvincia) )
                return TRUE;
        }
    }
    /* Tipo de zona de cargo: Codigo de Comuna */
    else if( stImptoDcto.iTipZonacargo == giCodComuna)
    {
        /* Ninguna validacion */
        if( stImptoDcto.iTipEvaluacion == giNoEvaluar)
            return TRUE;

        /* Validacion de cliente y abonado */
        if( stImptoDcto.iTipEvaluacion == giEvalClieAbon)
        {
            if( !strcmp(stCodZonas.szCodComunaCliente,stImptoDcto.szCodZonacargo)
                    && !strcmp(stCodZonas.szCodComunaAbon, stImptoDcto.szCodZonacargo)
                    &&!strcmp(stCodZonas.szCodRegionCliente,stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodRegionAbon, stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodProvCliente,stImptoDcto.szCodProvincia)
                    && !strcmp(stCodZonas.szCodProvAbon,  stImptoDcto.szCodProvincia) )
                return TRUE;
        }
        /* Validacion de cliente */
        else if( stImptoDcto.iTipEvaluacion == giEvalCliente )
        {
            if( !strcmp(stCodZonas.szCodComunaCliente,stImptoDcto.szCodZonacargo)
                    &&!strcmp(stCodZonas.szCodRegionCliente,stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodProvCliente,stImptoDcto.szCodProvincia) )
                return TRUE;

        }
        /* Validacion de abonado */
        else if( stImptoDcto.iTipEvaluacion == giEvalAbonado)
        {
            if( !strcmp(stCodZonas.szCodComunaAbon, stImptoDcto.szCodZonacargo)
                    &&!strcmp(stCodZonas.szCodRegionAbon,stImptoDcto.szCodRegion)
                    && !strcmp(stCodZonas.szCodProvAbon,stImptoDcto.szCodProvincia) )
                return TRUE;

        }
    }

    /* El valor por defecto es FALSE */
    return FALSE;
}

/*
 * Funcion      : bfnGenerarImptoAlDcto
 * Descripcion  : Generacion del impuesto al documento
 */
BOOL bfnGenerarImptoAlDcto(int iTipoFact, IMPTODCTO stImptoDcto, COD_IMPTODCTOS stCodZonas, double dSumConcNetos)
{
    char *modulo = "bfnGenerarImptoAlDcto";
    int  iIdxNew = 0;
    CONCEPTO stConcepto;

    vDTrazasLog  (modulo,"\n\t** Dentro de la funcion [%s] **",LOG05, modulo);

    iIdxNew = stPreFactura.iNumRegistros;

    stPreFactura.A_PFactura[iIdxNew].iCodConcepto = (int)stImptoDcto.lCodConcepto;

    memset (&stConcepto,0,sizeof(CONCEPTO))                   ;

    if (!bFindConcepto (stPreFactura.A_PFactura[iIdxNew].iCodConcepto, &stConcepto))
    {
        vDTrazasLog (szExeName, "\n\t\t* No se encuentra detalle de concepto de Impto Dcto ", LOG01);
        return FALSE;
    }
    strcpy(stPreFactura.A_PFactura[iIdxNew].szDesConcepto, stConcepto.szDesConcepto);


    if (!bGetMaxColPreFa
            (stPreFactura.A_PFactura[iIdxNew].iCodConcepto,
            &stPreFactura.A_PFactura[iIdxNew].lColumna ))
        return FALSE;


    stPreFactura.A_PFactura[iIdxNew].bOptImpuesto = FALSE;
    stPreFactura.A_PFactura[iIdxNew].lNumProceso  = stPreFactura.A_PFactura[0].lNumProceso;
    stPreFactura.A_PFactura[iIdxNew].lCodCliente  = stPreFactura.A_PFactura[0].lCodCliente;
    stPreFactura.A_PFactura[iIdxNew].iCodProducto = 1;

    strcpy(stPreFactura.A_PFactura[iIdxNew].szCodMoneda , stPreFactura.A_PFactura[0].szCodMoneda) ;

    vDTrazasLog  (modulo,"\n\t** stImptoDcto.szTipValor     [%s] **"
                         "\n\t** stImptoDcto.dImpfacturable [%f] **"
                         "\n\t** dSumConcNetos              [%f] **"
                        ,LOG06
                        ,stImptoDcto.szTipValor
                        ,stImptoDcto.dImpfacturable
                        ,dSumConcNetos);

    switch(stImptoDcto.szTipValor[0])
    {
        case 'M':
            stPreFactura.A_PFactura[iIdxNew].dImpConcepto    = stImptoDcto.dImpfacturable ;
            stPreFactura.A_PFactura[iIdxNew].dImpFacturable  = fnCnvDouble(stImptoDcto.dImpfacturable, 0) ;
            break;

        case 'P':
            stPreFactura.A_PFactura[iIdxNew].dImpConcepto    = (stImptoDcto.dImpfacturable/100) * dSumConcNetos;
            stPreFactura.A_PFactura[iIdxNew].dImpFacturable  = fnCnvDouble(((stImptoDcto.dImpfacturable/100) * dSumConcNetos), 0);
            break;

        default:
            /* Por defecto se asume monto (M)*/
            stPreFactura.A_PFactura[iIdxNew].dImpConcepto    = stImptoDcto.dImpfacturable ;
            stPreFactura.A_PFactura[iIdxNew].dImpFacturable  = fnCnvDouble(stImptoDcto.dImpfacturable,0) ;
            break;

    }

    switch (iTipoFact)
    {
        case FACT_CICLO      :
        case FACT_BAJA       :
            strcpy (stPreFactura.A_PFactura[iIdxNew].szFecValor ,
                    stCiclo.szFecEmision);
            break;
        case FACT_CONTADO    :
        case FACT_COMPRA     :
        case FACT_MISCELAN   :
        case FACT_LIQUIDACION:
        case FACT_RENTAPHONE :
        case FACT_ROAMINGVIS :
            strcpy (stPreFactura.A_PFactura[iIdxNew].szFecValor,
                    szSysDate);
            break;
        case FACT_NOTACRED   :
        case FACT_NOTADEBI   :
            strcpy (stPreFactura.A_PFactura[iIdxNew].szFecValor,
                    stNota.szFecEmision);
            break;
        default              :
            break;
    }

    strcpy(stPreFactura.A_PFactura[iIdxNew].szFecEfectividad, szSysDate);
    
    /* 38937 PPV 30/03/2007 Se pasa el codigo de ciudad del cliente */
    if (strlen(stCodZonas.szCodCiudadCliente)==0) strcpy (stCodZonas.szCodCiudadCliente,stCliente.szCodCiudad);


    strcpy (stPreFactura.A_PFactura[iIdxNew].szCodCiudad      , stCodZonas.szCodCiudadCliente);
    strcpy (stPreFactura.A_PFactura[iIdxNew].szCodRegion     , stCodZonas.szCodRegionCliente);
    strcpy (stPreFactura.A_PFactura[iIdxNew].szCodProvincia, stCodZonas.szCodProvCliente);
    strcpy (stPreFactura.A_PFactura[iIdxNew].szCodCuota        , "0") ;

    strcpy(stPreFactura.A_PFactura[iIdxNew].szCodModulo , "FA");
    stPreFactura.A_PFactura[iIdxNew].iIndFactur   = 1;   /* FACTURABLE;  */

    stPreFactura.A_PFactura[iIdxNew].iIndEstado   = EST_NORMAL;
    stPreFactura.A_PFactura[iIdxNew].iCodTipConce = IMPUESTO  ;
    stPreFactura.A_PFactura[iIdxNew].lNumUnidades = 1;
    stPreFactura.A_Ind[iIdxNew].i_lCodCiclFact    = (stCiclo.lCodCiclFact == ORA_NULL)?ORA_NULL:SQLOK;
    stPreFactura.A_PFactura[iIdxNew].iCodConceRel = 0;
    stPreFactura.A_PFactura[iIdxNew].lColumnaRel  = 0;
    stPreFactura.A_PFactura[iIdxNew].lNumAbonado  = 0;
    stPreFactura.A_Ind[iIdxNew].i_lNumAbonado     = 0;
    stPreFactura.A_Ind[iIdxNew].i_szNumTerminal   = -1;
    stPreFactura.A_Ind[iIdxNew].i_lCapCode        = -1;
    stPreFactura.A_Ind[iIdxNew].i_szNumSerieMec   = -1;
    stPreFactura.A_Ind[iIdxNew].i_szNumSerieLe    = -1;
    stPreFactura.A_PFactura[iIdxNew].iFlagImpues   = 0  ;
    stPreFactura.A_PFactura[iIdxNew].iFlagDto      = 0  ;
    stPreFactura.A_PFactura[iIdxNew].iFlagDto      = 0  ;
    stPreFactura.A_PFactura[iIdxNew].dValDto       = -1 ;
    stPreFactura.A_Ind[iIdxNew].i_dValDto          = -1 ;
    stPreFactura.A_PFactura[iIdxNew].iTipDto       = -1 ;
    stPreFactura.A_Ind[iIdxNew].i_iTipDto          = -1 ;
    stPreFactura.A_PFactura[iIdxNew].lNumVenta     = stVenta.lNumVenta;
    stPreFactura.A_Ind[iIdxNew].i_lNumVenta        = (stVenta.lNumVenta == ORA_NULL)?-1:0;

    stPreFactura.A_PFactura[iIdxNew].lNumTransaccion = -1;
    stPreFactura.A_Ind[iIdxNew].i_lNumTransaccion  = -1;
    stPreFactura.A_PFactura[iIdxNew].iMesGarantia  = 0;
    stPreFactura.A_PFactura[iIdxNew].iIndAlta      = 1;
    stPreFactura.A_PFactura[iIdxNew].iIndSuperTel  = 0;
    stPreFactura.A_PFactura[iIdxNew].iNumPaquete   =-1;
    stPreFactura.A_Ind[iIdxNew].i_iNumPaquete      =-1;
    stPreFactura.A_PFactura[iIdxNew].iIndCuota     = 0;
    stPreFactura.A_PFactura[iIdxNew].iNumCuotas    = 0;
    stPreFactura.A_PFactura[iIdxNew].iOrdCuota     = 0;

    stPreFactura.A_PFactura[iIdxNew].dhImpConversion =  stPreFactura.A_PFactura[0].dhImpConversion;

    strcpy(stPreFactura.A_PFactura[iIdxNew].szhCodMonedaImp , stPreFactura.A_PFactura[0].szhCodMonedaImp);

    /* stPreFactura.iNumRegistros++; */
    if(bfnIncrementarIndicePreFactura()==FALSE)
    {
        vDTrazasLog  (szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        vDTrazasError(szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        return FALSE;
    }


    vDTrazasLog  (modulo,"\n\t** Saliendo de la funcion [%s] **",LOG05, modulo);

    return(TRUE);

}


/*
 * Funcion      : bfnCargarCodigosZona
 * Descripcion  : Cargar los codigos necesarios para la posterior  utilizacion en validacion de zonas en Maicao.
 */
BOOL bfnCargarCodigosZona(COD_IMPTODCTOS *pstCodZonas, char *pszFecZonaImpo,long lNumAbonado, int iTipoFact)
{
    char    *modulo = "vfnCargarCodigosZona";
    char    szCodRegion   [4];
    char    szCodProvincia[6];
    char    szCodCiudad   [6];
    char    szCodComuna   [6];
    int     iCodZonaImp;
    long    lCodUsuario;


    vDTrazasLog  (modulo,"\n\t** Dentro de la funcion [%s] **",LOG05, modulo);

    /* Cargar Codigos de zona impositiva de cliente y abonado */
    if (bGetZonaImpositiva(stCliente.szCodRegion   ,
                           stCliente.szCodProvincia,
                           stCliente.szCodCiudad   ,
                           &iCodZonaImp, pszFecZonaImpo, iTipoFact))
    {
        vDTrazasLog  (modulo,"\n\t** => Cod Zona Imp. Cliente: [%d] **",LOG05,iCodZonaImp);
        pstCodZonas->iCodZonaImpCliente = iCodZonaImp;
    }
    else
    {
        vDTrazasError(modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
        vDTrazasLog  (modulo,"\n\t** En Zona impositiva del cliente  **",LOG01);
        return FALSE;
    }

    /* Obtencion de los codigos de region, provincia y ciudad */
    strcpy(pstCodZonas->szCodRegionCliente,stCliente.szCodRegion   );
    strcpy(pstCodZonas->szCodProvCliente  ,stCliente.szCodProvincia);
    strcpy(pstCodZonas->szCodCiudadCliente,stCliente.szCodCiudad   );
    strcpy(pstCodZonas->szCodComunaCliente,stCliente.szCodComuna   );

    if(lNumAbonado > 0L)
    {
        /* 20060606: Se carga en esta funcion el codigo de zona impositiva del abonado */
        if(iTipoFact!=FACT_NOTACRED)/*CO-200608310357 FPH I, si es Nota de Credito no rescate la zonaimpositiva*/
        {
            if (!bfnGetDirAbonado (lNumAbonado,szCodRegion, szCodProvincia, szCodCiudad, szCodComuna, &lCodUsuario, &iCodZonaImp))
            {
            vDTrazasError(modulo,"\n\t** En obtencion codigos de direccion del abonado  **",LOG01);
            vDTrazasLog  (modulo,"\n\t** En obtencion codigos de direccion del abonado  **",LOG01);
            return FALSE;
            }
        }/*CO-200608310357 FPH F*/
        strcpy(pstCodZonas->szCodRegionAbon,szCodRegion   );
        strcpy(pstCodZonas->szCodProvAbon  ,szCodProvincia);
        strcpy(pstCodZonas->szCodCiudadAbon,szCodCiudad   );
        strcpy(pstCodZonas->szCodComunaAbon,szCodComuna   );
        pstCodZonas->iCodZonaImpAbon = iCodZonaImp;
    }
    else
    {
        /* Si es abonado cero, se utiliza codigo de zona impositiva del cliente */
        pstCodZonas->iCodZonaImpAbon = pstCodZonas->iCodZonaImpCliente;

        /* Si es abonado cero, se utiliza direccion del cliente */
        strcpy(pstCodZonas->szCodRegionAbon,stCliente.szCodRegion   );
        strcpy(pstCodZonas->szCodProvAbon  ,stCliente.szCodProvincia);
        strcpy(pstCodZonas->szCodCiudadAbon,stCliente.szCodCiudad   );
        strcpy(pstCodZonas->szCodComunaAbon,stCliente.szCodComuna   );
    }

    /* Imprimir codigos de zona cargados */
    vDTrazasLog  (modulo,"\n\t** Valores Cargados de zonas para abonado [%ld]: **"
                         "\n\t** pstCodZonas->iCodZonaImpCliente [%d]"
                         "\n\t** pstCodZonas->iCodZonaImpAbon    [%d]"
                         "\n\t** pstCodZonas->szCodProvCliente   [%s]"
                         "\n\t** pstCodZonas->szCodProvAbon      [%s]"
                         "\n\t** pstCodZonas->szCodRegionCliente [%s]"
                         "\n\t** pstCodZonas->szCodRegionAbon    [%s]"
                         "\n\t** pstCodZonas->szCodCiudadCliente [%s]"
                         "\n\t** pstCodZonas->szCodCiudadAbon    [%s]"
                         "\n\t** pstCodZonas->szCodComunaCliente [%s]"
                         "\n\t** pstCodZonas->szCodComunaAbon    [%s]"
                        , LOG06
                        , lNumAbonado
                        , pstCodZonas->iCodZonaImpCliente
                        , pstCodZonas->iCodZonaImpAbon
                        , pstCodZonas->szCodProvCliente
                        , pstCodZonas->szCodProvAbon
                        , pstCodZonas->szCodRegionCliente
                        , pstCodZonas->szCodRegionAbon
                        , pstCodZonas->szCodCiudadCliente
                        , pstCodZonas->szCodCiudadAbon
                        , pstCodZonas->szCodComunaCliente
                        , pstCodZonas->szCodComunaAbon);

    vDTrazasLog  (modulo,"\n\t** Saliendo de la funcion [%s] **",LOG05, modulo);

    return TRUE;
}

/*
 * Funcion      : dfnSumarConceptosNetos
 * Descripcion  : Sumar conceptos de cargo y conceptos de descuentos.
 */
double dfnSumarConceptosNetos(void)
{
    register int i    = 0;
    double dSumaNetos = 0.0;

    for(i=0;i<stPreFactura.iNumRegistros;i++)
    {
        if(stPreFactura.A_PFactura[i].iCodTipConce== ARTICULO || stPreFactura.A_PFactura[i].iCodTipConce== DESCUENTO)
            dSumaNetos += stPreFactura.A_PFactura[i].dImpFacturable;

    }

    return dSumaNetos;

}

/*
 * Funcion      : ifnBuscarSgteConceptoImpto
 * Descripcion  : Buscar el siguiente concepto de impuesto en la estructura de impuestos.
 */
int ifnBuscarSgteConceptoImpto(int iPosRegImptoDctos)
{
    register int i = 0;

    for(i=iPosRegImptoDctos;i<pstImptoDctos.iNumImptosDctos-1;i++)
    {
        if(pstImptoDctos.stImptoDcto[i+1].lCodConcepto != pstImptoDctos.stImptoDcto[i].lCodConcepto)
            return i+1;
    }

    /* Se ha llegado al final de la estructura sin encontrar un concepto distinto */
    return i+1;

}


/*
 * Funcion      : bfnValidarRebImptosDctos
 * Descripcion  : Validar si el impuesto al documento ingresado por parametro
 *                esta rebajado en su totalidad.
 */
BOOL bfnValidarRebImptosDctos(IMPTODCTO stImptoDcto, char *pszFecZonaImp)
{
    EXEC SQL BEGIN  DECLARE SECTION;
    char     szhPrefPlaza      [26];    EXEC SQL VAR szhPrefPlaza     IS STRING(26);
    char     szhCodTipDocum    [3] ;    EXEC SQL VAR szhCodTipDocum   IS STRING(3) ;
    long     lhCodCliente      =0L ;
    long     lhNumFolio        =0L ;
    char     szhFecha          [15];    EXEC SQL VAR szhFecha         IS STRING(15);

    long    lhCodConceptoImpto =0L ;
    char    szhCodZonaCargo    [11];    EXEC SQL VAR szhCodZonaCargo  IS STRING(11);
    int     ihTipZonaCargo     =0  ;
    int     ihTipEvaluacion    =0  ;

    long     dhNumRegs         =0.0;
    EXEC SQL END    DECLARE SECTION;

    char    *modulo = "bfnValidarRebImptosDctos";


    vDTrazasLog  (modulo,"\n\t** Dentro de la funcion [%s] **"
                         "\n\t** pszFecZonaImp       :[%s]"
                        , LOG05
                        , modulo
                        , pszFecZonaImp);

    strcpy(szhFecha, pszFecZonaImp);

    strcpy(szhPrefPlaza  , stNota.szPrefPlaza);
    sprintf(szhCodTipDocum,"%d", stNota.iCodTipDocum);

    lhNumFolio        = stNota.lNumFolio;
    lhCodCliente      = stNota.lCodCliente;

    lhCodConceptoImpto     = stImptoDcto.lCodConcepto    ;
    strcpy(szhCodZonaCargo  ,stImptoDcto.szCodZonacargo) ;
    ihTipZonaCargo         = stImptoDcto.iTipZonacargo   ;
    ihTipEvaluacion        = stImptoDcto.iTipEvaluacion  ;


    EXEC SQL
        SELECT nvl (sum(A.IMP_CONCEPTO) - sum(A.IMP_FACTURABLE), 0.0)
        INTO :dhNumRegs
        FROM FA_AJUSTECONC A
        WHERE A.PREF_PLAZA   = :szhPrefPlaza
          AND A.NUM_FOLIO    = :lhNumFolio
          AND A.COD_CLIENTE  = :lhCodCliente
          AND A.COD_TIPDOCUM = :szhCodTipDocum
          AND A.IMP_CONCEPTO <> A.IMP_FACTURABLE
          AND EXISTS (SELECT 1
                      FROM FA_GRPSERCONC B
                      WHERE B.COD_CONCEPTO = A.COD_CONCEPTO
                        AND B.FEC_DESDE <=TO_DATE (:szhFecha,'YYYYMMDDHH24MISS')
                        AND B.FEC_HASTA >=TO_DATE (:szhFecha,'YYYYMMDDHH24MISS')
                        AND EXISTS (SELECT 1
                                    FROM FA_IMPTODCTOS_TD C
                                    WHERE B.COD_GRPSERVI   = C.COD_GRPSERVI
                                      AND C.COD_CONCEPTO   = :lhCodConceptoImpto
                                      AND C.COD_ZONACARGO  = :szhCodZonaCargo
                                      AND C.TIP_ZONACARGO  = :ihTipZonaCargo
                                      AND C.TIP_EVALUACION = :ihTipEvaluacion
                                      AND C.FEC_DESDE      <= to_date (:szhFecha, 'YYYYMMDDHH24MISS')
                                      AND C.FEC_HASTA      >= to_date (:szhFecha, 'YYYYMMDDHH24MISS')));

    if(SQLCODE!=SQLOK)
    {
        vDTrazasLog  (modulo,"\n\t** Error en SELECT, sqlcode: [%d] **",LOG01, sqlca.sqlcode);
        vDTrazasError(modulo,"\n\t** Error en SELECT, sqlcode: [%d] **",LOG01, sqlca.sqlcode);
        return FALSE;

    }
    if(SQLCODE==SQLNOTFOUND)
    {
        vDTrazasLog  (modulo,"\n\t** Saliendo de la funcion [%s]\n\t** Diferencia No Encontrada **",LOG05, modulo);
        return TRUE;
    }

    vDTrazasLog  (modulo,"\n\t** Saliendo de la funcion [%s]\n\t** dhNumRegs :[%f] **",LOG05, modulo, dhNumRegs);

    if(dhNumRegs == 0.0)
        return TRUE;
    else
        return FALSE;

}
/*
 * Funcion      : bfnExisteConcRev
 * Descripcion  : Validar si existe el concepto ingresado por parametro <lCodConcepto> en <plConceptos>.
 */
BOOL bfnExisteConcRev(long lCodConcepto, long *plConceptos, int iNumConc)
{
    int i=0;

    for(i=0;i<iNumConc;i++)
    {
        if(lCodConcepto == plConceptos[i])
            return TRUE;
    }

    /* Si no lo encuentra, retorna FALSE */
    return FALSE;
}

/*
 * Funcion      : bfnVerificarVigConc
 * Descripcion  : Validar si el impuesto al documento esta vigente de acuerdo a la fecha de emision.
 */
BOOL bfnVerificarVigConc(IMPTODCTO stImptoDcto, char *pszFecZonaImp)
{
    char    szFecEmision[9] = "";

    strncpy(szFecEmision, pszFecZonaImp,8); /* Rescatar solo YYYYMMDD */
    szFecEmision[8] = '\0';

    if(strcmp(szFecEmision, stImptoDcto.szFecDesde)>=0 && strcmp(szFecEmision, stImptoDcto.szFecHasta)<=0 )
        return TRUE;
    else
        return FALSE;
}
/** Hasta aqui impuesto Maicao **/

BOOL bImptosDocto (int iTipoFact, char *szFecZonaImpo, int iCodZonaImpos)
{
    char  modulo[] = "bImptosDocto";

    int      iInd              = 0 ;
    long     i, lIndConc, lNumAbonado_ant  = 0L;
    int      iNImptos          = 0 ;
    int      iCodZonaAbon      = 0 ;
    int      iCodZonaAbon_Ant  = -1;
    int      iCodZonaImp       = 0;
    int      iCodGrpServi      = 0 ;
    long     lCodUsuario       = 0 ;
    long     lCodUsuario_Ant   = -1;
    char     szCodRegion    [4]= "";
    char     szCodProvincia [6]= "";
    char     szCodCiudad    [6]= "";
    char     szCodComuna    [6]= "";
    IMPTOS   stImpto = {0,(IMPUESTOS *)NULL};
    double   dMtoImpuesto, dMtoBase = 0.0;
    double   dMtoImpuestoAux = 0.0;
    double   dMtoBaseAux = 0.0;
    

    strcpy (stAnomProceso.szDesProceso, "Impuestos Doctos");

    vDTrazasLog (szExeName,"\n\t\t* Impuestos con rango por Documentos", LOG04);

    /*********************************************************/
    if (strlen (szFecZonaImpo) == 0)
    {
        iDError (modulo,ERR040,vInsertarIncidencia);
        return FALSE;
    }

    /* *************************************************** */
    if (!bGetImpuestosDocto (stCliente.iCodCatImpos, iCodZonaImpos,
                             szFecZonaImpo,&stImpto, iTipoFact))
    {
        vFreeImpuestos(&stImpto);
        return FALSE;
    }

    vDTrazasLog (modulo, "\n\t\t* Aplica Impuesto Documento"
                         "\n\t\t=> Cat. Impositiva    [%d]"
                         "\n\t\t=> Zona Impositiva    [%d]"
                         "\n\t\t=> Fecha Zona Imp.    [%s]"
                         "\n\t\t=> Numero de Impuestos[%d]"
                       , LOG05, stCliente.iCodCatImpos
                       , iCodZonaImpos, szFecZonaImpo
                       , stImpto.iNumImpuestos);

		

    for (iInd=0;iInd<stImpto.iNumImpuestos;iInd++)
    {
        dMtoImpuesto = 0.0;
        dMtoBase = 0.0;
        for (i=0;i < stPreFactura.iNumRegistros ;i++)
        {
            if (stPreFactura.A_PFactura[i].iCodTipConce  == ARTICULO ||
                stPreFactura.A_PFactura[i].iCodTipConce  == DESCUENTO )
            {
                if (!bGetGrupoServicios (stPreFactura.A_PFactura[i].iCodConcepto,
                                         &iCodGrpServi, szFecZonaImpo,iTipoFact))
                {
                     return FALSE; // error el concepto no tiene asociado grupo
                }
                
                if (stImpto.pImpuestos [iInd].iCodGrpServi != iCodGrpServi)
                {
                    /* no aplica al concepto */
                    continue;
                }
                
               /* if (iTipoFact == FACT_MISCELAN || 
                    stPreFactura.A_PFactura[i].lNumAbonado == 0 || 
                    stPreFactura.A_PFactura[i].lNumAbonado == -1)
                {
                    iCodZonaAbon = iCodZonaImpos; // asume zona del cliente
                }
                else
                {
                    if (stImpto.pImpuestos [iInd].iCodZonaAbon != 0 )
                    {
                        // obtiene zona impositiva abonado
                        if (stPreFactura.A_PFactura[i].lNumAbonado != lNumAbonado_ant  )
                        {
                            if (!bfnGetDirAbonado (stPreFactura.A_PFactura[i].lNumAbonado,
                                                   szCodRegion, szCodProvincia, szCodCiudad, 
                                                   szCodComuna, &lCodUsuario, &iCodZonaImp))
                            {
                                return FALSE; // error no se encontro direccion
                            }
                            else
                            {
                                lNumAbonado_ant = stPreFactura.A_PFactura[i].lNumAbonado;
                                
                                if (lCodUsuario_Ant==lCodUsuario)
                                {
                                    iCodZonaAbon=iCodZonaAbon_Ant;
                                }
                                else 
                                {                        
                                    if (!bGetZonaImpositiva (szCodRegion   ,
                                                             szCodProvincia,
                                                             szCodCiudad   ,
                                                             &iCodZonaAbon, 
                                                             szFecZonaImpo, iTipoFact))
                                    {
                                        vDTrazasError(modulo,"\n\t** No se puede obtener Zona Impositiva Abonado **",LOG01);
                                        vDTrazasLog  (modulo,"\n\t** No se puede obtener Zona Impositiva Abonado **",LOG01);
                                        return FALSE;
                                    }
                                    else
                                    {
                                        iCodZonaAbon_Ant=iCodZonaAbon;
                                    }*if encuentra zonaAbon*
                                    lCodUsuario_Ant=lCodUsuario;
                                }
                            } * if encuentra direccion de Abonado                        
                        }
                        else 
                        {
                            * if cod usuario es igual al anterior, asume zona anterior sino busca nuevamente 
                            * Obtiene  la zona impositiva del abonado 
                            iCodZonaAbon=iCodZonaAbon_Ant;               
                        }
                        if (stImpto.pImpuestos [iInd].iCodZonaAbon != iCodZonaAbon )
                            continue;  * no aplica el impuesto *
                    }
                } *fact miscelanea*
    */
	            if (stPreFactura.A_PFactura[i].iCodZonaAbon == -1)
                    iCodZonaAbon = stNota.iCodZonaImpo;
                else
                    /* Se considera para los conceptos con abonado 0 la zona impositiva del Cliente. */
                    /* iCodZonaAbon = stPreFactura.A_PFactura.iCodZonaAbon[i]; */
                    if (stPreFactura.A_PFactura[i].lNumAbonado  == 0 && stPreFactura.A_PFactura[i].iCodZonaAbon == 0)
                       iCodZonaAbon = stNota.iCodZonaImpo;
                    else
                       iCodZonaAbon = stPreFactura.A_PFactura[i].iCodZonaAbon;
    
                vDTrazasLog (modulo, "\t\t* Cod.ZonaAbon [%d] ",LOG06, iCodZonaAbon);
                if (stImpto.pImpuestos [iInd].iCodZonaAbon != iCodZonaAbon )
                    continue;  /* no es afecto al impuesto */
					
                if (!bCalculaMtoImptoDocto (i,stImpto.pImpuestos[iInd]
                                           , &dMtoImpuesto, &dMtoBase ))
                {
                    vFreeImpuestos(&stImpto);
                    return FALSE;
                }
    
                vDTrazasLog (modulo, "\n\t\t SUMATORIA IMPUESTOS DOCTOS\n"
                                       "\t\t ========================== \n"
                                       "\t\t (i)                 => [%d]\n"
                                       "\t\t dImpFacturable (i)  => [%f]\n"
                                       "\t\t dImpConcepto (i)    => [%f]\n"                                       
                                       "\t\t Mto. Impuesto       => [%f]\n"
                                       "\t\t Mto. Base           => [%f]\n"
                                   , LOG06, i                                
                                   , stPreFactura.A_PFactura[i].dImpFacturable
                                   , stPreFactura.A_PFactura[i].dImpConcepto    
                                   , dMtoImpuesto, dMtoBase );
								
								
                lIndConc = i; // guarda el ultimo concepto afecto
    
            }/* fin if Imptos y Carrier */
        }/* fin for stPreFactura */
        
        dMtoImpuestoAux += dMtoImpuesto;
        dMtoBaseAux +=dMtoBase;
    
/* PGG - 176704 - 19-10-2011 - DESDE AQUI
        if (dMtoImpuesto >= stImpto.pImpuestos[iInd].dImpUmbral )
        {
            // generacion de concepto de impuesto  
            if (!bfnAplicaImptoDocto( &stImpto.pImpuestos[iInd], lIndConc 
                                    , iTipoFact, dMtoImpuesto, dMtoBase))
            {
                vDTrazasError(modulo,"\n\t** ERROR, en creacion del concepto de Impto. **",LOG01);
                vFreeImpuestos(&stImpto);
                return (FALSE);
            }
            iNImptos++;
        }
 PGG - 176704 - 19-10-2011 - HASTA AQUI */
    }/* fin for Impuestos */
		
		if (stImpto.iNumImpuestos > 0)
		{
	    if (dMtoImpuestoAux >= stImpto.pImpuestos[0].dImpUmbral )
	    {
	        // generacion de concepto de impuesto  
	        if (!bfnAplicaImptoDocto( &stImpto.pImpuestos[0], lIndConc 
	                                , iTipoFact, dMtoImpuestoAux, dMtoBaseAux))
	        {
	            vDTrazasError(modulo,"\n\t** ERROR, en creacion del concepto de Impto. **",LOG01);
	            vFreeImpuestos(&stImpto);
	            return (FALSE);
	        }
	        iNImptos++;
	    }
		}
        

    vDTrazasLog (modulo, "\t\tNro de Impuestos aplicados al Documento %d\n"
                       , LOG04, iNImptos);

    vFreeImpuestos(&stImpto);

    iNImptosT += iNImptos;

 return TRUE;
}/*************************** Final bImptosDocto *****************************/
BOOL bImptosDoctoUmbral (int iTipoFact, char *szFecZonaImpo, int iCodZonaImpos, ACUMABONADOS *pAcumAbonados)
{
    char  modulo[] = "bImptosDoctoUmbral";

    int      iInd              = 0 ;
    long     i, lIndConc, lNumAbonado_ant  = 0L;
	long     lNumAbonado_ant2  = 0L;
    int      iNImptos          = 0 ;
    int      iCodZonaAbon      = 0 ;
    int      iCodZonaAbon_Ant  = -1;
    int      iCodZonaImp       = 0;
    int      iCodGrpServi      = 0 ;
    long     lCodUsuario       = 0 ;
    long     lCodUsuario_Ant   = -1;
    char     szCodRegion    [4]= "";
    char     szCodProvincia [6]= "";
    char     szCodCiudad    [6]= "";
    char     szCodComuna    [6]= "";
    IMPTOS   stImpto = {0,(IMPUESTOS *)NULL};
    double   dMtoImpuesto, dMtoBase = 0.0, dMtoFacturable=0.0;
    double   dMtoImpuestoAux = 0.0;
    double   dMtoBaseAux = 0.0;
	int      iPos = -1;
    int      r = 0;
	
	vDTrazasLog (szExeName,"\n\t\t* Impuestos con rango por Documentos", LOG04);
	
	ACUMIMPUESTOABONADOS   stImptoAcum  = {0,(ACUMIMPUESTO *)NULL};; /*P-CSR-12019*/

    strcpy (stAnomProceso.szDesProceso, "Impuestos Doctos");
    /*********************************************************/
    if (strlen (szFecZonaImpo) == 0)
    {
        iDError (modulo,ERR040,vInsertarIncidencia);
        return FALSE;
    }

    /* *************************************************** */
    if (!bGetImpuestosDocto (stCliente.iCodCatImpos, iCodZonaImpos,
                             szFecZonaImpo,&stImpto, iTipoFact))
    {
        vFreeImpuestos(&stImpto);
        return FALSE;
    }

    vDTrazasLog (modulo, "\n\t\t* Aplica Impuesto Documento"
                         "\n\t\t=> Cat. Impositiva    [%d]"
                         "\n\t\t=> Zona Impositiva    [%d]"
                         "\n\t\t=> Fecha Zona Imp.    [%s]"
                         "\n\t\t=> Numero de Impuestos[%d]"
                       , LOG05, stCliente.iCodCatImpos
                       , iCodZonaImpos, szFecZonaImpo
                       , stImpto.iNumImpuestos);

		
 
    for (iInd=0;iInd<stImpto.iNumImpuestos;iInd++)
    {


        for (i=0;i < stPreFactura.iNumRegistros ;i++)
        {
		    /*P-CSR-12019*/
           dMtoImpuesto = 0.0;
           dMtoBase = 0.0;
	       dMtoFacturable = 0.0;
		 //	vDTrazasLog  (modulo,"\n\t**bImptosDoctoUmbral  Abonado actual %ld, abonado anterior %ld **",LOG05, stPreFactura.A_PFactura[i].lNumAbonado , lNumAbonado_ant2 );
		    if (stPreFactura.A_PFactura[i].lNumAbonado != lNumAbonado_ant2  )
            {   
			   iPos=-1;
	    	//    vDTrazasLog  (modulo,"\n\t**bImptosDoctoUmbral  Cantidad de abonados acumulados a recorrer %ld **",LOG05, pAcumAbonados->iNumAbonados  );
     			for (r=0;r<pAcumAbonados->iNumAbonados ; r++)
			   {    //vDTrazasLog  (modulo,"\n\t**bImptosDoctoUmbral  buscando abonado %ld en abonado (indice  %ld) **",LOG05,
			                    //  stPreFactura.A_PFactura[i].lNumAbonado , pAcumAbonados->stAcumAbonado[r].lNumAbonado, r  );
			       if (stPreFactura.A_PFactura[i].lNumAbonado == pAcumAbonados->stAcumAbonado[r].lNumAbonado)
				   {
				      iPos = r;
					  break;
				   } 
			   }
			   lNumAbonado_ant2 = stPreFactura.A_PFactura[i].lNumAbonado ;
			}
		 	if (iPos == -1 )
			{  
			   
		//	   vDTrazasError(modulo,"\n\t** No se encontro el monto total del abonado requerido para calcular impuestos. Abonado[%ld]**",LOG01,stPreFactura.A_PFactura[i].lNumAbonado);
               vDTrazasLog  (modulo,"\n\t** No se encontro el monto total del abonado requerido para calcular impuestos. Abonado[%ld]. Se evalua siguiente abonado**",LOG01,stPreFactura.A_PFactura[i].lNumAbonado);
			   continue;
		//	   return FALSE;
		 	}
			/*FIN P-CSR-12019*/
			 
            if (stPreFactura.A_PFactura[i].iCodTipConce  == ARTICULO ||
                stPreFactura.A_PFactura[i].iCodTipConce  == DESCUENTO )
            {
                if (!bGetGrupoServicios (stPreFactura.A_PFactura[i].iCodConcepto,
                                         &iCodGrpServi, szFecZonaImpo,iTipoFact))
                {
                     return FALSE; // error el concepto no tiene asociado grupo
                }
 
                if (stImpto.pImpuestos [iInd].iCodGrpServi != iCodGrpServi)
                {
                    /* no aplica al concepto */
                    continue;
                }
                if (iTipoFact == FACT_MISCELAN || 
                    stPreFactura.A_PFactura[i].lNumAbonado == 0 || 
                    stPreFactura.A_PFactura[i].lNumAbonado == -1)
                {
                    iCodZonaAbon = iCodZonaImpos; // asume zona del cliente
                }
                else
                {
                    if (stImpto.pImpuestos [iInd].iCodZonaAbon != 0 )
                    {
                        // obtiene zona impositiva abonado
                        if (stPreFactura.A_PFactura[i].lNumAbonado != lNumAbonado_ant  )
                        {
                            if (!bfnGetDirAbonado (stPreFactura.A_PFactura[i].lNumAbonado,
                                                   szCodRegion, szCodProvincia, szCodCiudad, 
                                                   szCodComuna, &lCodUsuario, &iCodZonaImp))
                            {
                                return FALSE; // error no se encontro direccion
                            }
                            else
                            {
                                lNumAbonado_ant = stPreFactura.A_PFactura[i].lNumAbonado;
                                
                                if (lCodUsuario_Ant==lCodUsuario)
                                {
                                    iCodZonaAbon=iCodZonaAbon_Ant;
                                }
                                else 
                                {                        
                                    if (!bGetZonaImpositiva (szCodRegion   ,
                                                             szCodProvincia,
                                                             szCodCiudad   ,
                                                             &iCodZonaAbon, 
                                                             szFecZonaImpo, iTipoFact))
                                    {
                                        vDTrazasError(modulo,"\n\t** No se puede obtener Zona Impositiva Abonado **",LOG01);
                                        vDTrazasLog  (modulo,"\n\t** No se puede obtener Zona Impositiva Abonado **",LOG01);
                                        return FALSE;
                                    }
                                    else
                                    {
                                        iCodZonaAbon_Ant=iCodZonaAbon;
                                    }/*if encuentra zonaAbon*/
                                    lCodUsuario_Ant=lCodUsuario;
                                }
                            } /* if encuentra direccion de Abonado */                        
                        }
                        else 
                        {
                            /* if cod usuario es igual al anterior, asume zona anterior sino busca nuevamente */
                            /* Obtiene  la zona impositiva del abonado */
                            iCodZonaAbon=iCodZonaAbon_Ant;               
                        }
                        if (stImpto.pImpuestos [iInd].iCodZonaAbon != iCodZonaAbon )
                            continue;  /* no aplica el impuesto */
                    }
                } /*fact miscelanea*/
               if (stPreFactura.A_PFactura[i].iCodTipConce  != DESCUENTO){
							   
				   if (!bCalculaMtoImptoDoctoUmbral (i,
				                                     stPreFactura.A_PFactura[i].dImpConcepto,
				                                     stPreFactura.A_PFactura[i].szCodMoneda,
				                                     stImpto.pImpuestos[iInd] ,
													  stPreFactura.A_PFactura[i].lNumAbonado, 
													  &stImptoAcum, &pAcumAbonados->stAcumAbonado[iPos], /*P-CSR-12019*/
												&dMtoImpuesto, &dMtoBase, &dMtoFacturable  ))
					{
						vFreeImpuestos(&stImpto);
					   return FALSE;
					}
					if (!bfnAplicaImptoDocto2( &stImpto.pImpuestos[iInd], i 
	                                , iTipoFact, dMtoImpuesto, dMtoBase, dMtoFacturable))
	               {
	                  vDTrazasError(modulo,"\n\t** ERROR, en creacion del concepto de Impto. **",LOG01);
	                  vFreeImpuestos(&stImpto);
	                  return (FALSE);
	               }
				}
    
                vDTrazasLog (modulo, "\n\t\t SUMATORIA IMPUESTOS DOCTOS\n"
                                       "\t\t ========================== \n"
                                       "\t\t (i)                 => [%d]\n"
                                       "\t\t dImpFacturable (i)  => [%f]\n"
                                       "\t\t dImpConcepto (i)    => [%f]\n"                                       
                                       "\t\t Mto. Impuesto       => [%f]\n"
                                       "\t\t Mto. Base           => [%f]\n"
                                   , LOG06, i                                
                                   , stPreFactura.A_PFactura[i].dImpFacturable
                                   , stPreFactura.A_PFactura[i].dImpConcepto    
                                   , dMtoImpuesto, dMtoBase );


                lIndConc = i; // guarda el ultimo concepto afecto
                iNImptos++;
            }/* fin if Imptos y Carrier */
        }/* fin for stPreFactura */
        
        dMtoImpuestoAux += dMtoImpuesto;
        dMtoBaseAux +=dMtoBase;
    
    }/* fin for Impuestos */

    vDTrazasLog (modulo, "\t\tNro de Impuestos aplicados al Documento %d\n"
                       , LOG04, iNImptos);

    vFreeImpuestos(&stImpto);

    iNImptosT += iNImptos;

 return TRUE;
}/*************************** Final bImptosDocto *****************************/


BOOL bGetImpuestosAll (int iCodCatImpos, int  iCodZonaImpo, char *szFecVenc ,int iCodZonaAbon, int iCodGrpServi,
                         IMPTOS* pImpto  , int  iTipoFact)
{
    int  iCount    = 0   ;
    int  iNumImpto = 0   ;
    BOOL bRes      = TRUE;

    EXEC SQL BEGIN DECLARE SECTION;
         static int   ihCodCatImpos  ;
         static int   ihCodZonaImpo  ;
         static int   ihCodZonaAbon  ;
         static int   ihCodTipImpues ;
         static int   ihCodGrpServi  ;
         static char* szhFecVencimie ; EXEC SQL VAR szhFecVencimie IS STRING(15);
         static int   ihCodConcGene  ;
         static float fhPrcImpuesto  ;
         static int   ihTipMonto     ;
         static double dhImpUmbral   ;
         static double dhImpMaximo   ;
         static int   ihCodTipImptDcto;
		 static int   ihCodTipImpue;
    EXEC SQL END DECLARE SECTION;

    vDTrazasLog (szExeName, "\n\t\t* Parametros entrada bGetImpuestosAll "
                            "\n\t\t=> Cod.CatImpos   [%d]"
                            "\n\t\t=> Cod.ZonaImpos  [%d]"
                            "\n\t\t=> Fec.emision.  [%s]"
							"\n\t\t=> Zona Abon  [%d]"
							"\n\t\t=> Cod.Grupo Servi  [%d]"
                          , LOG05, iCodCatImpos, iCodZonaImpo, szFecVenc, iCodZonaAbon,iCodGrpServi);

    if (iTipoFact == FACT_CICLO)
    {
 
        while (bRes && iCount<NUM_IMPUESTOS)
        {
 
		    if (pstImpuestos[iCount].iCodCatImpos == iCodCatImpos       &&
                   pstImpuestos[iCount].iCodGrpServi == iCodGrpServi       &&
                  (pstImpuestos[iCount].iCodZonaImpo == iCodZonaImpo ||
                   pstImpuestos[iCount].iCodZonaImpo == 0                ) &&
                  (pstImpuestos[iCount].iCodZonaAbon == iCodZonaAbon ||
                   pstImpuestos[iCount].iCodZonaAbon == 0                ) &&
                  (strcmp (pstImpuestos[iCount].szFecDesde,szFecVenc)<= 0) &&
                  (strcmp (pstImpuestos[iCount].szFecHasta,szFecVenc)>= 0) &&
                  pstImpuestos[iCount].fPrcImpuesto  != 0.0    )           
                 // pstImpuestos[iCount].iCodTipImpues != pstFadParam.iCodTipImptoDocto 
            {
 
                if ((pImpto->pImpuestos =
                  (IMPUESTOS*)realloc((IMPUESTOS*)pImpto->pImpuestos,
                  (iNumImpto+1)*sizeof(IMPUESTOS)))==(IMPUESTOS*)NULL)
                {
                    iDError (szExeName,ERR005,vInsertarIncidencia,"bGetImpuesto->pImpto");
                    strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria"
                                                      , strlen(stAnomProceso.szObsAnomalia));
                    bRes = FALSE;
                }
                else
                {
                    memcpy (&pImpto->pImpuestos[iNumImpto],&pstImpuestos[iCount],sizeof(IMPUESTOS));
                    iNumImpto++;
                }
            }  
            iCount++;
        }/* fin While NUM_IMPUESTOS */
    }
    else
    {  
       ihCodCatImpos = iCodCatImpos ;
       ihCodZonaImpo = iCodZonaImpo ;
       szhFecVencimie= szFecVenc    ;
       ihCodTipImptDcto = pstFadParam.iCodTipImptoDocto;

       EXEC SQL DECLARE Cur_Impuestos_dcto CURSOR FOR
            SELECT /*+ index (GE_IMPUESTOS PK_GE_IMPUESTOS) */
                   I.COD_CONCGENE                          ,
                   I.PRC_IMPUESTO,
                   I.COD_ZONAABON,
                   I.COD_GRPSERVI,
                   T.TIP_MONTO,
				   I.COD_TIPIMPUES,
                   NVL(T.IMP_UMBRAL,0), 
                   NVL(T.IMP_MAXIMO,0)
            FROM   GE_IMPUESTOS I, GE_TIPIMPUES T
            WHERE  I.COD_TIPIMPUES= T.COD_TIPIMPUE
              AND  I.COD_CATIMPOS = :ihCodCatImpos
              AND  I.COD_ZONAIMPO = DECODE(I.COD_ZONAIMPO,0,0,:ihCodZonaImpo)
              AND  I.FEC_DESDE   <= TO_DATE (:szhFecVencimie,'YYYYMMDDHH24MISS')
              AND  I.FEC_HASTA   >= TO_DATE (:szhFecVencimie,'YYYYMMDDHH24MISS')
              AND  I.PRC_IMPUESTO != 0.0 
			  AND   I.COD_GRPSERVI = :iCodGrpServi
			  AND   I.COD_ZONAABON  = :iCodZonaAbon
             // AND  T.COD_TIPIMPUE = :ihCodTipImptDcto   /*  IMPUESTOS DOCUMENTO*/
            ORDER BY COD_CONCGENE,PRC_IMPUESTO;

      EXEC SQL OPEN Cur_Impuestos_dcto;

      if (SQLCODE != SQLOK &&  SQLCODE != SQLNOTFOUND)
      {
          iDError (szExeName,ERR000,vInsertarIncidencia,"Open->Ge_Impuestos",
                   szfnORAerror());
          bRes = FALSE;
      }
      iNumImpto = 0;
      while (bRes && SQLCODE == SQLOK)
      {
             EXEC SQL 
             FETCH Cur_Impuestos_dcto 
              INTO :ihCodConcGene,
                   :fhPrcImpuesto,
                   :ihCodZonaAbon,
                   :ihCodGrpServi,
                   :ihTipMonto   ,
				   :ihCodTipImpue,
                   :dhImpUmbral  ,
                   :dhImpMaximo;
                                               
             if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
             {
                 iDError (szExeName,ERR000,vInsertarIncidencia
                         , "Fetch->Ge_Impuestos",szfnORAerror());
             }
                
             if (SQLCODE == SQLOK)
             {
                 if ((pImpto->pImpuestos =
                    (IMPUESTOS *)realloc( (IMPUESTOS *)pImpto->pImpuestos,
                    (iNumImpto+1)*sizeof(IMPUESTOS) ) ) == (IMPUESTOS *)NULL)
                 {
                     iDError (szExeName,ERR005,vInsertarIncidencia,"bGetImpuesto->pImpto");
                     strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria",
                                                           strlen(stAnomProceso.szObsAnomalia));
                     bRes = FALSE;
                 }
                 else
                 {
                      pImpto->pImpuestos[iNumImpto].iCodConcGene =ihCodConcGene;
                      pImpto->pImpuestos[iNumImpto].iCodCatImpos =ihCodCatImpos;
                      pImpto->pImpuestos[iNumImpto].iCodZonaImpo =ihCodZonaImpo;
                      pImpto->pImpuestos[iNumImpto].iCodZonaAbon =ihCodZonaAbon;
                      pImpto->pImpuestos[iNumImpto].iCodTipImpues=ihCodTipImpue;
                      pImpto->pImpuestos[iNumImpto].fPrcImpuesto =fhPrcImpuesto;
                      pImpto->pImpuestos[iNumImpto].iCodGrpServi =ihCodGrpServi;
                      pImpto->pImpuestos[iNumImpto].iTipMonto    =ihTipMonto;
                      pImpto->pImpuestos[iNumImpto].dImpUmbral   =dhImpUmbral;
                      pImpto->pImpuestos[iNumImpto].dImpMaximo   =dhImpMaximo;

                      iNumImpto++;
                 }
             }/* fin SQLCODE == SQLOK */
      }/* While sqlcode == sqlok */
      
      if (bRes && SQLCODE != SQLNOTFOUND)
      {
          bRes = FALSE;
      }
      else
      {
         EXEC SQL CLOSE Cur_Impuestos_dcto;
         if (SQLCODE)
         {
             iDError (szExeName,ERR000,vInsertarIncidencia
                               , "Close->Ge_Impuestos",szfnORAerror());
             bRes = FALSE;
         }
      }
   }
    
   if (bRes)
   {
       pImpto->iNumImpuestos = iNumImpto;
       vPrintImpuestos (pImpto)         ;
   }
   
   return (bRes);
}
/*****************************************************************************/
/*  funcion : bGetImpuestosDocto                                             */
/* -Busca en memoria pstImpuesto  (global al modulo) los impuestos para una  */
/*  un mismo iCodCatImpos, iCodZonaimpos, Fecha                              */
/*  y los carga en IMPTOS                                                    */
/* -Valores de Retorno : Error->FALSE, !Error->TRUE                          */
/*****************************************************************************/
BOOL bGetImpuestosDocto (int iCodCatImpos, int  iCodZonaImpo, char *szFecVenc ,
                         IMPTOS* pImpto  , int  iTipoFact)
{
    int  iCount    = 0   ;
    int  iNumImpto = 0   ;
    BOOL bRes      = TRUE;

    EXEC SQL BEGIN DECLARE SECTION;
         static int   ihCodCatImpos  ;
         static int   ihCodZonaImpo  ;
         static int   ihCodZonaAbon  ;
         static int   ihCodTipImpues ;
         static int   ihCodGrpServi  ;
         static char* szhFecVencimie ; EXEC SQL VAR szhFecVencimie IS STRING(15);
         static int   ihCodConcGene  ;
         static float fhPrcImpuesto  ;
         static int   ihTipMonto     ;
         static double dhImpUmbral   ;
         static double dhImpMaximo   ;
         static int   ihCodTipImptDcto;
    EXEC SQL END DECLARE SECTION;

    vDTrazasLog (szExeName, "\n\t\t* Parametros entrada Ge_Impuestos Documentos"
                            "\n\t\t=> Cod.CatImpos   [%d]"
                            "\n\t\t=> Cod.ZonaImpos  [%d]"
                            "\n\t\t=> Fec.Vencimie.  [%s]"
                          , LOG05, iCodCatImpos, iCodZonaImpo, szFecVenc);

    if (iTipoFact == FACT_CICLO)
    {
 
        while (bRes && iCount<NUM_IMPUESTOS)
        {

            if (pstImpuestos[iCount].iCodCatImpos == iCodCatImpos &&
                (pstImpuestos[iCount].iCodZonaImpo == iCodZonaImpo ||
                 pstImpuestos[iCount].iCodZonaImpo == 0 ) &&
                (strcmp (pstImpuestos[iCount].szFecDesde,szFecVenc)<= 0) &&
                (strcmp (pstImpuestos[iCount].szFecHasta,szFecVenc)>= 0) &&
                  pstImpuestos[iCount].fPrcImpuesto  != 0.0              &&
                  pstImpuestos[iCount].iCodTipImpues == pstFadParam.iCodTipImptoDocto /* impuesto al documento */
                )
            {
 
                if ((pImpto->pImpuestos =
                  (IMPUESTOS*)realloc((IMPUESTOS*)pImpto->pImpuestos,
                  (iNumImpto+1)*sizeof(IMPUESTOS)))==(IMPUESTOS*)NULL)
                {
                    iDError (szExeName,ERR005,vInsertarIncidencia,"bGetImpuesto->pImpto");
                    strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria"
                                                      , strlen(stAnomProceso.szObsAnomalia));
                    bRes = FALSE;
                }
                else
                {
                    memcpy (&pImpto->pImpuestos[iNumImpto],&pstImpuestos[iCount],sizeof(IMPUESTOS));
                    iNumImpto++;
                }
            }  
            iCount++;
        }/* fin While NUM_IMPUESTOS */
    }
    else
    {  
       ihCodCatImpos = iCodCatImpos ;
       ihCodZonaImpo = iCodZonaImpo ;
       szhFecVencimie= szFecVenc    ;
       ihCodTipImptDcto = pstFadParam.iCodTipImptoDocto;

       EXEC SQL DECLARE Cur_Impuestos_dcto2 CURSOR FOR
            SELECT /*+ index (GE_IMPUESTOS PK_GE_IMPUESTOS) */
                   I.COD_CONCGENE                          ,
                   I.PRC_IMPUESTO,
                   I.COD_ZONAABON,
                   I.COD_GRPSERVI,
                   T.TIP_MONTO,
                   T.IMP_UMBRAL, 
                   T.IMP_MAXIMO
            FROM   GE_IMPUESTOS I, GE_TIPIMPUES T
            WHERE  I.COD_TIPIMPUES= T.COD_TIPIMPUE
              AND  I.COD_CATIMPOS = :ihCodCatImpos
              AND  I.COD_ZONAIMPO = DECODE(I.COD_ZONAIMPO,0,0,:ihCodZonaImpo)
              AND  I.FEC_DESDE   <= TO_DATE (:szhFecVencimie,'YYYYMMDDHH24MISS')
              AND  I.FEC_HASTA   >= TO_DATE (:szhFecVencimie,'YYYYMMDDHH24MISS')
              AND  I.PRC_IMPUESTO != 0.0 
              AND  T.COD_TIPIMPUE = :ihCodTipImptDcto   /*  IMPUESTOS DOCUMENTO*/
            ORDER BY COD_CONCGENE,PRC_IMPUESTO;

      EXEC SQL OPEN Cur_Impuestos_dcto2;

      if (SQLCODE != SQLOK &&  SQLCODE != SQLNOTFOUND)
      {
          iDError (szExeName,ERR000,vInsertarIncidencia,"Open->Ge_Impuestos",
                   szfnORAerror());
          bRes = FALSE;
      }
      iNumImpto = 0;
      while (bRes && SQLCODE == SQLOK)
      {
             EXEC SQL 
             FETCH Cur_Impuestos_dcto2 
              INTO :ihCodConcGene,
                   :fhPrcImpuesto,
                   :ihCodZonaAbon,
                   :ihCodGrpServi,
                   :ihTipMonto   ,
                   :dhImpUmbral  ,
                   :dhImpMaximo;
                                               
             if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
             {
                 iDError (szExeName,ERR000,vInsertarIncidencia
                         , "Fetch->Ge_Impuestos",szfnORAerror());
             }
                
             if (SQLCODE == SQLOK)
             {
                 if ((pImpto->pImpuestos =
                    (IMPUESTOS *)realloc( (IMPUESTOS *)pImpto->pImpuestos,
                    (iNumImpto+1)*sizeof(IMPUESTOS) ) ) == (IMPUESTOS *)NULL)
                 {
                     iDError (szExeName,ERR005,vInsertarIncidencia,"bGetImpuesto->pImpto");
                     strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria",
                                                           strlen(stAnomProceso.szObsAnomalia));
                     bRes = FALSE;
                 }
                 else
                 {
                      pImpto->pImpuestos[iNumImpto].iCodConcGene =ihCodConcGene;
                      pImpto->pImpuestos[iNumImpto].iCodCatImpos =ihCodCatImpos;
                      pImpto->pImpuestos[iNumImpto].iCodZonaImpo =ihCodZonaImpo;
                      pImpto->pImpuestos[iNumImpto].iCodZonaAbon =ihCodZonaAbon;
                      pImpto->pImpuestos[iNumImpto].iCodTipImpues=ihCodTipImpues;
                      pImpto->pImpuestos[iNumImpto].fPrcImpuesto =fhPrcImpuesto;
                      pImpto->pImpuestos[iNumImpto].iCodGrpServi =ihCodGrpServi;
                      pImpto->pImpuestos[iNumImpto].iTipMonto    =ihTipMonto;
                      pImpto->pImpuestos[iNumImpto].dImpUmbral   =dhImpUmbral;
                      pImpto->pImpuestos[iNumImpto].dImpMaximo   =dhImpMaximo;

                      iNumImpto++;
                 }
             }/* fin SQLCODE == SQLOK */
      }/* While sqlcode == sqlok */
      
      if (bRes && SQLCODE != SQLNOTFOUND)
      {
          bRes = FALSE;
      }
      else
      {
         EXEC SQL CLOSE Cur_Impuestos_dcto2;
         if (SQLCODE)
         {
             iDError (szExeName,ERR000,vInsertarIncidencia
                               , "Close->Ge_Impuestos",szfnORAerror());
             bRes = FALSE;
         }
      }
   }
    
   if (bRes)
   {
       pImpto->iNumImpuestos = iNumImpto;
       vPrintImpuestos (pImpto)         ;
   }
   
   return (bRes);
}/************************** Final bGetImpuestos *****************************/

/*P-CSR-12019*/
/* GCASTRO - se agrega psnIndOrdenTotal como parametro - 200069 - 24-10-2013 */ 
BOOL bEsNotaCreditoTotal (long plNumProceso,
                          long plNumFolio,
                          char *psPrefPlaza,
                          char *psnIndOrdenTotal,
                          int *iEsNotaTotal,
						  BOOL *bDocOrigenCiclo)     // monto acumulado base
{
    EXEC SQL BEGIN DECLARE SECTION;
        static double dTotalConcPrefactura;
		static long   lCantConcPrefactura;
		static double   dTotalConcDocOrig;
		static long    lCantConcDocOrig;
		static long   lNumFolio;
		static long    lIndOrdenTotalOrig ;
		static long    lNumProceso;
		static char    sPrefPlaza[26]; EXEC SQL VAR sPrefPlaza    IS STRING(26);
	    static char    szhcod_ciclfact[10];  EXEC SQL VAR szhcod_ciclfact    IS STRING(10);
		static char    szNomTabla[50]  ; EXEC SQL VAR szNomTabla    IS STRING(50);
		static char    szOrigen[3]  ; EXEC SQL VAR szOrigen    IS STRING(3);
		long lIndOrdenTotalDocOrig; /* GCASTRO - 200069 - 24-10-2013 */ 
	EXEC SQL END DECLARE SECTION  ;
    static char    szSql[4096]=""  ;
	
	lCantConcPrefactura = 0;
	dTotalConcPrefactura = 0.0;
	lNumProceso = plNumProceso;
	vDTrazasLog (szExeName, "\n\t\t En funcion bEsNotaCreditoTotal. "  
                          "\n\t\t Parametros recibidos: Num Proceso[%d] " 
                          "\n\t\t Num Folio[%d] " 
                          "\n\t\t psPrefPlaza[%s] " 
                          "\n\t\t psnIndOrdenTotal[%s] " 
                          , LOG05,plNumProceso,  plNumFolio,  psPrefPlaza, psnIndOrdenTotal);

   //totalizar montos de la NC
    
    EXEC SQL
     SELECT  SUM(IMP_FACTURABLE), Count(1)
	   INTO  :dTotalConcPrefactura, :lCantConcPrefactura
	   FROM  FA_PREFACTURA
	   WHERE num_proceso = :lNumProceso;

    if (SQLCODE)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error Suma Total Prefactura",szfnORAerror ());
        vDTrazasError(szExeName,"\n\t**  Error Suma Total Prefactura **"
                             "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (FALSE);
    }
	vDTrazasLog (szExeName, "\n\tbEsNotaCreditoTotal - TotalConcPrefactura[%f]", LOG05, dTotalConcPrefactura);
	
	memset(sPrefPlaza,0,sizeof(sPrefPlaza));
	strcpy(sPrefPlaza,psPrefPlaza);
	lNumFolio = plNumFolio;
	lIndOrdenTotalDocOrig=atol(psnIndOrdenTotal); /* GCASTRO - 200069 - 24-10-2013 */  
	//Determinar si es un documento original ciclo o no ciclo
	
      /* GCASTRO - Se grega lIndOrdenTotalDocOrig en la sentecia SQL - 200069 - 24-10-2013 */ 
      EXEC SQL 
      SELECT  'C' , a.cod_ciclfact, a.ind_ordentotal, b.FA_HISTCONC 
      INTO     :szOrigen, :szhcod_ciclfact, :lIndOrdenTotalOrig, :szNomTabla
       FROM fa_histdocu a, fa_enlacehist b, fa_ajustes c
       WHERE a.ind_ordentotal= :lIndOrdenTotalDocOrig
	   	 AND a.num_folio = :lNumFolio
       AND a.pref_plaza = :sPrefPlaza
       AND a.cod_ciclfact = b.cod_ciclfact
       AND  a.num_folio =  c.num_folio
       AND  a.cod_cliente = c.cod_cliente
       AND  a.cod_tipdocum = c.cod_tipdocum                     
       UNION
       SELECT  'NC', cod_ciclfact, ind_ordentotal, 'FA_FACTCONC_NOCICLO'
       FROM fa_factdocu_nociclo a, fa_ajustes c 
       WHERE a.ind_ordentotal= :lIndOrdenTotalDocOrig
	     AND  a.num_folio = :lNumFolio
       AND a.pref_plaza = :sPrefPlaza
       AND  a.num_folio =  c.num_folio
       AND  a.cod_cliente = c.cod_cliente
       AND  a.cod_tipdocum = c.cod_tipdocum ;

 
    if (SQLCODE)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"Error Rec.Datos Doc.Original",szfnORAerror ());
        vDTrazasError(szExeName,"\n\t**  Error Rec.Datos Doc.Original **"
                             "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (FALSE);
    }
	vDTrazasLog (szExeName, "\n\tbEsNotaCreditoTotal -  "
	                         "\n\tDatos doc. original:  cod_ciclfact[%s]"
	                        "\n\t                       IndOrdenTotal[%d]"
							"\n\t                       Ubicacion [%s]"	,
							LOG05, szhcod_ciclfact,lIndOrdenTotalOrig, szNomTabla);
	if (strcmp(szOrigen,"C")==0)  
	   *bDocOrigenCiclo=TRUE;
	else
	   *bDocOrigenCiclo=FALSE;
	   
	sprintf(szSql,       
       "SELECT SUM( IMP_FACTURABLE ), COUNT(1) "
       "FROM    %s "
       "WHERE   IND_ORDENTOTAL = :lIndOrdenTotal "
       "AND     COD_TIPCONCE   IN (2,3) "     
       ,szNomTabla);
    vDTrazasLog (szExeName, "\n\tbEsNotaCreditoTotal -  "
	                         "\n\tConsulta a ejecutar [%s]",
							LOG05, szSql);
    
	EXEC SQL PREPARE sql_fa_histconc FROM :szSql;
    if (SQLCODE)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"PREPARE sql_fa_histconc ",szfnORAerror ());
        vDTrazasError(szExeName,"\n\t**  Error en SQL-PREPARE sql_fa_histconc  **"
                            "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (FALSE);
    }
	
	EXEC SQL DECLARE Cur_HistConc CURSOR FOR sql_fa_histconc;
    if (SQLCODE)
    {
        iDError (szExeName,ERR000,vInsertarIncidencia,"DECLARE Cur_HistConc",szfnORAerror ());
        vDTrazasError(szExeName,"\n\t**  Error en SQL-DECLARE Cur_HistConc **"
                             "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (FALSE);
    }
	
	EXEC SQL OPEN Cur_HistConc USING :lIndOrdenTotalOrig;
    if (SQLCODE)
    { 
        iDError (szExeName,ERR000,vInsertarIncidencia,"OPEN Cur_HistConc",szfnORAerror ());
        vDTrazasError(szExeName,"\n\t**  Error en SQL-OPEN CURSOR Cur_HistConc **"
                             "\n\t\t=> Error : [%d]  [%s] ",LOG01,SQLCODE,SQLERRM);
        return  (FALSE);
    }
	
	EXEC SQL FETCH Cur_HistConc INTO  :dTotalConcDocOrig, :lCantConcDocOrig;

    if (SQLCODE != SQLOK && SQLCODE != SQLNOTFOUND)
    {
          iDError (szExeName,ERR000,vInsertarIncidencia,"Fetch=>Fa_HistConc", szfnORAerror ());
          return (FALSE);
    }
	 
	if ( dTotalConcPrefactura != dTotalConcDocOrig )
    {
	   *iEsNotaTotal = 0;
    }
    else
    {
	   *iEsNotaTotal = 1; 
    }
	 
   return (TRUE);
}
void bBuscaMontoDescto(int iInd, double *dMontoDescuento ){
   int i;
   int iCodConceptoActual;
   long lColumnaActual;
   long lNumAbonadoActual;
   *dMontoDescuento = 0.0;
   iCodConceptoActual = stPreFactura.A_PFactura[iInd].iCodConcepto;
   lColumnaActual = stPreFactura.A_PFactura[iInd].lColumna;
   lNumAbonadoActual = stPreFactura.A_PFactura[iInd].lNumAbonado;
   
   vDTrazasLog (szExeName, "\n\t\tEn funcion bBuscaMontoDescto\n", LOG05);
   
   for (i=0;i<stPreFactura.iNumRegistros;i++){
      if (stPreFactura.A_PFactura[i].iCodConceRel == iCodConceptoActual && 
	      stPreFactura.A_PFactura[i].lColumnaRel == lColumnaActual &&
		  stPreFactura.A_PFactura[i].lNumAbonado == lNumAbonadoActual &&
		  stPreFactura.A_PFactura[i].iCodTipConce == DESCUENTO)
	  {
	       vDTrazasLog (szExeName, "\n\t\t bBuscaMontoDescto Valor descuento encontrado [%d]\n", LOG05, stPreFactura.A_PFactura[i].dImpConcepto);
	      *dMontoDescuento += stPreFactura.A_PFactura[i].dImpConcepto;
	  }
		  
   }
 
}
/*P-CSR-12019*/
BOOL bCalculaMtoImptoDoctoUmbral (int iInd,             // concepto sobre el que aplico Impto
                            double dpImpConcepto,
							char *cpCodMonedaImp,
                            IMPUESTOS pImpuesto,  // info. impuesto 
							long lNumAbonado,   //P-CSR-12019
							ACUMIMPUESTOABONADOS *pAcumImptoAbonado, /*P-CSR-12019*/
							ACUMABONADO *pAcumAbonado, /*P-CSR-12019*/
                            double *dMtoImpuesto, // monto acumulado de impuesto
                            double *dMtoBase,     // monto acumulado base
							double *dMtoFacturable) /*P-CSR-12019*/
{
     double dImptoPorCompletar;
	 int    iInd1;
	 int    iExiste;
     int    iPos;
	 int    i;
	 double dImptoAcumAbonado;
	 double dMontoDescuento;
	 double dMontoConceptoNeto;
	 int iTotElementos;
	 iPos = 0;
	 iExiste = 0;
	 dImptoPorCompletar=0.0;
	 dMontoDescuento=0.0;
	 dMontoConceptoNeto=0.0;
	 *dMtoImpuesto = 0.0;
	 *dMtoBase = 0.0;
	 dImptoAcumAbonado = 0.0;
	  vDTrazasLog (szExeName, "\n\t\tEn funcion bCalculaMtoImptoDoctoUmbral\n", LOG05);

 
      iTotElementos = pAcumImptoAbonado->iNumAbonados;
	  for (i=0;i<pAcumImptoAbonado->iNumAbonados;i++){
	    if (lNumAbonado == pAcumImptoAbonado->stAcumImpto[i].lNumAbonado){
		    iExiste= 1;
			iPos = i;
			dImptoAcumAbonado = pAcumImptoAbonado->stAcumImpto[i].dImpTotal;
			break;
		} 
	 }
	 if (iExiste==0)
	 {
	     if ((pAcumImptoAbonado->stAcumImpto =
                    (ACUMIMPUESTO *)realloc( (ACUMIMPUESTO *)pAcumImptoAbonado->stAcumImpto,
                    (iTotElementos+1)*sizeof(ACUMIMPUESTO) ) ) == (ACUMIMPUESTO *)NULL)
      {
		 iDError (szExeName,ERR005,vInsertarIncidencia,"pAcumImptoAbonado->stAcumImpto");
		 strncpy (stAnomProceso.szObsAnomalia, "No se ha podido reservar Memoria",
											   strlen(stAnomProceso.szObsAnomalia));
		 return (FALSE);
      }else
	  {
	  	 pAcumImptoAbonado->iNumAbonados = iTotElementos+1;
         pAcumImptoAbonado->stAcumImpto[iTotElementos ].lNumAbonado =lNumAbonado;
	     pAcumImptoAbonado->stAcumImpto[iTotElementos ].dImpTotal = 0.0;
		 iPos=iTotElementos;
	  }
	 }
     if (pImpuesto.dImpMaximo > 0)
	       dImptoPorCompletar = pImpuesto.dImpMaximo - dImptoAcumAbonado;
	  else
	      dImptoPorCompletar = 9999999999;
	
	vDTrazasLog (szExeName, "\n\t\t bCalculaMtoImptoDoctoUmbral: dImptoAcumAbonado =[%f]"   
                            "\n\t\t bCalculaMtoImptoDoctoUmbral: dImptoPorCompletar   [%f]"   
                            "\n\t\t bCalculaMtoImptoDoctoUmbral: iPos  [%d]"   
                            "\n\t\t bCalculaMtoImptoDoctoUmbral: pImpuesto.dImpUmbral   [%f]"   
                            "\n\t\t bCalculaMtoImptoDoctoUmbral: pAcumAbonado->dImpTotal  [%f]"  , LOG05,
							dImptoAcumAbonado,dImptoPorCompletar,iPos, pImpuesto.dImpUmbral,  pAcumAbonado->dImpTotal );
     if (dImptoPorCompletar > 0) {
        if (pAcumAbonado->dImpTotal >= pImpuesto.dImpUmbral) {
  	       bBuscaMontoDescto(iInd, &dMontoDescuento ) ;
 
		   dMontoConceptoNeto = dpImpConcepto+dMontoDescuento;
		   
           if ( pImpuesto.iTipMonto == PORCENTUAL )
            { // acumula
              *dMtoImpuesto +=
               (double)(pImpuesto.fPrcImpuesto * dMontoConceptoNeto )/100;
            }
            else 
            { // asigna 
               *dMtoImpuesto = (double)(pImpuesto.fPrcImpuesto) ;
            }
			 *dMtoBase = dMontoConceptoNeto;
			if (*dMtoImpuesto > dImptoPorCompletar) {
			   
			   *dMtoBase = (double)((dMontoConceptoNeto * dImptoPorCompletar) / *dMtoImpuesto) ;
			   *dMtoImpuesto = dImptoPorCompletar;
			}
			   
		     pAcumImptoAbonado->stAcumImpto[iPos].dImpTotal +=  *dMtoImpuesto;
			 *dMtoFacturable = *dMtoImpuesto;
			if (!bConversionMoneda (stCliente.lCodCliente                          ,
                            cpCodMonedaImp      ,
                            stDatosGener.szCodMoneFact                     ,
                            szSysDate                                      ,
                            dMtoFacturable))
            {
                return FALSE;
            } /* P-MIX-09003 4 */
	     }
     }

     vDTrazasLog (szExeName, "\n\t\t* Calculo Impuesto :\n"
                            "\t\t=> iInd           [%d]\n"
                            "\t\t=> Prc. Impuesto  [%f]\n"
                            "\t\t=> Mto. Acumulado [%f]\n"
                            "\t\t=> Mto. Base      [%f]\n"
							"\t\t=> Descuento      [%f]\n"
							"\t\t=> Mto facturable [%f]\n"
                          , LOG05
                          , iInd, pImpuesto.fPrcImpuesto
                          , *dMtoImpuesto
                          , *dMtoBase,dMontoDescuento,*dMtoFacturable); 
                       
    return (TRUE);
}/**************************  Final bCalculaImptos ***************************/

BOOL bCalculaMtoImptoNotaCredUmbral (int iInd,             // concepto sobre el que aplico Impto
                            double dpImpConcepto,
							char *cpCodMonedaImp,
                            IMPUESTOS pImpuesto,  // info. impuesto 
							DETIMPTOSTIPO*  pAcumImptoTipo,
							long lNumAbonado,   //P-CSR-12019
                            double *dMtoImpuesto, // monto acumulado de impuesto
                            double *dMtoBase,     // monto acumulado base
							double *dMtoFacturable) /*P-CSR-12019*/
{
	 double dMontoConceptoNeto;

	 dMontoConceptoNeto=0.0;
	 *dMtoImpuesto = 0.0;
	 *dMtoBase = 0.0;
	 
	 vDTrazasLog (szExeName, "\n\t\tEn funcion bCalculaMtoImptoNotaCredUmbral\n", LOG03);

	 
    dMontoConceptoNeto = dpImpConcepto;
		   
    if ( pImpuesto.iTipMonto == PORCENTUAL )
    { // acumula
         *dMtoImpuesto +=  (double)(pImpuesto.fPrcImpuesto * dMontoConceptoNeto )/100;
    }
    else 
    { // asigna 
         *dMtoImpuesto = (double)(pImpuesto.fPrcImpuesto) ;
    }
	vDTrazasLog (szExeName, "\n\t\t* Impuesto acumulado NC [%f] Impuesto Acum doc. original [%f] Impuesto calculado [%f]",  LOG05, pAcumImptoTipo->dAcumImpuestoNCred,  pAcumImptoTipo->dAcumImpuestoOrig, *dMtoImpuesto);		
	
	if (pAcumImptoTipo->dAcumImpuestoNCred == pAcumImptoTipo->dAcumImpuestoOrig)
    {
	     *dMtoImpuesto = 0.0;
    }else 
	{ 
	    if ((pAcumImptoTipo->dAcumImpuestoNCred + *dMtoImpuesto) > pAcumImptoTipo->dAcumImpuestoOrig)
	       *dMtoImpuesto =  pAcumImptoTipo->dAcumImpuestoOrig - pAcumImptoTipo->dAcumImpuestoNCred;
	}
			
	*dMtoBase = dMontoConceptoNeto;
    *dMtoFacturable = *dMtoImpuesto;
	if (!bConversionMoneda (stCliente.lCodCliente                          ,
                            cpCodMonedaImp      ,
                            stDatosGener.szCodMoneFact                     ,
                            szSysDate                                      ,
                            dMtoFacturable))
    {
         return FALSE;
    } /* P-MIX-09003 4 */
  

     vDTrazasLog (szExeName, "\n\t\t* Calculo Impuesto :\n"
                            "\t\t=> iInd              [%d]\n"
                            "\t\t=> Prc. Impuesto     [%f]\n"
							"\t\t=> Monto calculo ini [%f]\n"
                            "\t\t=> Mto. Acumulado    [%f]\n"
                            "\t\t=> Mto. Base         [%f]\n"
							"\t\t=> Mto facturable    [%f]\n"
                          , LOG05
                          , iInd, pImpuesto.fPrcImpuesto
						  ,dpImpConcepto
                          , *dMtoImpuesto
                          , *dMtoBase,*dMtoFacturable); 
                       
    return (TRUE);
}

BOOL bCalculaMtoImptoDocto (int iInd,             // concepto sobre el que aplico Impto
                            IMPUESTOS pImpuesto,  // info. impuesto 
                            double *dMtoImpuesto, // monto acumulado de impuesto
                            double *dMtoBase)     // monto acumulado base
{

	*dMtoImpuesto  = 0.0;
 
            if ( pImpuesto.iTipMonto == PORCENTUAL )
            { // acumula
              *dMtoImpuesto +=
               (double)(pImpuesto.fPrcImpuesto * stPreFactura.A_PFactura[iInd].dImpConcepto)/100;
            }
            else
            { // asigna 
               *dMtoImpuesto = (double)(pImpuesto.fPrcImpuesto) ;
            }
 
       
	  *dMtoBase += stPreFactura.A_PFactura[iInd].dImpConcepto; 
      /* INC 177256 LIA 02112011  */
     *dMtoBase = stPreFactura.A_PFactura[iInd].dImpConcepto;
  
     vDTrazasLog (szExeName, "\n\t\t* Calculo Impuesto :\n"
                            "\t\t=> iInd           [%d]\n"
                            "\t\t=> Prc. Impuesto  [%f]\n"
                            "\t\t=> Mto. Acumulado [%f]\n"
                            "\t\t=> Mto. Base      [%f]\n"
                          , LOG05
                          , iInd, pImpuesto.fPrcImpuesto
                          , *dMtoImpuesto
                          , *dMtoBase); 
                          
    return (TRUE);
}/**************************  Final bCalculaImptos ***************************/

/*****************************************************************************/
/*                      funcion : bfnAplicaImptoDocto                        */
/*  Aplica los campos al nuevo concepto de impuesto                          */
/*****************************************************************************/
BOOL bfnAplicaImptoDocto (IMPUESTOS* pImpto, long iIdxOri, int iTipoFact
                         , double pdMtoImpto, double pdMtoBase)
{
    CONCEPTO stConcepto ;
    int iIdxFin;
    
    memset (&stConcepto,0,sizeof(CONCEPTO));
    
    iIdxFin = stPreFactura.iNumRegistros;


    if (!bFindConcepto (pImpto->iCodConcGene,
                        &stConcepto))
    {
        vDTrazasLog  (szExeName,">> ERROR: buscando detalle conceptos  <<",LOG01);
        return FALSE;
    }

    // rao prueba de copiar completo el concepto 
    memcpy (&stPreFactura.A_PFactura[iIdxFin], &stPreFactura.A_PFactura[iIdxOri], sizeof (FAPFACTURA));

    if (!bGetMaxColPreFa(pImpto->iCodConcGene, &stPreFactura.A_PFactura[iIdxFin].lColumna ))
        return FALSE;
    
    stPreFactura.A_PFactura[iIdxFin].iCodConcepto = pImpto->iCodConcGene ;

    strcpy (stPreFactura.A_PFactura[iIdxFin].szDesConcepto, stConcepto.szDesConcepto);
    stPreFactura.A_PFactura[iIdxFin].fPrcImpuesto = pImpto->fPrcImpuesto;

    if (pdMtoImpto > pImpto->dImpMaximo)
        pdMtoImpto =  pImpto->dImpMaximo;
     
    stPreFactura.A_PFactura[iIdxFin].dImpConcepto  = pdMtoImpto;
    stPreFactura.A_PFactura[iIdxFin].dImpMontoBase = pdMtoBase;
    stPreFactura.A_PFactura[iIdxFin].dImpFacturable = fnCnvDouble (pdMtoImpto,0);

    vDTrazasLog (szExeName, "\n\t\t* Calculo Impuesto Docto:"
                            "\n\t\t=> iNumReg        [%d]"
                            "\n\t\t=> Mto. Impuesto  [%f]"
                            "\n\t\t=> Mto. Base      [%f]"
                            "\n\t\t=> Monto Neto     [%f]"
                            "\n\t\t=> Monto Facturable [%f]"
                          , LOG05
                          , iIdxFin, pdMtoImpto, pdMtoBase
                          , stPreFactura.A_PFactura[iIdxFin].dImpConcepto
                          , stPreFactura.A_PFactura[iIdxFin].dImpFacturable);

    stPreFactura.A_PFactura[iIdxFin].bOptImpuesto = TRUE;
                                    
    switch (iTipoFact)
    {
        case FACT_CICLO      :
        case FACT_BAJA       :
            strcpy (stPreFactura.A_PFactura[iIdxFin].szFecValor , stCiclo.szFecEmision);
            break;
        case FACT_CONTADO    :
        case FACT_COMPRA     :
        case FACT_MISCELAN   :
        case FACT_LIQUIDACION:
        case FACT_RENTAPHONE :
        case FACT_ROAMINGVIS :
            strcpy (stPreFactura.A_PFactura[iIdxFin].szFecValor, szSysDate);
            break;
        default              :
            break;
    }

    strcpy(stPreFactura.A_PFactura[iIdxFin].szFecEfectividad, szSysDate);
    stPreFactura.A_PFactura[iIdxFin].iIndEstado    = EST_NORMAL;
    stPreFactura.A_PFactura[iIdxOri].iIndEstado    = EST_IMPTO ;
    stPreFactura.A_PFactura[iIdxFin].iCodTipConce  = IMPUESTO  ;
    stPreFactura.A_PFactura[iIdxFin].lNumUnidades  = 1;
    stPreFactura.A_PFactura[iIdxFin].lCodCiclFact  = stCiclo.lCodCiclFact;
    stPreFactura.A_Ind[iIdxFin].i_lCodCiclFact     = (stCiclo.lCodCiclFact == ORA_NULL)?ORA_NULL:SQLOK;
    stPreFactura.A_PFactura[iIdxFin].iCodConceRel  = stPreFactura.A_PFactura[iIdxOri].iCodConcepto;
    stPreFactura.A_PFactura[iIdxFin].lColumnaRel   = stPreFactura.A_PFactura[iIdxOri].lColumna ;
    stPreFactura.A_PFactura[iIdxFin].lNumAbonado   = stPreFactura.A_PFactura[iIdxOri].lNumAbonado;
    stPreFactura.A_Ind[iIdxFin].i_lNumAbonado      = (stPreFactura.A_PFactura[iIdxOri].lNumAbonado == ORA_NULL)?-1:0 ;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szNumTerminal , "" );
    stPreFactura.A_Ind[iIdxFin].i_szNumTerminal    =  -1;
    stPreFactura.A_Ind[iIdxFin].i_lCapCode         =  (stPreFactura.A_PFactura[iIdxOri].lCapCode   == ORA_NULL)?-1:0    ;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szNumSerieMec , "" );
    stPreFactura.A_Ind[iIdxFin].i_szNumSerieMec    = -1;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szNumSerieLe  , "" );
    stPreFactura.A_Ind[iIdxFin].i_szNumSerieLe     = -1;
    stPreFactura.A_PFactura[iIdxFin].iFlagImpues   = 0 ;
    stPreFactura.A_PFactura[iIdxOri].iFlagImpues   = 1 ;
    stPreFactura.A_PFactura[iIdxFin].iFlagDto      = 0 ;
    stPreFactura.A_PFactura[iIdxFin].iFlagDto      = 0 ;
    stPreFactura.A_PFactura[iIdxFin].dValDto       = -1;
    stPreFactura.A_Ind[iIdxFin].i_dValDto          = -1;
    stPreFactura.A_PFactura[iIdxFin].iTipDto       = -1;
    stPreFactura.A_Ind[iIdxFin].i_iTipDto          = -1;
    stPreFactura.A_PFactura[iIdxFin].lNumVenta     = -1;
    stPreFactura.A_Ind[iIdxFin].i_lNumVenta        = -1;

    stPreFactura.A_PFactura[iIdxFin].lNumTransaccion = -1 ;
    stPreFactura.A_Ind[iIdxFin].i_lNumTransaccion    = -1;
    stPreFactura.A_PFactura[iIdxFin].iMesGarantia   = 0;
    stPreFactura.A_PFactura[iIdxFin].iIndAlta       = 1;
    stPreFactura.A_PFactura[iIdxFin].iIndSuperTel   = 0;
    stPreFactura.A_PFactura[iIdxFin].iNumPaquete    =-1;
    stPreFactura.A_Ind[iIdxFin].i_iNumPaquete       =-1;
    stPreFactura.A_PFactura[iIdxFin].iIndCuota      = 0;
    stPreFactura.A_PFactura[iIdxFin].iNumCuotas     = 0;
    stPreFactura.A_PFactura[iIdxFin].iOrdCuota      = 0;

    /* stPreFactura.iNumRegistros++; */
    if(bfnIncrementarIndicePreFactura()==FALSE) 
    {
        vDTrazasLog  (szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        vDTrazasError(szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        return FALSE;
    }

    return(TRUE);
}
BOOL bfnAplicaImptoDocto2 (IMPUESTOS* pImpto, long iIdxOri, int iTipoFact
                         , double pdMtoImpto, double pdMtoBase, double pdMtoFacturable)
{
    CONCEPTO stConcepto ;
    int iIdxFin;
    
    memset (&stConcepto,0,sizeof(CONCEPTO));
    
    iIdxFin = stPreFactura.iNumRegistros;


    if (!bFindConcepto (pImpto->iCodConcGene,
                        &stConcepto))
    {
        vDTrazasLog  (szExeName,">> ERROR: buscando detalle conceptos  <<",LOG01);
        return FALSE;
    }

    // rao prueba de copiar completo el concepto 
    memcpy (&stPreFactura.A_PFactura[iIdxFin], &stPreFactura.A_PFactura[iIdxOri], sizeof (FAPFACTURA));

    if (!bGetMaxColPreFa(pImpto->iCodConcGene, &stPreFactura.A_PFactura[iIdxFin].lColumna ))
        return FALSE;
    
    stPreFactura.A_PFactura[iIdxFin].iCodConcepto = pImpto->iCodConcGene ;

    strcpy (stPreFactura.A_PFactura[iIdxFin].szDesConcepto, stConcepto.szDesConcepto);
    stPreFactura.A_PFactura[iIdxFin].fPrcImpuesto = pImpto->fPrcImpuesto;
     
    stPreFactura.A_PFactura[iIdxFin].dImpConcepto  = pdMtoImpto;
    stPreFactura.A_PFactura[iIdxFin].dImpMontoBase = pdMtoBase;
    stPreFactura.A_PFactura[iIdxFin].dImpFacturable = fnCnvDouble (pdMtoFacturable,0);

    vDTrazasLog (szExeName, "\n\t\t* Calculo Impuesto Docto:"
                            "\n\t\t=> iNumReg        [%d]"
                            "\n\t\t=> Mto. Impuesto  [%f]"
                            "\n\t\t=> Mto. Base      [%f]"
                            "\n\t\t=> Monto Neto     [%f]"
                            "\n\t\t=> Monto Facturable [%f]"
                          , LOG05
                          , iIdxFin, pdMtoImpto, pdMtoBase
                          , stPreFactura.A_PFactura[iIdxFin].dImpConcepto
                          , stPreFactura.A_PFactura[iIdxFin].dImpFacturable);

    stPreFactura.A_PFactura[iIdxFin].bOptImpuesto = TRUE;
    stPreFactura.A_PFactura[iIdxFin].dImpFactConIva   = 0;                               
    switch (iTipoFact)
    {
        case FACT_CICLO      :
        case FACT_BAJA       :
            strcpy (stPreFactura.A_PFactura[iIdxFin].szFecValor , stCiclo.szFecEmision);
            break;
        case FACT_CONTADO    :
        case FACT_COMPRA     :
        case FACT_MISCELAN   :
        case FACT_LIQUIDACION:
        case FACT_RENTAPHONE :
        case FACT_ROAMINGVIS :
            strcpy (stPreFactura.A_PFactura[iIdxFin].szFecValor, szSysDate);
            break;
        default              :
            break;
    }

    strcpy(stPreFactura.A_PFactura[iIdxFin].szFecEfectividad, szSysDate );
    stPreFactura.A_PFactura[iIdxFin].iIndEstado    = EST_NORMAL;
    stPreFactura.A_PFactura[iIdxOri].iIndEstado    = EST_IMPTO ;
    stPreFactura.A_PFactura[iIdxFin].iCodTipConce  = IMPUESTO  ;
    stPreFactura.A_PFactura[iIdxFin].lNumUnidades  = 1;
    stPreFactura.A_PFactura[iIdxFin].lCodCiclFact  = stCiclo.lCodCiclFact;
    stPreFactura.A_Ind[iIdxFin].i_lCodCiclFact     = (stCiclo.lCodCiclFact == ORA_NULL)?ORA_NULL:SQLOK;
    stPreFactura.A_PFactura[iIdxFin].iCodConceRel  = stPreFactura.A_PFactura[iIdxOri].iCodConcepto;
    stPreFactura.A_PFactura[iIdxFin].lColumnaRel   = stPreFactura.A_PFactura[iIdxOri].lColumna ;
    stPreFactura.A_PFactura[iIdxFin].lNumAbonado   = stPreFactura.A_PFactura[iIdxOri].lNumAbonado;
    stPreFactura.A_Ind[iIdxFin].i_lNumAbonado      = (stPreFactura.A_PFactura[iIdxOri].lNumAbonado == ORA_NULL)?-1:0 ;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szNumTerminal , "" );
    stPreFactura.A_Ind[iIdxFin].i_szNumTerminal    =  -1;
    stPreFactura.A_Ind[iIdxFin].i_lCapCode         =  (stPreFactura.A_PFactura[iIdxOri].lCapCode   == ORA_NULL)?-1:0    ;
    strcpy(stPreFactura.A_PFactura[iIdxFin].szNumSerieMec , "" );
    stPreFactura.A_Ind[iIdxFin].i_szNumSerieMec    = -1;
  //  strcpy(stPreFactura.A_PFactura[iIdxFin].szNumSerieLe  , "" );
    stPreFactura.A_PFactura[iIdxFin].dImpFactConIva = 0;
    stPreFactura.A_Ind[iIdxFin].i_szNumSerieLe     = (strcmp(stPreFactura.A_PFactura[iIdxOri].szNumSerieLe ,"")==0)?-1:0;
    stPreFactura.A_PFactura[iIdxFin].iFlagImpues   = 0 ;
    stPreFactura.A_PFactura[iIdxOri].iFlagImpues   = 1 ;
    stPreFactura.A_PFactura[iIdxFin].iFlagDto      = 0 ;
    stPreFactura.A_PFactura[iIdxFin].iFlagDto      = 0 ;
    stPreFactura.A_PFactura[iIdxFin].dValDto       = -1;
    stPreFactura.A_Ind[iIdxFin].i_dValDto          = -1;
    stPreFactura.A_PFactura[iIdxFin].iTipDto       = -1;
    stPreFactura.A_Ind[iIdxFin].i_iTipDto          = -1;
    stPreFactura.A_PFactura[iIdxFin].lNumVenta     = 0;
    stPreFactura.A_Ind[iIdxFin].i_lNumVenta        = 0;

    stPreFactura.A_PFactura[iIdxFin].lNumTransaccion = -1 ;
    stPreFactura.A_Ind[iIdxFin].i_lNumTransaccion    = -1;
    stPreFactura.A_PFactura[iIdxFin].iMesGarantia   = 0;
    stPreFactura.A_PFactura[iIdxFin].iIndAlta       = 1;
    stPreFactura.A_PFactura[iIdxFin].iIndSuperTel   = 0;
    stPreFactura.A_PFactura[iIdxFin].iNumPaquete    =-1;
    stPreFactura.A_Ind[iIdxFin].i_iNumPaquete       =-1;
    stPreFactura.A_PFactura[iIdxFin].iIndCuota      = 0;
    stPreFactura.A_PFactura[iIdxFin].iNumCuotas     = 0;
    stPreFactura.A_PFactura[iIdxFin].iOrdCuota      = 0;

    /* stPreFactura.iNumRegistros++; */
    if(bfnIncrementarIndicePreFactura()==FALSE) 
    {
        vDTrazasLog  (szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        vDTrazasError(szExeName,">> ERROR: Al Intentar Aumentar memoria de stPreFactura  <<",LOG01);
        return FALSE;
    }

    return(TRUE);
}

/*****************************************************************************/
/*                      funcion : bImptosDoctoNotas                          */
/*  Aplica impuestos de tipo documento con rangos a las NC                   */
/*****************************************************************************/
BOOL bImptosDoctoNotas (int iTipoFact)
{
char  modulo[] = "bImptosDoctoNotas";

  int  iNumRegIni    = 0;
  int  iInd          = 0;
  int  i             = 0;
  int  iNImptos      = 0;
  int  iCodZonaAbon  = 0;
  int  iCodGrpServi  = 0;
  long lIndConc      = 0L;
  double   dMtoImpuesto, dMtoBase, dMtoImptoOri, dMtoBaseOri = 0.0;
  double   dMtoImpuestoAux, dMtoBaseAux = 0.0; /* PGG - 177256 - 2/11/2011 */
  IMPTOS   stImpto = {0,(IMPUESTOS *)NULL};
  

    vDTrazasLog (szExeName,"\n\t\t* IMPUESTOS DOCUMENTOS NOTA CREDITO"
                           "\n\t\t=> Cat. Impositiva       [%d]"
                           "\n\t\t=> Zona Impositiva       [%d]"
                           "\n\t\t=> Fecha Zona Impositiva [%s]"
                           , LOG05,stCliente.iCodCatImpos
                           , stNota.iCodZonaImpo, stNota.szFecEmision);
    
    if (! bGetImpuestosDocto (stCliente.iCodCatImpos,stNota.iCodZonaImpo
                            , stNota.szFecEmision, &stImpto, iTipoFact))
    {
        vFreeImpuestos(&stImpto);
        return FALSE;
    }
    vDTrazasLog (modulo,"\t\t* Numero de Impuestos [%d]",LOG05
                        ,stImpto.iNumImpuestos);

    for (iInd=0;iInd<stImpto.iNumImpuestos;iInd++)
    {    
        iNumRegIni = stPreFactura.iNumRegistros;
        for (i=0;i<iNumRegIni;i++)
        {
            if (stPreFactura.A_PFactura[i].iFlagImpues  == 1        &&
                stPreFactura.A_PFactura[i].iCodTipConce != IMPUESTO &&
                stPreFactura.A_PFactura[i].iIndCuota    <= 0 )
            {
                if (!bGetGrupoServicios (stPreFactura.A_PFactura[i].iCodConcepto,
                                         &iCodGrpServi,stNota.szFecEmision,iTipoFact))
                    return FALSE; // error el concepto no tiene asociado grupo
    
                if (stImpto.pImpuestos [iInd].iCodGrpServi != iCodGrpServi)
                {
                    /* no aplica al concepto */
                    continue;
                }
                if (stPreFactura.A_PFactura[i].iCodZonaAbon == -1)
                    iCodZonaAbon = stNota.iCodZonaImpo;
                else
                    /* Se considera para los conceptos con abonado 0 la zona impositiva del Cliente. */
                    /* iCodZonaAbon = stPreFactura.A_PFactura.iCodZonaAbon[i]; */
                    if (stPreFactura.A_PFactura[i].lNumAbonado  == 0 && stPreFactura.A_PFactura[i].iCodZonaAbon == 0)
                       iCodZonaAbon = stNota.iCodZonaImpo;
                    else
                       iCodZonaAbon = stPreFactura.A_PFactura[i].iCodZonaAbon;
    
                vDTrazasLog (modulo, "\t\t* Cod.ZonaAbon [%i]",LOG06, iCodZonaAbon);
                if (stImpto.pImpuestos [iInd].iCodZonaAbon != iCodZonaAbon )
                    continue;  /* no es afecto al impuesto */

                if (!bCalculaMtoImptoDocto (i,stImpto.pImpuestos[iInd]
                                           , &dMtoImpuesto, &dMtoBase ))
                {
                    vFreeImpuestos(&stImpto);
                    return FALSE;
                }
                lIndConc = i; // guarda el ultimo concepto afecto

/* PGG - CAMBIO DE POSICION DE TODO ESTE BLOQUE... LO METO DENTRO DEL FOR - 03/11/2011 - 177256 - DESDE AQUI */
				        if (dMtoImpuesto)  // es afecto  
				        {
				            if (!bfnValidaImptoDocto(stImpto.pImpuestos[iInd].iCodConcGene, &dMtoImptoOri,&dMtoBaseOri))
				            {
				                vDTrazasError(modulo,"\n\t** ERROR, obtener monto impuestos origen **",LOG02);
				                return FALSE;
				            }
				            vDTrazasLog (szExeName,"\t\tMto. base Original [%f]\tMto. Impto Original [%f]\n"
				                                   "\t\tMto. base NC       [%f]\tMto. Impto NC       [%f]"
				                                  ,LOG06, dMtoBaseOri, dMtoImptoOri
				                                  , dMtoBase, dMtoImpuesto);
				                                  
				            if (dMtoImpuesto > dMtoImptoOri ) // Impto Original es menor que el de la NC
				                dMtoImpuesto = dMtoImptoOri; 
				            else
				            { 
				                dMtoImpuesto = dMtoImptoOri *  (dMtoBase / dMtoBaseOri); // aplica porcentualmente el impto.
				            }
										
										dMtoImpuestoAux += dMtoImpuesto; 	/* PGG - 177256 - 2/11/2011 */
				        		dMtoBaseAux +=dMtoBase;						/* PGG - 177256 - 2/11/2011 */
				
				/*
				            // generacion de concepto de impuesto  
				            if (!bfnAplicaImptoDocto( &stImpto.pImpuestos[iInd], lIndConc
				                                    , iTipoFact, dMtoImpuesto, dMtoBase))
				            {
				                vDTrazasError(modulo,"\n\t** ERROR, en creacion del concepto de Impto. **",LOG01);
				                vFreeImpuestos(&stImpto);
				                return (FALSE);
				            }
				            iNImptos++;
				*/
				            
				        }
/* PGG - CAMBIO DE POSICION DE TODO ESTE BLOQUE... LO METO DENTRO DEL FOR - 03/11/2011 - 177256 - DESDE AQUI */

            }
        }

    }/* fin for Impuestos */

/* PGG - 177256 - 2/11/2011 - DESDE AQUI */

		if (stImpto.iNumImpuestos > 0)
		{
	    if (dMtoImpuestoAux >= stImpto.pImpuestos[0].dImpUmbral )
	    {
	        // generacion de concepto de impuesto  
	        if (!bfnAplicaImptoDocto( &stImpto.pImpuestos[0], lIndConc 
	                                , iTipoFact, dMtoImpuestoAux, dMtoBaseAux))
	        {
	            vDTrazasError(modulo,"\n\t** ERROR, en creacion del concepto de Impto. **",LOG01);
	            vFreeImpuestos(&stImpto);
	            return (FALSE);
	        }
	        iNImptos++;
	    }
		}
/* PGG - 177256 - 2/11/2011 - HASTA AQUI */		


    vFreeImpuestos(&stImpto);
    iNImptosT += iNImptos;

    vDTrazasLog (szExeName,"\n\t\tCantidad de Impuestos Aplicados NC [%d]",
               LOG04, iNImptosT);
    return TRUE;
}/**************************** Final bImptosIvaNotas *************************/


// obtiene el monto de los conceptos de impuesto
BOOL bfnValidaImptoDocto(long lCondConcepto, double *dMtoImpuesto, double *dMtoBase)
{
    long  lInd = 0L;

    *dMtoImpuesto = 0.0;
    *dMtoBase     = 0.0;    
    
    for (lInd=0; lInd< stNota.iNumConceptos ;lInd++)
    {
        if ( stNota.A_HistConc.iCodConcepto[lInd]  == lCondConcepto &&  
             stNota.A_HistConc.iCodTipConce[lInd]  == IMPUESTO )
        {
            *dMtoImpuesto += stNota.A_HistConc.dImpFacturable[lInd];
            *dMtoBase     += stNota.A_HistConc.dImpMontoBase [lInd];
        }            
    }

    return TRUE;
} 

/******************************************************************************************/
/** Informacion de Versionado *************************************************************/
/******************************************************************************************/
/** Pieza                                               : */
/**  %ARCHIVE% */
/** Identificador en PVCS                               : */
/**  %PID% */
/** Producto                                            : */
/**  %PP% */
/** Revisiï¿½                                            : */
/**  %PR% */
/** Autor de la Revision                                 : */
/**  %AUTHOR% */
/** Estado de la Revision  ($TO_BE_DEFINED es Check-Out) : */
/**  %PS% */
/** Fecha de Creacion de la Revision                     : */
/**  %DATE% */
/** Worksets ******************************************************************************/
/** %PIRW% */
/** Historia ******************************************************************************/
/** %PL% */
/******************************************************************************************/
